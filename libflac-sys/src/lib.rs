/* automatically generated by rust-bindgen 0.69.2 */

#![allow(non_upper_case_globals, non_camel_case_types, non_snake_case)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
  storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
  #[inline]
  pub const fn new(storage: Storage) -> Self {
    Self { storage }
  }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
  Storage: AsRef<[u8]> + AsMut<[u8]>,
{
  #[inline]
  pub fn get_bit(&self, index: usize) -> bool {
    debug_assert!(index / 8 < self.storage.as_ref().len());
    let byte_index = index / 8;
    let byte = self.storage.as_ref()[byte_index];
    let bit_index = if cfg!(target_endian = "big") {
      7 - (index % 8)
    } else {
      index % 8
    };
    let mask = 1 << bit_index;
    byte & mask == mask
  }
  #[inline]
  pub fn set_bit(&mut self, index: usize, val: bool) {
    debug_assert!(index / 8 < self.storage.as_ref().len());
    let byte_index = index / 8;
    let byte = &mut self.storage.as_mut()[byte_index];
    let bit_index = if cfg!(target_endian = "big") {
      7 - (index % 8)
    } else {
      index % 8
    };
    let mask = 1 << bit_index;
    if val {
      *byte |= mask;
    } else {
      *byte &= !mask;
    }
  }
  #[inline]
  pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
    debug_assert!(bit_width <= 64);
    debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
    debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
    let mut val = 0;
    for i in 0..(bit_width as usize) {
      if self.get_bit(i + bit_offset) {
        let index = if cfg!(target_endian = "big") {
          bit_width as usize - 1 - i
        } else {
          i
        };
        val |= 1 << index;
      }
    }
    val
  }
  #[inline]
  pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
    debug_assert!(bit_width <= 64);
    debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
    debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
    for i in 0..(bit_width as usize) {
      let mask = 1 << i;
      let val_bit_is_set = val & mask == mask;
      let index = if cfg!(target_endian = "big") {
        bit_width as usize - 1 - i
      } else {
        i
      };
      self.set_bit(index + bit_offset, val_bit_is_set);
    }
  }
}
pub const FLAC_API_VERSION_CURRENT: u32 = 14;
pub const FLAC_API_VERSION_REVISION: u32 = 0;
pub const FLAC_API_VERSION_AGE: u32 = 2;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const __bool_true_false_are_defined: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const FLAC__MAX_METADATA_TYPE_CODE: u32 = 126;
pub const FLAC__MIN_BLOCK_SIZE: u32 = 16;
pub const FLAC__MAX_BLOCK_SIZE: u32 = 65535;
pub const FLAC__SUBSET_MAX_BLOCK_SIZE_48000HZ: u32 = 4608;
pub const FLAC__MAX_CHANNELS: u32 = 8;
pub const FLAC__MIN_BITS_PER_SAMPLE: u32 = 4;
pub const FLAC__MAX_BITS_PER_SAMPLE: u32 = 32;
pub const FLAC__REFERENCE_CODEC_MAX_BITS_PER_SAMPLE: u32 = 32;
pub const FLAC__MAX_SAMPLE_RATE: u32 = 1048575;
pub const FLAC__MAX_LPC_ORDER: u32 = 32;
pub const FLAC__SUBSET_MAX_LPC_ORDER_48000HZ: u32 = 12;
pub const FLAC__MIN_QLP_COEFF_PRECISION: u32 = 5;
pub const FLAC__MAX_QLP_COEFF_PRECISION: u32 = 15;
pub const FLAC__MAX_FIXED_ORDER: u32 = 4;
pub const FLAC__MAX_RICE_PARTITION_ORDER: u32 = 15;
pub const FLAC__SUBSET_MAX_RICE_PARTITION_ORDER: u32 = 8;
pub const FLAC__STREAM_SYNC_LENGTH: u32 = 4;
pub const FLAC__STREAM_METADATA_STREAMINFO_LENGTH: u32 = 34;
pub const FLAC__STREAM_METADATA_SEEKPOINT_LENGTH: u32 = 18;
pub const FLAC__STREAM_METADATA_HEADER_LENGTH: u32 = 4;
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX: &[u8; 1] = b"\0";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING: u32 = 32;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const BUFSIZ: u32 = 512;
pub const _NSTREAM_: u32 = 512;
pub const _IOB_ENTRIES: u32 = 3;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 64;
pub const _IONBF: u32 = 4;
pub const L_tmpnam: u32 = 260;
pub const L_tmpnam_s: u32 = 260;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const FILENAME_MAX: u32 = 260;
pub const FOPEN_MAX: u32 = 20;
pub const _SYS_OPEN: u32 = 20;
pub const TMP_MAX: u32 = 2147483647;
pub const TMP_MAX_S: u32 = 2147483647;
pub const _TMP_MAX_S: u32 = 2147483647;
pub const SYS_OPEN: u32 = 20;
pub const FLAC__STREAM_ENCODER_SET_NUM_THREADS_OK: u32 = 0;
pub const FLAC__STREAM_ENCODER_SET_NUM_THREADS_NOT_COMPILED_WITH_MULTITHREADING_ENABLED: u32 = 1;
pub const FLAC__STREAM_ENCODER_SET_NUM_THREADS_ALREADY_INITIALIZED: u32 = 2;
pub const FLAC__STREAM_ENCODER_SET_NUM_THREADS_TOO_MANY_THREADS: u32 = 3;
extern "C" {
  #[doc = " \\c 1 if the library has been compiled with support for Ogg FLAC, else \\c 0."]
  pub static mut FLAC_API_SUPPORTS_OGG_FLAC: ::std::os::raw::c_int;
}
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
  pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
  pub fn __security_init_cookie();
}
extern "C" {
  pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
  pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
  pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
  pub fn _invalid_parameter_noinfo();
}
extern "C" {
  pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
  pub fn _invoke_watson(
    _Expression: *const wchar_t,
    _FunctionName: *const wchar_t,
    _FileName: *const wchar_t,
    _LineNo: ::std::os::raw::c_uint,
    _Reserved: usize,
  ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
  pub _locale_pctype: *const ::std::os::raw::c_ushort,
  pub _locale_mb_cur_max: ::std::os::raw::c_int,
  pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
  const UNINIT: ::std::mem::MaybeUninit<__crt_locale_data_public> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<__crt_locale_data_public>(),
    16usize,
    concat!("Size of: ", stringify!(__crt_locale_data_public))
  );
  assert_eq!(
    ::std::mem::align_of::<__crt_locale_data_public>(),
    8usize,
    concat!("Alignment of ", stringify!(__crt_locale_data_public))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__crt_locale_data_public),
      "::",
      stringify!(_locale_pctype)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__crt_locale_data_public),
      "::",
      stringify!(_locale_mb_cur_max)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(__crt_locale_data_public),
      "::",
      stringify!(_locale_lc_codepage)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
  pub locinfo: *mut __crt_locale_data,
  pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
  const UNINIT: ::std::mem::MaybeUninit<__crt_locale_pointers> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<__crt_locale_pointers>(),
    16usize,
    concat!("Size of: ", stringify!(__crt_locale_pointers))
  );
  assert_eq!(
    ::std::mem::align_of::<__crt_locale_pointers>(),
    8usize,
    concat!("Alignment of ", stringify!(__crt_locale_pointers))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__crt_locale_pointers),
      "::",
      stringify!(locinfo)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__crt_locale_pointers),
      "::",
      stringify!(mbcinfo)
    )
  );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
  pub _Wchar: ::std::os::raw::c_ulong,
  pub _Byte: ::std::os::raw::c_ushort,
  pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
  const UNINIT: ::std::mem::MaybeUninit<_Mbstatet> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<_Mbstatet>(),
    8usize,
    concat!("Size of: ", stringify!(_Mbstatet))
  );
  assert_eq!(
    ::std::mem::align_of::<_Mbstatet>(),
    4usize,
    concat!("Alignment of ", stringify!(_Mbstatet))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr)._Wchar) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_Mbstatet),
      "::",
      stringify!(_Wchar)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr)._Byte) as usize - ptr as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_Mbstatet),
      "::",
      stringify!(_Byte)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr)._State) as usize - ptr as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(_Mbstatet),
      "::",
      stringify!(_State)
    )
  );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
  pub fn _wassert(_Message: *const wchar_t, _File: *const wchar_t, _Line: ::std::os::raw::c_uint);
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type FLAC__int8 = i8;
pub type FLAC__uint8 = u8;
pub type FLAC__int16 = i16;
pub type FLAC__int32 = i32;
pub type FLAC__int64 = i64;
pub type FLAC__uint16 = u16;
pub type FLAC__uint32 = u32;
pub type FLAC__uint64 = u64;
pub type FLAC__bool = ::std::os::raw::c_int;
pub type FLAC__byte = FLAC__uint8;
extern "C" {
  pub fn _calloc_base(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn calloc(
    _Count: ::std::os::raw::c_ulonglong,
    _Size: ::std::os::raw::c_ulonglong,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn _callnewh(_Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _expand(_Block: *mut ::std::os::raw::c_void, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
  pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
  pub fn _malloc_base(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn malloc(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
  pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
  pub fn _realloc_base(
    _Block: *mut ::std::os::raw::c_void,
    _Size: usize,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn realloc(
    _Block: *mut ::std::os::raw::c_void,
    _Size: ::std::os::raw::c_ulonglong,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn _recalloc_base(
    _Block: *mut ::std::os::raw::c_void,
    _Count: usize,
    _Size: usize,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn _recalloc(
    _Block: *mut ::std::os::raw::c_void,
    _Count: usize,
    _Size: usize,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
  pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn _aligned_offset_malloc(
    _Size: usize,
    _Alignment: usize,
    _Offset: usize,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn _aligned_msize(
    _Block: *mut ::std::os::raw::c_void,
    _Alignment: usize,
    _Offset: usize,
  ) -> usize;
}
extern "C" {
  pub fn _aligned_offset_realloc(
    _Block: *mut ::std::os::raw::c_void,
    _Size: usize,
    _Alignment: usize,
    _Offset: usize,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn _aligned_offset_recalloc(
    _Block: *mut ::std::os::raw::c_void,
    _Count: usize,
    _Size: usize,
    _Alignment: usize,
    _Offset: usize,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn _aligned_realloc(
    _Block: *mut ::std::os::raw::c_void,
    _Size: usize,
    _Alignment: usize,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn _aligned_recalloc(
    _Block: *mut ::std::os::raw::c_void,
    _Count: usize,
    _Size: usize,
    _Alignment: usize,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
  pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
  pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
  pub fn __threadid() -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn __threadhandle() -> usize;
}
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
  unsafe extern "C" fn(
    arg1: *mut ::std::os::raw::c_void,
    arg2: *const ::std::os::raw::c_void,
    arg3: *const ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
  unsafe extern "C" fn(
    arg1: *const ::std::os::raw::c_void,
    arg2: *const ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int,
>;
extern "C" {
  pub fn bsearch_s(
    _Key: *const ::std::os::raw::c_void,
    _Base: *const ::std::os::raw::c_void,
    _NumOfElements: rsize_t,
    _SizeOfElements: rsize_t,
    _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
    _Context: *mut ::std::os::raw::c_void,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn qsort_s(
    _Base: *mut ::std::os::raw::c_void,
    _NumOfElements: rsize_t,
    _SizeOfElements: rsize_t,
    _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
    _Context: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn bsearch(
    _Key: *const ::std::os::raw::c_void,
    _Base: *const ::std::os::raw::c_void,
    _NumOfElements: usize,
    _SizeOfElements: usize,
    _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn qsort(
    _Base: *mut ::std::os::raw::c_void,
    _NumOfElements: usize,
    _SizeOfElements: usize,
    _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
  );
}
extern "C" {
  pub fn _lfind_s(
    _Key: *const ::std::os::raw::c_void,
    _Base: *const ::std::os::raw::c_void,
    _NumOfElements: *mut ::std::os::raw::c_uint,
    _SizeOfElements: usize,
    _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
    _Context: *mut ::std::os::raw::c_void,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn _lfind(
    _Key: *const ::std::os::raw::c_void,
    _Base: *const ::std::os::raw::c_void,
    _NumOfElements: *mut ::std::os::raw::c_uint,
    _SizeOfElements: ::std::os::raw::c_uint,
    _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn _lsearch_s(
    _Key: *const ::std::os::raw::c_void,
    _Base: *mut ::std::os::raw::c_void,
    _NumOfElements: *mut ::std::os::raw::c_uint,
    _SizeOfElements: usize,
    _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
    _Context: *mut ::std::os::raw::c_void,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn _lsearch(
    _Key: *const ::std::os::raw::c_void,
    _Base: *mut ::std::os::raw::c_void,
    _NumOfElements: *mut ::std::os::raw::c_uint,
    _SizeOfElements: ::std::os::raw::c_uint,
    _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn lfind(
    _Key: *const ::std::os::raw::c_void,
    _Base: *const ::std::os::raw::c_void,
    _NumOfElements: *mut ::std::os::raw::c_uint,
    _SizeOfElements: ::std::os::raw::c_uint,
    _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn lsearch(
    _Key: *const ::std::os::raw::c_void,
    _Base: *mut ::std::os::raw::c_void,
    _NumOfElements: *mut ::std::os::raw::c_uint,
    _SizeOfElements: ::std::os::raw::c_uint,
    _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn _itow_s(
    _Value: ::std::os::raw::c_int,
    _Buffer: *mut wchar_t,
    _BufferCount: usize,
    _Radix: ::std::os::raw::c_int,
  ) -> errno_t;
}
extern "C" {
  pub fn _itow(
    _Value: ::std::os::raw::c_int,
    _Buffer: *mut wchar_t,
    _Radix: ::std::os::raw::c_int,
  ) -> *mut wchar_t;
}
extern "C" {
  pub fn _ltow_s(
    _Value: ::std::os::raw::c_long,
    _Buffer: *mut wchar_t,
    _BufferCount: usize,
    _Radix: ::std::os::raw::c_int,
  ) -> errno_t;
}
extern "C" {
  pub fn _ltow(
    _Value: ::std::os::raw::c_long,
    _Buffer: *mut wchar_t,
    _Radix: ::std::os::raw::c_int,
  ) -> *mut wchar_t;
}
extern "C" {
  pub fn _ultow_s(
    _Value: ::std::os::raw::c_ulong,
    _Buffer: *mut wchar_t,
    _BufferCount: usize,
    _Radix: ::std::os::raw::c_int,
  ) -> errno_t;
}
extern "C" {
  pub fn _ultow(
    _Value: ::std::os::raw::c_ulong,
    _Buffer: *mut wchar_t,
    _Radix: ::std::os::raw::c_int,
  ) -> *mut wchar_t;
}
extern "C" {
  pub fn wcstod(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
  pub fn _wcstod_l(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
  pub fn wcstol(
    _String: *const wchar_t,
    _EndPtr: *mut *mut wchar_t,
    _Radix: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn _wcstol_l(
    _String: *const wchar_t,
    _EndPtr: *mut *mut wchar_t,
    _Radix: ::std::os::raw::c_int,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn wcstoll(
    _String: *const wchar_t,
    _EndPtr: *mut *mut wchar_t,
    _Radix: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn _wcstoll_l(
    _String: *const wchar_t,
    _EndPtr: *mut *mut wchar_t,
    _Radix: ::std::os::raw::c_int,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn wcstoul(
    _String: *const wchar_t,
    _EndPtr: *mut *mut wchar_t,
    _Radix: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn _wcstoul_l(
    _String: *const wchar_t,
    _EndPtr: *mut *mut wchar_t,
    _Radix: ::std::os::raw::c_int,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn wcstoull(
    _String: *const wchar_t,
    _EndPtr: *mut *mut wchar_t,
    _Radix: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
  pub fn _wcstoull_l(
    _String: *const wchar_t,
    _EndPtr: *mut *mut wchar_t,
    _Radix: ::std::os::raw::c_int,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
  pub fn wcstold(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
  pub fn _wcstold_l(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t, _Locale: _locale_t)
    -> f64;
}
extern "C" {
  pub fn wcstof(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32;
}
extern "C" {
  pub fn _wcstof_l(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t, _Locale: _locale_t) -> f32;
}
extern "C" {
  pub fn _wtof(_String: *const wchar_t) -> f64;
}
extern "C" {
  pub fn _wtof_l(_String: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
  pub fn _wtoi(_String: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _wtoi_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _wtol(_String: *const wchar_t) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn _wtol_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn _wtoll(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn _wtoll_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn _i64tow_s(
    _Value: ::std::os::raw::c_longlong,
    _Buffer: *mut wchar_t,
    _BufferCount: usize,
    _Radix: ::std::os::raw::c_int,
  ) -> errno_t;
}
extern "C" {
  pub fn _i64tow(
    _Value: ::std::os::raw::c_longlong,
    _Buffer: *mut wchar_t,
    _Radix: ::std::os::raw::c_int,
  ) -> *mut wchar_t;
}
extern "C" {
  pub fn _ui64tow_s(
    _Value: ::std::os::raw::c_ulonglong,
    _Buffer: *mut wchar_t,
    _BufferCount: usize,
    _Radix: ::std::os::raw::c_int,
  ) -> errno_t;
}
extern "C" {
  pub fn _ui64tow(
    _Value: ::std::os::raw::c_ulonglong,
    _Buffer: *mut wchar_t,
    _Radix: ::std::os::raw::c_int,
  ) -> *mut wchar_t;
}
extern "C" {
  pub fn _wtoi64(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn _wtoi64_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn _wcstoi64(
    _String: *const wchar_t,
    _EndPtr: *mut *mut wchar_t,
    _Radix: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn _wcstoi64_l(
    _String: *const wchar_t,
    _EndPtr: *mut *mut wchar_t,
    _Radix: ::std::os::raw::c_int,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn _wcstoui64(
    _String: *const wchar_t,
    _EndPtr: *mut *mut wchar_t,
    _Radix: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
  pub fn _wcstoui64_l(
    _String: *const wchar_t,
    _EndPtr: *mut *mut wchar_t,
    _Radix: ::std::os::raw::c_int,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
  pub fn _wfullpath(
    _Buffer: *mut wchar_t,
    _Path: *const wchar_t,
    _BufferCount: usize,
  ) -> *mut wchar_t;
}
extern "C" {
  pub fn _wmakepath_s(
    _Buffer: *mut wchar_t,
    _BufferCount: usize,
    _Drive: *const wchar_t,
    _Dir: *const wchar_t,
    _Filename: *const wchar_t,
    _Ext: *const wchar_t,
  ) -> errno_t;
}
extern "C" {
  pub fn _wmakepath(
    _Buffer: *mut wchar_t,
    _Drive: *const wchar_t,
    _Dir: *const wchar_t,
    _Filename: *const wchar_t,
    _Ext: *const wchar_t,
  );
}
extern "C" {
  pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
  pub fn _wsplitpath(
    _FullPath: *const wchar_t,
    _Drive: *mut wchar_t,
    _Dir: *mut wchar_t,
    _Filename: *mut wchar_t,
    _Ext: *mut wchar_t,
  );
}
extern "C" {
  pub fn _wsplitpath_s(
    _FullPath: *const wchar_t,
    _Drive: *mut wchar_t,
    _DriveCount: usize,
    _Dir: *mut wchar_t,
    _DirCount: usize,
    _Filename: *mut wchar_t,
    _FilenameCount: usize,
    _Ext: *mut wchar_t,
    _ExtCount: usize,
  ) -> errno_t;
}
extern "C" {
  pub fn _wdupenv_s(
    _Buffer: *mut *mut wchar_t,
    _BufferCount: *mut usize,
    _VarName: *const wchar_t,
  ) -> errno_t;
}
extern "C" {
  pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn _wgetenv_s(
    _RequiredCount: *mut usize,
    _Buffer: *mut wchar_t,
    _BufferCount: usize,
    _VarName: *const wchar_t,
  ) -> errno_t;
}
extern "C" {
  pub fn _wputenv(_EnvString: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
  pub fn _wsearchenv_s(
    _Filename: *const wchar_t,
    _VarName: *const wchar_t,
    _Buffer: *mut wchar_t,
    _BufferCount: usize,
  ) -> errno_t;
}
extern "C" {
  pub fn _wsearchenv(
    _Filename: *const wchar_t,
    _VarName: *const wchar_t,
    _ResultPath: *mut wchar_t,
  );
}
extern "C" {
  pub fn _wsystem(_Command: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _swab(
    _Buf1: *mut ::std::os::raw::c_char,
    _Buf2: *mut ::std::os::raw::c_char,
    _SizeInBytes: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
  pub fn _exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
  pub fn _Exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
  pub fn quick_exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
  pub fn abort() -> !;
}
extern "C" {
  pub fn _set_abort_behavior(
    _Flags: ::std::os::raw::c_uint,
    _Mask: ::std::os::raw::c_uint,
  ) -> ::std::os::raw::c_uint;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
  pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
  pub fn at_quick_exit(
    arg1: ::std::option::Option<unsafe extern "C" fn()>,
  ) -> ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
  unsafe extern "C" fn(
    arg1: *const wchar_t,
    arg2: *const wchar_t,
    arg3: *const wchar_t,
    arg4: ::std::os::raw::c_uint,
    arg5: usize,
  ),
>;
extern "C" {
  pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
  pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
  pub fn _set_invalid_parameter_handler(
    _Handler: _invalid_parameter_handler,
  ) -> _invalid_parameter_handler;
}
extern "C" {
  pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
  pub fn _set_thread_local_invalid_parameter_handler(
    _Handler: _invalid_parameter_handler,
  ) -> _invalid_parameter_handler;
}
extern "C" {
  pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
  pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
  pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
  pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
  pub fn perror(_ErrMsg: *const ::std::os::raw::c_char);
}
extern "C" {
  pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn __p__wpgmptr() -> *mut *mut wchar_t;
}
extern "C" {
  pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
  pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
  pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
  pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
  pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
  pub quot: ::std::os::raw::c_int,
  pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
  const UNINIT: ::std::mem::MaybeUninit<_div_t> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<_div_t>(),
    8usize,
    concat!("Size of: ", stringify!(_div_t))
  );
  assert_eq!(
    ::std::mem::align_of::<_div_t>(),
    4usize,
    concat!("Alignment of ", stringify!(_div_t))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_div_t),
      "::",
      stringify!(quot)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_div_t),
      "::",
      stringify!(rem)
    )
  );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
  pub quot: ::std::os::raw::c_long,
  pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
  const UNINIT: ::std::mem::MaybeUninit<_ldiv_t> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<_ldiv_t>(),
    8usize,
    concat!("Size of: ", stringify!(_ldiv_t))
  );
  assert_eq!(
    ::std::mem::align_of::<_ldiv_t>(),
    4usize,
    concat!("Alignment of ", stringify!(_ldiv_t))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_ldiv_t),
      "::",
      stringify!(quot)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_ldiv_t),
      "::",
      stringify!(rem)
    )
  );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lldiv_t {
  pub quot: ::std::os::raw::c_longlong,
  pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__lldiv_t() {
  const UNINIT: ::std::mem::MaybeUninit<_lldiv_t> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<_lldiv_t>(),
    16usize,
    concat!("Size of: ", stringify!(_lldiv_t))
  );
  assert_eq!(
    ::std::mem::align_of::<_lldiv_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_lldiv_t))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_lldiv_t),
      "::",
      stringify!(quot)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_lldiv_t),
      "::",
      stringify!(rem)
    )
  );
}
pub type lldiv_t = _lldiv_t;
extern "C" {
  pub fn abs(_Number: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn labs(_Number: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn llabs(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn _abs64(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn _byteswap_ushort(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
  pub fn _byteswap_ulong(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn _byteswap_uint64(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
  pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
  pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
  pub fn lldiv(
    _Numerator: ::std::os::raw::c_longlong,
    _Denominator: ::std::os::raw::c_longlong,
  ) -> lldiv_t;
}
extern "C" {
  pub fn _rotl(
    _Value: ::std::os::raw::c_uint,
    _Shift: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_uint;
}
extern "C" {
  pub fn _lrotl(
    _Value: ::std::os::raw::c_ulong,
    _Shift: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn _rotl64(
    _Value: ::std::os::raw::c_ulonglong,
    _Shift: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
  pub fn _rotr(
    _Value: ::std::os::raw::c_uint,
    _Shift: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_uint;
}
extern "C" {
  pub fn _lrotr(
    _Value: ::std::os::raw::c_ulong,
    _Shift: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn _rotr64(
    _Value: ::std::os::raw::c_ulonglong,
    _Shift: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
  pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
  pub fn rand() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
  pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
  const UNINIT: ::std::mem::MaybeUninit<_LDOUBLE> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<_LDOUBLE>(),
    10usize,
    concat!("Size of: ", stringify!(_LDOUBLE))
  );
  assert_eq!(
    ::std::mem::align_of::<_LDOUBLE>(),
    1usize,
    concat!("Alignment of ", stringify!(_LDOUBLE))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).ld) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LDOUBLE),
      "::",
      stringify!(ld)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
  pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
  const UNINIT: ::std::mem::MaybeUninit<_CRT_DOUBLE> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<_CRT_DOUBLE>(),
    8usize,
    concat!("Size of: ", stringify!(_CRT_DOUBLE))
  );
  assert_eq!(
    ::std::mem::align_of::<_CRT_DOUBLE>(),
    8usize,
    concat!("Alignment of ", stringify!(_CRT_DOUBLE))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CRT_DOUBLE),
      "::",
      stringify!(x)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
  pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
  const UNINIT: ::std::mem::MaybeUninit<_CRT_FLOAT> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<_CRT_FLOAT>(),
    4usize,
    concat!("Size of: ", stringify!(_CRT_FLOAT))
  );
  assert_eq!(
    ::std::mem::align_of::<_CRT_FLOAT>(),
    4usize,
    concat!("Alignment of ", stringify!(_CRT_FLOAT))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_CRT_FLOAT),
      "::",
      stringify!(f)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
  pub x: f64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
  const UNINIT: ::std::mem::MaybeUninit<_LONGDOUBLE> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<_LONGDOUBLE>(),
    8usize,
    concat!("Size of: ", stringify!(_LONGDOUBLE))
  );
  assert_eq!(
    ::std::mem::align_of::<_LONGDOUBLE>(),
    8usize,
    concat!("Alignment of ", stringify!(_LONGDOUBLE))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LONGDOUBLE),
      "::",
      stringify!(x)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
  pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
  const UNINIT: ::std::mem::MaybeUninit<_LDBL12> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<_LDBL12>(),
    12usize,
    concat!("Size of: ", stringify!(_LDBL12))
  );
  assert_eq!(
    ::std::mem::align_of::<_LDBL12>(),
    1usize,
    concat!("Alignment of ", stringify!(_LDBL12))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).ld12) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_LDBL12),
      "::",
      stringify!(ld12)
    )
  );
}
extern "C" {
  pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
  pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
  pub fn _atoi_l(
    _String: *const ::std::os::raw::c_char,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _atol_l(
    _String: *const ::std::os::raw::c_char,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn _atoll_l(
    _String: *const ::std::os::raw::c_char,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn _atoi64_l(
    _String: *const ::std::os::raw::c_char,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn _atoflt(
    _Result: *mut _CRT_FLOAT,
    _String: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _atodbl(
    _Result: *mut _CRT_DOUBLE,
    _String: *mut ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _atoldbl(
    _Result: *mut _LDOUBLE,
    _String: *mut ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _atoflt_l(
    _Result: *mut _CRT_FLOAT,
    _String: *const ::std::os::raw::c_char,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _atodbl_l(
    _Result: *mut _CRT_DOUBLE,
    _String: *mut ::std::os::raw::c_char,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _atoldbl_l(
    _Result: *mut _LDOUBLE,
    _String: *mut ::std::os::raw::c_char,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn strtof(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
  ) -> f32;
}
extern "C" {
  pub fn _strtof_l(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
    _Locale: _locale_t,
  ) -> f32;
}
extern "C" {
  pub fn strtod(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
  ) -> f64;
}
extern "C" {
  pub fn _strtod_l(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
    _Locale: _locale_t,
  ) -> f64;
}
extern "C" {
  pub fn strtold(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
  ) -> f64;
}
extern "C" {
  pub fn _strtold_l(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
    _Locale: _locale_t,
  ) -> f64;
}
extern "C" {
  pub fn strtol(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn _strtol_l(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn strtoll(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn _strtoll_l(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn strtoul(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn _strtoul_l(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn strtoull(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
  pub fn _strtoull_l(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
  pub fn _strtoi64(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn _strtoi64_l(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn _strtoui64(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
  pub fn _strtoui64_l(
    _String: *const ::std::os::raw::c_char,
    _EndPtr: *mut *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
  pub fn _itoa_s(
    _Value: ::std::os::raw::c_int,
    _Buffer: *mut ::std::os::raw::c_char,
    _BufferCount: usize,
    _Radix: ::std::os::raw::c_int,
  ) -> errno_t;
}
extern "C" {
  pub fn _itoa(
    _Value: ::std::os::raw::c_int,
    _Buffer: *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn _ltoa_s(
    _Value: ::std::os::raw::c_long,
    _Buffer: *mut ::std::os::raw::c_char,
    _BufferCount: usize,
    _Radix: ::std::os::raw::c_int,
  ) -> errno_t;
}
extern "C" {
  pub fn _ltoa(
    _Value: ::std::os::raw::c_long,
    _Buffer: *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn _ultoa_s(
    _Value: ::std::os::raw::c_ulong,
    _Buffer: *mut ::std::os::raw::c_char,
    _BufferCount: usize,
    _Radix: ::std::os::raw::c_int,
  ) -> errno_t;
}
extern "C" {
  pub fn _ultoa(
    _Value: ::std::os::raw::c_ulong,
    _Buffer: *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn _i64toa_s(
    _Value: ::std::os::raw::c_longlong,
    _Buffer: *mut ::std::os::raw::c_char,
    _BufferCount: usize,
    _Radix: ::std::os::raw::c_int,
  ) -> errno_t;
}
extern "C" {
  pub fn _i64toa(
    _Value: ::std::os::raw::c_longlong,
    _Buffer: *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn _ui64toa_s(
    _Value: ::std::os::raw::c_ulonglong,
    _Buffer: *mut ::std::os::raw::c_char,
    _BufferCount: usize,
    _Radix: ::std::os::raw::c_int,
  ) -> errno_t;
}
extern "C" {
  pub fn _ui64toa(
    _Value: ::std::os::raw::c_ulonglong,
    _Buffer: *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn _ecvt_s(
    _Buffer: *mut ::std::os::raw::c_char,
    _BufferCount: usize,
    _Value: f64,
    _DigitCount: ::std::os::raw::c_int,
    _PtDec: *mut ::std::os::raw::c_int,
    _PtSign: *mut ::std::os::raw::c_int,
  ) -> errno_t;
}
extern "C" {
  pub fn _ecvt(
    _Value: f64,
    _DigitCount: ::std::os::raw::c_int,
    _PtDec: *mut ::std::os::raw::c_int,
    _PtSign: *mut ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn _fcvt_s(
    _Buffer: *mut ::std::os::raw::c_char,
    _BufferCount: usize,
    _Value: f64,
    _FractionalDigitCount: ::std::os::raw::c_int,
    _PtDec: *mut ::std::os::raw::c_int,
    _PtSign: *mut ::std::os::raw::c_int,
  ) -> errno_t;
}
extern "C" {
  pub fn _fcvt(
    _Value: f64,
    _FractionalDigitCount: ::std::os::raw::c_int,
    _PtDec: *mut ::std::os::raw::c_int,
    _PtSign: *mut ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn _gcvt_s(
    _Buffer: *mut ::std::os::raw::c_char,
    _BufferCount: usize,
    _Value: f64,
    _DigitCount: ::std::os::raw::c_int,
  ) -> errno_t;
}
extern "C" {
  pub fn _gcvt(
    _Value: f64,
    _DigitCount: ::std::os::raw::c_int,
    _Buffer: *mut ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _mblen_l(
    _Ch: *const ::std::os::raw::c_char,
    _MaxCount: usize,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _mbstrlen(_String: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
  pub fn _mbstrlen_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
  pub fn _mbstrnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
  pub fn _mbstrnlen_l(
    _String: *const ::std::os::raw::c_char,
    _MaxCount: usize,
    _Locale: _locale_t,
  ) -> usize;
}
extern "C" {
  pub fn mbtowc(
    _DstCh: *mut wchar_t,
    _SrcCh: *const ::std::os::raw::c_char,
    _SrcSizeInBytes: usize,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _mbtowc_l(
    _DstCh: *mut wchar_t,
    _SrcCh: *const ::std::os::raw::c_char,
    _SrcSizeInBytes: usize,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn mbstowcs_s(
    _PtNumOfCharConverted: *mut usize,
    _DstBuf: *mut wchar_t,
    _SizeInWords: usize,
    _SrcBuf: *const ::std::os::raw::c_char,
    _MaxCount: usize,
  ) -> errno_t;
}
extern "C" {
  pub fn mbstowcs(
    _Dest: *mut wchar_t,
    _Source: *const ::std::os::raw::c_char,
    _MaxCount: usize,
  ) -> usize;
}
extern "C" {
  pub fn _mbstowcs_s_l(
    _PtNumOfCharConverted: *mut usize,
    _DstBuf: *mut wchar_t,
    _SizeInWords: usize,
    _SrcBuf: *const ::std::os::raw::c_char,
    _MaxCount: usize,
    _Locale: _locale_t,
  ) -> errno_t;
}
extern "C" {
  pub fn _mbstowcs_l(
    _Dest: *mut wchar_t,
    _Source: *const ::std::os::raw::c_char,
    _MaxCount: usize,
    _Locale: _locale_t,
  ) -> usize;
}
extern "C" {
  pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _wctomb_l(
    _MbCh: *mut ::std::os::raw::c_char,
    _WCh: wchar_t,
    _Locale: _locale_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn wctomb_s(
    _SizeConverted: *mut ::std::os::raw::c_int,
    _MbCh: *mut ::std::os::raw::c_char,
    _SizeInBytes: rsize_t,
    _WCh: wchar_t,
  ) -> errno_t;
}
extern "C" {
  pub fn _wctomb_s_l(
    _SizeConverted: *mut ::std::os::raw::c_int,
    _MbCh: *mut ::std::os::raw::c_char,
    _SizeInBytes: usize,
    _WCh: wchar_t,
    _Locale: _locale_t,
  ) -> errno_t;
}
extern "C" {
  pub fn wcstombs_s(
    _PtNumOfCharConverted: *mut usize,
    _Dst: *mut ::std::os::raw::c_char,
    _DstSizeInBytes: usize,
    _Src: *const wchar_t,
    _MaxCountInBytes: usize,
  ) -> errno_t;
}
extern "C" {
  pub fn wcstombs(
    _Dest: *mut ::std::os::raw::c_char,
    _Source: *const wchar_t,
    _MaxCount: usize,
  ) -> usize;
}
extern "C" {
  pub fn _wcstombs_s_l(
    _PtNumOfCharConverted: *mut usize,
    _Dst: *mut ::std::os::raw::c_char,
    _DstSizeInBytes: usize,
    _Src: *const wchar_t,
    _MaxCountInBytes: usize,
    _Locale: _locale_t,
  ) -> errno_t;
}
extern "C" {
  pub fn _wcstombs_l(
    _Dest: *mut ::std::os::raw::c_char,
    _Source: *const wchar_t,
    _MaxCount: usize,
    _Locale: _locale_t,
  ) -> usize;
}
extern "C" {
  pub fn _fullpath(
    _Buffer: *mut ::std::os::raw::c_char,
    _Path: *const ::std::os::raw::c_char,
    _BufferCount: usize,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn _makepath_s(
    _Buffer: *mut ::std::os::raw::c_char,
    _BufferCount: usize,
    _Drive: *const ::std::os::raw::c_char,
    _Dir: *const ::std::os::raw::c_char,
    _Filename: *const ::std::os::raw::c_char,
    _Ext: *const ::std::os::raw::c_char,
  ) -> errno_t;
}
extern "C" {
  pub fn _makepath(
    _Buffer: *mut ::std::os::raw::c_char,
    _Drive: *const ::std::os::raw::c_char,
    _Dir: *const ::std::os::raw::c_char,
    _Filename: *const ::std::os::raw::c_char,
    _Ext: *const ::std::os::raw::c_char,
  );
}
extern "C" {
  pub fn _splitpath(
    _FullPath: *const ::std::os::raw::c_char,
    _Drive: *mut ::std::os::raw::c_char,
    _Dir: *mut ::std::os::raw::c_char,
    _Filename: *mut ::std::os::raw::c_char,
    _Ext: *mut ::std::os::raw::c_char,
  );
}
extern "C" {
  pub fn _splitpath_s(
    _FullPath: *const ::std::os::raw::c_char,
    _Drive: *mut ::std::os::raw::c_char,
    _DriveCount: usize,
    _Dir: *mut ::std::os::raw::c_char,
    _DirCount: usize,
    _Filename: *mut ::std::os::raw::c_char,
    _FilenameCount: usize,
    _Ext: *mut ::std::os::raw::c_char,
    _ExtCount: usize,
  ) -> errno_t;
}
extern "C" {
  pub fn getenv_s(
    _RequiredCount: *mut usize,
    _Buffer: *mut ::std::os::raw::c_char,
    _BufferCount: rsize_t,
    _VarName: *const ::std::os::raw::c_char,
  ) -> errno_t;
}
extern "C" {
  pub fn __p___argc() -> *mut ::std::os::raw::c_int;
}
extern "C" {
  pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn __p___wargv() -> *mut *mut *mut wchar_t;
}
extern "C" {
  pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn __p__wenviron() -> *mut *mut *mut wchar_t;
}
extern "C" {
  pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn _dupenv_s(
    _Buffer: *mut *mut ::std::os::raw::c_char,
    _BufferCount: *mut usize,
    _VarName: *const ::std::os::raw::c_char,
  ) -> errno_t;
}
extern "C" {
  pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _putenv_s(
    _Name: *const ::std::os::raw::c_char,
    _Value: *const ::std::os::raw::c_char,
  ) -> errno_t;
}
extern "C" {
  pub fn _searchenv_s(
    _Filename: *const ::std::os::raw::c_char,
    _VarName: *const ::std::os::raw::c_char,
    _Buffer: *mut ::std::os::raw::c_char,
    _BufferCount: usize,
  ) -> errno_t;
}
extern "C" {
  pub fn _searchenv(
    _Filename: *const ::std::os::raw::c_char,
    _VarName: *const ::std::os::raw::c_char,
    _Buffer: *mut ::std::os::raw::c_char,
  );
}
extern "C" {
  pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
  pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
  pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
  pub fn ecvt(
    _Value: f64,
    _DigitCount: ::std::os::raw::c_int,
    _PtDec: *mut ::std::os::raw::c_int,
    _PtSign: *mut ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn fcvt(
    _Value: f64,
    _FractionalDigitCount: ::std::os::raw::c_int,
    _PtDec: *mut ::std::os::raw::c_int,
    _PtSign: *mut ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn gcvt(
    _Value: f64,
    _DigitCount: ::std::os::raw::c_int,
    _DstBuf: *mut ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn itoa(
    _Value: ::std::os::raw::c_int,
    _Buffer: *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn ltoa(
    _Value: ::std::os::raw::c_long,
    _Buffer: *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn swab(
    _Buf1: *mut ::std::os::raw::c_char,
    _Buf2: *mut ::std::os::raw::c_char,
    _SizeInBytes: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn ultoa(
    _Value: ::std::os::raw::c_ulong,
    _Buffer: *mut ::std::os::raw::c_char,
    _Radix: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
#[doc = " This is the opaque handle type used by the callbacks.  Typically\n  this is a \\c FILE* or address of a file descriptor."]
pub type FLAC__IOHandle = *mut ::std::os::raw::c_void;
#[doc = " Signature for the read callback.\n  The signature and semantics match POSIX fread() implementations\n  and can generally be used interchangeably. Note that the global\n  variable errno from errno.h is read by some libFLAC functions to\n  detect read errors.\n\n \\param  ptr      The address of the read buffer.\n \\param  size     The size of the records to be read.\n \\param  nmemb    The number of records to be read.\n \\param  handle   The handle to the data source.\n \\retval size_t\n    The number of records read."]
pub type FLAC__IOCallback_Read = ::std::option::Option<
  unsafe extern "C" fn(
    ptr: *mut ::std::os::raw::c_void,
    size: usize,
    nmemb: usize,
    handle: FLAC__IOHandle,
  ) -> usize,
>;
#[doc = " Signature for the write callback.\n  The signature and semantics match POSIX fwrite() implementations\n  and can generally be used interchangeably.\n\n \\param  ptr      The address of the write buffer.\n \\param  size     The size of the records to be written.\n \\param  nmemb    The number of records to be written.\n \\param  handle   The handle to the data source.\n \\retval size_t\n    The number of records written."]
pub type FLAC__IOCallback_Write = ::std::option::Option<
  unsafe extern "C" fn(
    ptr: *const ::std::os::raw::c_void,
    size: usize,
    nmemb: usize,
    handle: FLAC__IOHandle,
  ) -> usize,
>;
#[doc = " Signature for the seek callback.\n  The signature and semantics mostly match POSIX fseek() WITH ONE IMPORTANT\n  EXCEPTION: the offset is a 64-bit type whereas fseek() is generally 'long'\n  and 32-bits wide.\n\n \\param  handle   The handle to the data source.\n \\param  offset   The new position, relative to \\a whence\n \\param  whence   \\c SEEK_SET, \\c SEEK_CUR, or \\c SEEK_END\n \\retval int\n    \\c 0 on success, \\c -1 on error."]
pub type FLAC__IOCallback_Seek = ::std::option::Option<
  unsafe extern "C" fn(
    handle: FLAC__IOHandle,
    offset: FLAC__int64,
    whence: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int,
>;
#[doc = " Signature for the tell callback.\n  The signature and semantics mostly match POSIX ftell() WITH ONE IMPORTANT\n  EXCEPTION: the offset is a 64-bit type whereas ftell() is generally 'long'\n  and 32-bits wide.\n\n \\param  handle   The handle to the data source.\n \\retval FLAC__int64\n    The current position on success, \\c -1 on error."]
pub type FLAC__IOCallback_Tell =
  ::std::option::Option<unsafe extern "C" fn(handle: FLAC__IOHandle) -> FLAC__int64>;
#[doc = " Signature for the EOF callback.\n  The signature and semantics mostly match POSIX feof() but WATCHOUT:\n  on many systems, feof() is a macro, so in this case a wrapper function\n  must be provided instead.\n\n \\param  handle   The handle to the data source.\n \\retval int\n    \\c 0 if not at end of file, nonzero if at end of file."]
pub type FLAC__IOCallback_Eof =
  ::std::option::Option<unsafe extern "C" fn(handle: FLAC__IOHandle) -> ::std::os::raw::c_int>;
#[doc = " Signature for the close callback.\n  The signature and semantics match POSIX fclose() implementations\n  and can generally be used interchangeably.\n\n \\param  handle   The handle to the data source.\n \\retval int\n    \\c 0 on success, \\c EOF on error."]
pub type FLAC__IOCallback_Close =
  ::std::option::Option<unsafe extern "C" fn(handle: FLAC__IOHandle) -> ::std::os::raw::c_int>;
#[doc = " A structure for holding a set of callbacks.\n  Each FLAC interface that requires a FLAC__IOCallbacks structure will\n  describe which of the callbacks are required.  The ones that are not\n  required may be set to NULL.\n\n  If the seek requirement for an interface is optional, you can signify that\n  a data source is not seekable by setting the \\a seek field to \\c NULL.\n\n  See the detailed documentation for callbacks in the\n  \\link flac_callbacks callbacks \\endlink module."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__IOCallbacks {
  #[doc = "< See FLAC__IOCallbacks"]
  pub read: FLAC__IOCallback_Read,
  #[doc = "< See FLAC__IOCallbacks"]
  pub write: FLAC__IOCallback_Write,
  #[doc = "< See FLAC__IOCallbacks"]
  pub seek: FLAC__IOCallback_Seek,
  #[doc = "< See FLAC__IOCallbacks"]
  pub tell: FLAC__IOCallback_Tell,
  #[doc = "< See FLAC__IOCallbacks"]
  pub eof: FLAC__IOCallback_Eof,
  #[doc = "< See FLAC__IOCallbacks"]
  pub close: FLAC__IOCallback_Close,
}
#[test]
fn bindgen_test_layout_FLAC__IOCallbacks() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__IOCallbacks> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__IOCallbacks>(),
    48usize,
    concat!("Size of: ", stringify!(FLAC__IOCallbacks))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__IOCallbacks>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__IOCallbacks))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__IOCallbacks),
      "::",
      stringify!(read)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__IOCallbacks),
      "::",
      stringify!(write)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__IOCallbacks),
      "::",
      stringify!(seek)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__IOCallbacks),
      "::",
      stringify!(tell)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).eof) as usize - ptr as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__IOCallbacks),
      "::",
      stringify!(eof)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__IOCallbacks),
      "::",
      stringify!(close)
    )
  );
}
extern "C" {
  #[doc = " The version string of the release, stamped onto the libraries and binaries.\n\n \\note\n This does not correspond to the shared library version number, which\n is used to determine binary compatibility."]
  pub static mut FLAC__VERSION_STRING: *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " The vendor string inserted by the encoder into the VORBIS_COMMENT block.\n  This is a NUL-terminated ASCII string; when inserted into the\n  VORBIS_COMMENT the trailing null is stripped."]
  pub static mut FLAC__VENDOR_STRING: *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " The byte string representation of the beginning of a FLAC stream."]
  pub static FLAC__STREAM_SYNC_STRING: [FLAC__byte; 4usize];
}
extern "C" {
  #[doc = " The 32-bit integer big-endian representation of the beginning of\n  a FLAC stream."]
  pub static FLAC__STREAM_SYNC: u32;
}
extern "C" {
  #[doc = " The length of the FLAC signature in bits."]
  pub static FLAC__STREAM_SYNC_LEN: u32;
}
pub const FLAC__EntropyCodingMethodType_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE:
  FLAC__EntropyCodingMethodType = 0;
pub const FLAC__EntropyCodingMethodType_FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2:
  FLAC__EntropyCodingMethodType = 1;
#[doc = " An enumeration of the available entropy coding methods."]
pub type FLAC__EntropyCodingMethodType = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__EntropyCodingMethodType to a C string.\n\n  Using a FLAC__EntropyCodingMethodType as the index to this array will\n  give the string equivalent.  The contents should not be modified."]
  pub static FLAC__EntropyCodingMethodTypeString: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = " Contents of a Rice partitioned residual"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__EntropyCodingMethod_PartitionedRiceContents {
  pub parameters: *mut u32,
  pub raw_bits: *mut u32,
  pub capacity_by_order: u32,
}
#[test]
fn bindgen_test_layout_FLAC__EntropyCodingMethod_PartitionedRiceContents() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__EntropyCodingMethod_PartitionedRiceContents> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__EntropyCodingMethod_PartitionedRiceContents>(),
    24usize,
    concat!(
      "Size of: ",
      stringify!(FLAC__EntropyCodingMethod_PartitionedRiceContents)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__EntropyCodingMethod_PartitionedRiceContents>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(FLAC__EntropyCodingMethod_PartitionedRiceContents)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).parameters) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__EntropyCodingMethod_PartitionedRiceContents),
      "::",
      stringify!(parameters)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).raw_bits) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__EntropyCodingMethod_PartitionedRiceContents),
      "::",
      stringify!(raw_bits)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).capacity_by_order) as usize - ptr as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__EntropyCodingMethod_PartitionedRiceContents),
      "::",
      stringify!(capacity_by_order)
    )
  );
}
#[doc = " Header for a Rice partitioned residual.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#partitioned_rice\">format specification</A>)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__EntropyCodingMethod_PartitionedRice {
  pub order: u32,
  pub contents: *const FLAC__EntropyCodingMethod_PartitionedRiceContents,
}
#[test]
fn bindgen_test_layout_FLAC__EntropyCodingMethod_PartitionedRice() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__EntropyCodingMethod_PartitionedRice> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__EntropyCodingMethod_PartitionedRice>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(FLAC__EntropyCodingMethod_PartitionedRice)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__EntropyCodingMethod_PartitionedRice>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(FLAC__EntropyCodingMethod_PartitionedRice)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).order) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__EntropyCodingMethod_PartitionedRice),
      "::",
      stringify!(order)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).contents) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__EntropyCodingMethod_PartitionedRice),
      "::",
      stringify!(contents)
    )
  );
}
extern "C" {
  #[doc = "< == 4 (bits)"]
  pub static FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN: u32;
}
extern "C" {
  #[doc = "< == 4 (bits)"]
  pub static FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN: u32;
}
extern "C" {
  #[doc = "< == 5 (bits)"]
  pub static FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN: u32;
}
extern "C" {
  #[doc = "< == 5 (bits)"]
  pub static FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN: u32;
}
extern "C" {
  pub static FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER: u32;
}
extern "C" {
  pub static FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER: u32;
}
#[doc = " Header for the entropy coding method.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#residual\">format specification</A>)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__EntropyCodingMethod {
  pub type_: FLAC__EntropyCodingMethodType,
  pub data: FLAC__EntropyCodingMethod__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FLAC__EntropyCodingMethod__bindgen_ty_1 {
  pub partitioned_rice: FLAC__EntropyCodingMethod_PartitionedRice,
}
#[test]
fn bindgen_test_layout_FLAC__EntropyCodingMethod__bindgen_ty_1() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__EntropyCodingMethod__bindgen_ty_1> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__EntropyCodingMethod__bindgen_ty_1>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(FLAC__EntropyCodingMethod__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__EntropyCodingMethod__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(FLAC__EntropyCodingMethod__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).partitioned_rice) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__EntropyCodingMethod__bindgen_ty_1),
      "::",
      stringify!(partitioned_rice)
    )
  );
}
#[test]
fn bindgen_test_layout_FLAC__EntropyCodingMethod() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__EntropyCodingMethod> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__EntropyCodingMethod>(),
    24usize,
    concat!("Size of: ", stringify!(FLAC__EntropyCodingMethod))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__EntropyCodingMethod>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__EntropyCodingMethod))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__EntropyCodingMethod),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__EntropyCodingMethod),
      "::",
      stringify!(data)
    )
  );
}
extern "C" {
  #[doc = "< == 2 (bits)"]
  pub static FLAC__ENTROPY_CODING_METHOD_TYPE_LEN: u32;
}
#[doc = "< constant signal"]
pub const FLAC__SubframeType_FLAC__SUBFRAME_TYPE_CONSTANT: FLAC__SubframeType = 0;
#[doc = "< uncompressed signal"]
pub const FLAC__SubframeType_FLAC__SUBFRAME_TYPE_VERBATIM: FLAC__SubframeType = 1;
#[doc = "< fixed polynomial prediction"]
pub const FLAC__SubframeType_FLAC__SUBFRAME_TYPE_FIXED: FLAC__SubframeType = 2;
#[doc = "< linear prediction"]
pub const FLAC__SubframeType_FLAC__SUBFRAME_TYPE_LPC: FLAC__SubframeType = 3;
#[doc = " An enumeration of the available subframe types."]
pub type FLAC__SubframeType = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__SubframeType to a C string.\n\n  Using a FLAC__SubframeType as the index to this array will\n  give the string equivalent.  The contents should not be modified."]
  pub static FLAC__SubframeTypeString: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = " CONSTANT subframe.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#subframe_constant\">format specification</A>)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__Subframe_Constant {
  #[doc = "< The constant signal value."]
  pub value: FLAC__int64,
}
#[test]
fn bindgen_test_layout_FLAC__Subframe_Constant() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__Subframe_Constant> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__Subframe_Constant>(),
    8usize,
    concat!("Size of: ", stringify!(FLAC__Subframe_Constant))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__Subframe_Constant>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__Subframe_Constant))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe_Constant),
      "::",
      stringify!(value)
    )
  );
}
#[doc = "< verbatim subframe has 32-bit int"]
pub const FLAC__VerbatimSubframeDataType_FLAC__VERBATIM_SUBFRAME_DATA_TYPE_INT32:
  FLAC__VerbatimSubframeDataType = 0;
#[doc = "< verbatim subframe has 64-bit int"]
pub const FLAC__VerbatimSubframeDataType_FLAC__VERBATIM_SUBFRAME_DATA_TYPE_INT64:
  FLAC__VerbatimSubframeDataType = 1;
#[doc = " An enumeration of the possible verbatim subframe data types."]
pub type FLAC__VerbatimSubframeDataType = ::std::os::raw::c_int;
#[doc = " VERBATIM subframe.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#subframe_verbatim\">format specification</A>)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__Subframe_Verbatim {
  pub data: FLAC__Subframe_Verbatim__bindgen_ty_1,
  pub data_type: FLAC__VerbatimSubframeDataType,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FLAC__Subframe_Verbatim__bindgen_ty_1 {
  #[doc = "< A FLAC__int32 pointer to verbatim signal."]
  pub int32: *const FLAC__int32,
  #[doc = "< A FLAC__int64 pointer to verbatim signal."]
  pub int64: *const FLAC__int64,
}
#[test]
fn bindgen_test_layout_FLAC__Subframe_Verbatim__bindgen_ty_1() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__Subframe_Verbatim__bindgen_ty_1> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__Subframe_Verbatim__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(FLAC__Subframe_Verbatim__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__Subframe_Verbatim__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(FLAC__Subframe_Verbatim__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).int32) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe_Verbatim__bindgen_ty_1),
      "::",
      stringify!(int32)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).int64) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe_Verbatim__bindgen_ty_1),
      "::",
      stringify!(int64)
    )
  );
}
#[test]
fn bindgen_test_layout_FLAC__Subframe_Verbatim() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__Subframe_Verbatim> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__Subframe_Verbatim>(),
    16usize,
    concat!("Size of: ", stringify!(FLAC__Subframe_Verbatim))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__Subframe_Verbatim>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__Subframe_Verbatim))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe_Verbatim),
      "::",
      stringify!(data)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).data_type) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe_Verbatim),
      "::",
      stringify!(data_type)
    )
  );
}
#[doc = " FIXED subframe.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#subframe_fixed\">format specification</A>)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__Subframe_Fixed {
  pub entropy_coding_method: FLAC__EntropyCodingMethod,
  pub order: u32,
  pub warmup: [FLAC__int64; 4usize],
  pub residual: *const FLAC__int32,
}
#[test]
fn bindgen_test_layout_FLAC__Subframe_Fixed() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__Subframe_Fixed> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__Subframe_Fixed>(),
    72usize,
    concat!("Size of: ", stringify!(FLAC__Subframe_Fixed))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__Subframe_Fixed>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__Subframe_Fixed))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).entropy_coding_method) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe_Fixed),
      "::",
      stringify!(entropy_coding_method)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).order) as usize - ptr as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe_Fixed),
      "::",
      stringify!(order)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).warmup) as usize - ptr as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe_Fixed),
      "::",
      stringify!(warmup)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).residual) as usize - ptr as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe_Fixed),
      "::",
      stringify!(residual)
    )
  );
}
#[doc = " LPC subframe.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#subframe_lpc\">format specification</A>)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__Subframe_LPC {
  pub entropy_coding_method: FLAC__EntropyCodingMethod,
  pub order: u32,
  pub qlp_coeff_precision: u32,
  pub quantization_level: ::std::os::raw::c_int,
  pub qlp_coeff: [FLAC__int32; 32usize],
  pub warmup: [FLAC__int64; 32usize],
  pub residual: *const FLAC__int32,
}
#[test]
fn bindgen_test_layout_FLAC__Subframe_LPC() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__Subframe_LPC> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__Subframe_LPC>(),
    432usize,
    concat!("Size of: ", stringify!(FLAC__Subframe_LPC))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__Subframe_LPC>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__Subframe_LPC))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).entropy_coding_method) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe_LPC),
      "::",
      stringify!(entropy_coding_method)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).order) as usize - ptr as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe_LPC),
      "::",
      stringify!(order)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).qlp_coeff_precision) as usize - ptr as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe_LPC),
      "::",
      stringify!(qlp_coeff_precision)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).quantization_level) as usize - ptr as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe_LPC),
      "::",
      stringify!(quantization_level)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).qlp_coeff) as usize - ptr as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe_LPC),
      "::",
      stringify!(qlp_coeff)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).warmup) as usize - ptr as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe_LPC),
      "::",
      stringify!(warmup)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).residual) as usize - ptr as usize },
    424usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe_LPC),
      "::",
      stringify!(residual)
    )
  );
}
extern "C" {
  #[doc = "< == 4 (bits)"]
  pub static FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN: u32;
}
extern "C" {
  #[doc = "< == 5 (bits)"]
  pub static FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN: u32;
}
#[doc = " FLAC subframe structure.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#subframe\">format specification</A>)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__Subframe {
  pub type_: FLAC__SubframeType,
  pub data: FLAC__Subframe__bindgen_ty_1,
  pub wasted_bits: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FLAC__Subframe__bindgen_ty_1 {
  pub constant: FLAC__Subframe_Constant,
  pub fixed: FLAC__Subframe_Fixed,
  pub lpc: FLAC__Subframe_LPC,
  pub verbatim: FLAC__Subframe_Verbatim,
}
#[test]
fn bindgen_test_layout_FLAC__Subframe__bindgen_ty_1() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__Subframe__bindgen_ty_1> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__Subframe__bindgen_ty_1>(),
    432usize,
    concat!("Size of: ", stringify!(FLAC__Subframe__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__Subframe__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__Subframe__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).constant) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe__bindgen_ty_1),
      "::",
      stringify!(constant)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).fixed) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe__bindgen_ty_1),
      "::",
      stringify!(fixed)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).lpc) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe__bindgen_ty_1),
      "::",
      stringify!(lpc)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).verbatim) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe__bindgen_ty_1),
      "::",
      stringify!(verbatim)
    )
  );
}
#[test]
fn bindgen_test_layout_FLAC__Subframe() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__Subframe> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__Subframe>(),
    448usize,
    concat!("Size of: ", stringify!(FLAC__Subframe))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__Subframe>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__Subframe))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe),
      "::",
      stringify!(data)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).wasted_bits) as usize - ptr as usize },
    440usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Subframe),
      "::",
      stringify!(wasted_bits)
    )
  );
}
extern "C" {
  #[doc = " == 1 (bit)\n\n This used to be a zero-padding bit (hence the name\n FLAC__SUBFRAME_ZERO_PAD_LEN) but is now a reserved bit.  It still has a\n mandatory value of \\c 0 but in the future may take on the value \\c 0 or \\c 1\n to mean something else."]
  pub static FLAC__SUBFRAME_ZERO_PAD_LEN: u32;
}
extern "C" {
  #[doc = "< == 6 (bits)"]
  pub static FLAC__SUBFRAME_TYPE_LEN: u32;
}
extern "C" {
  #[doc = "< == 1 (bit)"]
  pub static FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN: u32;
}
extern "C" {
  #[doc = "< = 0x00"]
  pub static FLAC__SUBFRAME_TYPE_CONSTANT_BYTE_ALIGNED_MASK: u32;
}
extern "C" {
  #[doc = "< = 0x02"]
  pub static FLAC__SUBFRAME_TYPE_VERBATIM_BYTE_ALIGNED_MASK: u32;
}
extern "C" {
  #[doc = "< = 0x10"]
  pub static FLAC__SUBFRAME_TYPE_FIXED_BYTE_ALIGNED_MASK: u32;
}
extern "C" {
  #[doc = "< = 0x40"]
  pub static FLAC__SUBFRAME_TYPE_LPC_BYTE_ALIGNED_MASK: u32;
}
#[doc = "< independent channels"]
pub const FLAC__ChannelAssignment_FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT: FLAC__ChannelAssignment = 0;
#[doc = "< left+side stereo"]
pub const FLAC__ChannelAssignment_FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE: FLAC__ChannelAssignment = 1;
#[doc = "< right+side stereo"]
pub const FLAC__ChannelAssignment_FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE: FLAC__ChannelAssignment = 2;
#[doc = "< mid+side stereo"]
pub const FLAC__ChannelAssignment_FLAC__CHANNEL_ASSIGNMENT_MID_SIDE: FLAC__ChannelAssignment = 3;
#[doc = " An enumeration of the available channel assignments."]
pub type FLAC__ChannelAssignment = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__ChannelAssignment to a C string.\n\n  Using a FLAC__ChannelAssignment as the index to this array will\n  give the string equivalent.  The contents should not be modified."]
  pub static FLAC__ChannelAssignmentString: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = "< number contains the frame number"]
pub const FLAC__FrameNumberType_FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER: FLAC__FrameNumberType = 0;
#[doc = "< number contains the sample number of first sample in frame"]
pub const FLAC__FrameNumberType_FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER: FLAC__FrameNumberType = 1;
#[doc = " An enumeration of the possible frame numbering methods."]
pub type FLAC__FrameNumberType = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__FrameNumberType to a C string.\n\n  Using a FLAC__FrameNumberType as the index to this array will\n  give the string equivalent.  The contents should not be modified."]
  pub static FLAC__FrameNumberTypeString: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = " FLAC frame header structure.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#frame_header\">format specification</A>)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__FrameHeader {
  pub blocksize: u32,
  pub sample_rate: u32,
  pub channels: u32,
  pub channel_assignment: FLAC__ChannelAssignment,
  pub bits_per_sample: u32,
  pub number_type: FLAC__FrameNumberType,
  pub number: FLAC__FrameHeader__bindgen_ty_1,
  pub crc: FLAC__uint8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FLAC__FrameHeader__bindgen_ty_1 {
  pub frame_number: FLAC__uint32,
  pub sample_number: FLAC__uint64,
}
#[test]
fn bindgen_test_layout_FLAC__FrameHeader__bindgen_ty_1() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__FrameHeader__bindgen_ty_1> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__FrameHeader__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(FLAC__FrameHeader__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__FrameHeader__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__FrameHeader__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).frame_number) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__FrameHeader__bindgen_ty_1),
      "::",
      stringify!(frame_number)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).sample_number) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__FrameHeader__bindgen_ty_1),
      "::",
      stringify!(sample_number)
    )
  );
}
#[test]
fn bindgen_test_layout_FLAC__FrameHeader() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__FrameHeader> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__FrameHeader>(),
    40usize,
    concat!("Size of: ", stringify!(FLAC__FrameHeader))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__FrameHeader>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__FrameHeader))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).blocksize) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__FrameHeader),
      "::",
      stringify!(blocksize)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).sample_rate) as usize - ptr as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__FrameHeader),
      "::",
      stringify!(sample_rate)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__FrameHeader),
      "::",
      stringify!(channels)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).channel_assignment) as usize - ptr as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__FrameHeader),
      "::",
      stringify!(channel_assignment)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).bits_per_sample) as usize - ptr as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__FrameHeader),
      "::",
      stringify!(bits_per_sample)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).number_type) as usize - ptr as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__FrameHeader),
      "::",
      stringify!(number_type)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).number) as usize - ptr as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__FrameHeader),
      "::",
      stringify!(number)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).crc) as usize - ptr as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__FrameHeader),
      "::",
      stringify!(crc)
    )
  );
}
extern "C" {
  #[doc = "< == 0x3ffe; the frame header sync code"]
  pub static FLAC__FRAME_HEADER_SYNC: u32;
}
extern "C" {
  #[doc = "< == 14 (bits)"]
  pub static FLAC__FRAME_HEADER_SYNC_LEN: u32;
}
extern "C" {
  #[doc = "< == 1 (bits)"]
  pub static FLAC__FRAME_HEADER_RESERVED_LEN: u32;
}
extern "C" {
  #[doc = "< == 1 (bits)"]
  pub static FLAC__FRAME_HEADER_BLOCKING_STRATEGY_LEN: u32;
}
extern "C" {
  #[doc = "< == 4 (bits)"]
  pub static FLAC__FRAME_HEADER_BLOCK_SIZE_LEN: u32;
}
extern "C" {
  #[doc = "< == 4 (bits)"]
  pub static FLAC__FRAME_HEADER_SAMPLE_RATE_LEN: u32;
}
extern "C" {
  #[doc = "< == 4 (bits)"]
  pub static FLAC__FRAME_HEADER_CHANNEL_ASSIGNMENT_LEN: u32;
}
extern "C" {
  #[doc = "< == 3 (bits)"]
  pub static FLAC__FRAME_HEADER_BITS_PER_SAMPLE_LEN: u32;
}
extern "C" {
  #[doc = "< == 1 (bit)"]
  pub static FLAC__FRAME_HEADER_ZERO_PAD_LEN: u32;
}
extern "C" {
  #[doc = "< == 8 (bits)"]
  pub static FLAC__FRAME_HEADER_CRC_LEN: u32;
}
#[doc = " FLAC frame footer structure.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#frame_footer\">format specification</A>)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__FrameFooter {
  pub crc: FLAC__uint16,
}
#[test]
fn bindgen_test_layout_FLAC__FrameFooter() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__FrameFooter> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__FrameFooter>(),
    2usize,
    concat!("Size of: ", stringify!(FLAC__FrameFooter))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__FrameFooter>(),
    2usize,
    concat!("Alignment of ", stringify!(FLAC__FrameFooter))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).crc) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__FrameFooter),
      "::",
      stringify!(crc)
    )
  );
}
extern "C" {
  #[doc = "< == 16 (bits)"]
  pub static FLAC__FRAME_FOOTER_CRC_LEN: u32;
}
#[doc = " FLAC frame structure.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#frame\">format specification</A>)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__Frame {
  pub header: FLAC__FrameHeader,
  pub subframes: [FLAC__Subframe; 8usize],
  pub footer: FLAC__FrameFooter,
}
#[test]
fn bindgen_test_layout_FLAC__Frame() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__Frame> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__Frame>(),
    3632usize,
    concat!("Size of: ", stringify!(FLAC__Frame))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__Frame>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__Frame))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Frame),
      "::",
      stringify!(header)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).subframes) as usize - ptr as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Frame),
      "::",
      stringify!(subframes)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).footer) as usize - ptr as usize },
    3624usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__Frame),
      "::",
      stringify!(footer)
    )
  );
}
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_STREAMINFO: FLAC__MetadataType = 0;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_PADDING: FLAC__MetadataType = 1;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_APPLICATION: FLAC__MetadataType = 2;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_SEEKTABLE: FLAC__MetadataType = 3;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_VORBIS_COMMENT: FLAC__MetadataType = 4;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_CUESHEET: FLAC__MetadataType = 5;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_PICTURE: FLAC__MetadataType = 6;
pub const FLAC__MetadataType_FLAC__METADATA_TYPE_UNDEFINED: FLAC__MetadataType = 7;
pub const FLAC__MetadataType_FLAC__MAX_METADATA_TYPE: FLAC__MetadataType = 126;
#[doc = " An enumeration of the available metadata block types."]
pub type FLAC__MetadataType = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__MetadataType to a C string.\n\n  Using a FLAC__MetadataType as the index to this array will\n  give the string equivalent.  The contents should not be modified."]
  pub static FLAC__MetadataTypeString: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = " FLAC STREAMINFO structure.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#metadata_block_streaminfo\">format specification</A>)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_StreamInfo {
  pub min_blocksize: u32,
  pub max_blocksize: u32,
  pub min_framesize: u32,
  pub max_framesize: u32,
  pub sample_rate: u32,
  pub channels: u32,
  pub bits_per_sample: u32,
  pub total_samples: FLAC__uint64,
  pub md5sum: [FLAC__byte; 16usize],
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_StreamInfo() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__StreamMetadata_StreamInfo> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__StreamMetadata_StreamInfo>(),
    56usize,
    concat!("Size of: ", stringify!(FLAC__StreamMetadata_StreamInfo))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__StreamMetadata_StreamInfo>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__StreamMetadata_StreamInfo))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).min_blocksize) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_StreamInfo),
      "::",
      stringify!(min_blocksize)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).max_blocksize) as usize - ptr as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_StreamInfo),
      "::",
      stringify!(max_blocksize)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).min_framesize) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_StreamInfo),
      "::",
      stringify!(min_framesize)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).max_framesize) as usize - ptr as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_StreamInfo),
      "::",
      stringify!(max_framesize)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).sample_rate) as usize - ptr as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_StreamInfo),
      "::",
      stringify!(sample_rate)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_StreamInfo),
      "::",
      stringify!(channels)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).bits_per_sample) as usize - ptr as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_StreamInfo),
      "::",
      stringify!(bits_per_sample)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).total_samples) as usize - ptr as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_StreamInfo),
      "::",
      stringify!(total_samples)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).md5sum) as usize - ptr as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_StreamInfo),
      "::",
      stringify!(md5sum)
    )
  );
}
extern "C" {
  #[doc = "< == 16 (bits)"]
  pub static FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN: u32;
}
extern "C" {
  #[doc = "< == 16 (bits)"]
  pub static FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN: u32;
}
extern "C" {
  #[doc = "< == 24 (bits)"]
  pub static FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN: u32;
}
extern "C" {
  #[doc = "< == 24 (bits)"]
  pub static FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN: u32;
}
extern "C" {
  #[doc = "< == 20 (bits)"]
  pub static FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN: u32;
}
extern "C" {
  #[doc = "< == 3 (bits)"]
  pub static FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN: u32;
}
extern "C" {
  #[doc = "< == 5 (bits)"]
  pub static FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN: u32;
}
extern "C" {
  #[doc = "< == 36 (bits)"]
  pub static FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN: u32;
}
extern "C" {
  #[doc = "< == 128 (bits)"]
  pub static FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN: u32;
}
#[doc = " FLAC PADDING structure.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#metadata_block_padding\">format specification</A>)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_Padding {
  pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_Padding() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__StreamMetadata_Padding> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__StreamMetadata_Padding>(),
    4usize,
    concat!("Size of: ", stringify!(FLAC__StreamMetadata_Padding))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__StreamMetadata_Padding>(),
    4usize,
    concat!("Alignment of ", stringify!(FLAC__StreamMetadata_Padding))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_Padding),
      "::",
      stringify!(dummy)
    )
  );
}
#[doc = " FLAC APPLICATION structure.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#metadata_block_application\">format specification</A>)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_Application {
  pub id: [FLAC__byte; 4usize],
  pub data: *mut FLAC__byte,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_Application() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__StreamMetadata_Application> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__StreamMetadata_Application>(),
    16usize,
    concat!("Size of: ", stringify!(FLAC__StreamMetadata_Application))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__StreamMetadata_Application>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(FLAC__StreamMetadata_Application)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_Application),
      "::",
      stringify!(id)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_Application),
      "::",
      stringify!(data)
    )
  );
}
extern "C" {
  #[doc = "< == 32 (bits)"]
  pub static FLAC__STREAM_METADATA_APPLICATION_ID_LEN: u32;
}
#[doc = " SeekPoint structure used in SEEKTABLE blocks.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#seekpoint\">format specification</A>)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_SeekPoint {
  pub sample_number: FLAC__uint64,
  pub stream_offset: FLAC__uint64,
  pub frame_samples: u32,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_SeekPoint() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__StreamMetadata_SeekPoint> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__StreamMetadata_SeekPoint>(),
    24usize,
    concat!("Size of: ", stringify!(FLAC__StreamMetadata_SeekPoint))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__StreamMetadata_SeekPoint>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__StreamMetadata_SeekPoint))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).sample_number) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_SeekPoint),
      "::",
      stringify!(sample_number)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).stream_offset) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_SeekPoint),
      "::",
      stringify!(stream_offset)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).frame_samples) as usize - ptr as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_SeekPoint),
      "::",
      stringify!(frame_samples)
    )
  );
}
extern "C" {
  #[doc = "< == 64 (bits)"]
  pub static FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN: u32;
}
extern "C" {
  #[doc = "< == 64 (bits)"]
  pub static FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN: u32;
}
extern "C" {
  #[doc = "< == 16 (bits)"]
  pub static FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN: u32;
}
extern "C" {
  #[doc = " The value used in the \\a sample_number field of\n  FLAC__StreamMetadataSeekPoint used to indicate a placeholder\n  point (== 0xffffffffffffffff)."]
  pub static FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER: FLAC__uint64;
}
#[doc = " FLAC SEEKTABLE structure.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#metadata_block_seektable\">format specification</A>)\n\n \\note From the format specification:\n - The seek points must be sorted by ascending sample number.\n - Each seek point's sample number must be the first sample of the\n   target frame.\n - Each seek point's sample number must be unique within the table.\n - Existence of a SEEKTABLE block implies a correct setting of\n   total_samples in the stream_info block.\n - Behavior is undefined when more than one SEEKTABLE block is\n   present in a stream."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_SeekTable {
  pub num_points: u32,
  pub points: *mut FLAC__StreamMetadata_SeekPoint,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_SeekTable() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__StreamMetadata_SeekTable> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__StreamMetadata_SeekTable>(),
    16usize,
    concat!("Size of: ", stringify!(FLAC__StreamMetadata_SeekTable))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__StreamMetadata_SeekTable>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__StreamMetadata_SeekTable))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).num_points) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_SeekTable),
      "::",
      stringify!(num_points)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).points) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_SeekTable),
      "::",
      stringify!(points)
    )
  );
}
#[doc = " Vorbis comment entry structure used in VORBIS_COMMENT blocks.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#metadata_block_vorbis_comment\">format specification</A>)\n\n  For convenience, the APIs maintain a trailing NUL character at the end of\n  \\a entry which is not counted toward \\a length, i.e.\n  \\code strlen(entry) == length \\endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_VorbisComment_Entry {
  pub length: FLAC__uint32,
  pub entry: *mut FLAC__byte,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_VorbisComment_Entry() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__StreamMetadata_VorbisComment_Entry> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__StreamMetadata_VorbisComment_Entry>(),
    16usize,
    concat!(
      "Size of: ",
      stringify!(FLAC__StreamMetadata_VorbisComment_Entry)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__StreamMetadata_VorbisComment_Entry>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(FLAC__StreamMetadata_VorbisComment_Entry)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_VorbisComment_Entry),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_VorbisComment_Entry),
      "::",
      stringify!(entry)
    )
  );
}
extern "C" {
  #[doc = "< == 32 (bits)"]
  pub static FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN: u32;
}
#[doc = " FLAC VORBIS_COMMENT structure.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#metadata_block_vorbis_comment\">format specification</A>)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_VorbisComment {
  pub vendor_string: FLAC__StreamMetadata_VorbisComment_Entry,
  pub num_comments: FLAC__uint32,
  pub comments: *mut FLAC__StreamMetadata_VorbisComment_Entry,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_VorbisComment() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__StreamMetadata_VorbisComment> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__StreamMetadata_VorbisComment>(),
    32usize,
    concat!("Size of: ", stringify!(FLAC__StreamMetadata_VorbisComment))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__StreamMetadata_VorbisComment>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(FLAC__StreamMetadata_VorbisComment)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).vendor_string) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_VorbisComment),
      "::",
      stringify!(vendor_string)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).num_comments) as usize - ptr as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_VorbisComment),
      "::",
      stringify!(num_comments)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).comments) as usize - ptr as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_VorbisComment),
      "::",
      stringify!(comments)
    )
  );
}
extern "C" {
  #[doc = "< == 32 (bits)"]
  pub static FLAC__STREAM_METADATA_VORBIS_COMMENT_NUM_COMMENTS_LEN: u32;
}
#[doc = " FLAC CUESHEET track index structure.  (See the\n <A HREF=\"https://xiph.org/flac/format.html#cuesheet_track_index\">format specification</A> for\n the full description of each field.)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_CueSheet_Index {
  pub offset: FLAC__uint64,
  pub number: FLAC__byte,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_CueSheet_Index() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__StreamMetadata_CueSheet_Index> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__StreamMetadata_CueSheet_Index>(),
    16usize,
    concat!("Size of: ", stringify!(FLAC__StreamMetadata_CueSheet_Index))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__StreamMetadata_CueSheet_Index>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(FLAC__StreamMetadata_CueSheet_Index)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_CueSheet_Index),
      "::",
      stringify!(offset)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).number) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_CueSheet_Index),
      "::",
      stringify!(number)
    )
  );
}
extern "C" {
  #[doc = "< == 64 (bits)"]
  pub static FLAC__STREAM_METADATA_CUESHEET_INDEX_OFFSET_LEN: u32;
}
extern "C" {
  #[doc = "< == 8 (bits)"]
  pub static FLAC__STREAM_METADATA_CUESHEET_INDEX_NUMBER_LEN: u32;
}
extern "C" {
  #[doc = "< == 3*8 (bits)"]
  pub static FLAC__STREAM_METADATA_CUESHEET_INDEX_RESERVED_LEN: u32;
}
#[doc = " FLAC CUESHEET track structure.  (See the\n <A HREF=\"https://xiph.org/flac/format.html#cuesheet_track\">format specification</A> for\n the full description of each field.)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_CueSheet_Track {
  pub offset: FLAC__uint64,
  pub number: FLAC__byte,
  pub isrc: [::std::os::raw::c_char; 13usize],
  pub _bitfield_align_1: [u8; 0],
  pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
  pub __bindgen_padding_0: [u8; 5usize],
  pub num_indices: FLAC__byte,
  pub indices: *mut FLAC__StreamMetadata_CueSheet_Index,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_CueSheet_Track() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__StreamMetadata_CueSheet_Track> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__StreamMetadata_CueSheet_Track>(),
    40usize,
    concat!("Size of: ", stringify!(FLAC__StreamMetadata_CueSheet_Track))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__StreamMetadata_CueSheet_Track>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(FLAC__StreamMetadata_CueSheet_Track)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_CueSheet_Track),
      "::",
      stringify!(offset)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).number) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_CueSheet_Track),
      "::",
      stringify!(number)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).isrc) as usize - ptr as usize },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_CueSheet_Track),
      "::",
      stringify!(isrc)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).num_indices) as usize - ptr as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_CueSheet_Track),
      "::",
      stringify!(num_indices)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).indices) as usize - ptr as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_CueSheet_Track),
      "::",
      stringify!(indices)
    )
  );
}
impl FLAC__StreamMetadata_CueSheet_Track {
  #[inline]
  pub fn type_(&self) -> u32 {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_type(&mut self, val: u32) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(0usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn pre_emphasis(&self) -> u32 {
    unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
  }
  #[inline]
  pub fn set_pre_emphasis(&mut self, val: u32) {
    unsafe {
      let val: u32 = ::std::mem::transmute(val);
      self._bitfield_1.set(1usize, 1u8, val as u64)
    }
  }
  #[inline]
  pub fn new_bitfield_1(type_: u32, pre_emphasis: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
    let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
    __bindgen_bitfield_unit.set(0usize, 1u8, {
      let type_: u32 = unsafe { ::std::mem::transmute(type_) };
      type_ as u64
    });
    __bindgen_bitfield_unit.set(1usize, 1u8, {
      let pre_emphasis: u32 = unsafe { ::std::mem::transmute(pre_emphasis) };
      pre_emphasis as u64
    });
    __bindgen_bitfield_unit
  }
}
extern "C" {
  #[doc = "< == 64 (bits)"]
  pub static FLAC__STREAM_METADATA_CUESHEET_TRACK_OFFSET_LEN: u32;
}
extern "C" {
  #[doc = "< == 8 (bits)"]
  pub static FLAC__STREAM_METADATA_CUESHEET_TRACK_NUMBER_LEN: u32;
}
extern "C" {
  #[doc = "< == 12*8 (bits)"]
  pub static FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN: u32;
}
extern "C" {
  #[doc = "< == 1 (bit)"]
  pub static FLAC__STREAM_METADATA_CUESHEET_TRACK_TYPE_LEN: u32;
}
extern "C" {
  #[doc = "< == 1 (bit)"]
  pub static FLAC__STREAM_METADATA_CUESHEET_TRACK_PRE_EMPHASIS_LEN: u32;
}
extern "C" {
  #[doc = "< == 6+13*8 (bits)"]
  pub static FLAC__STREAM_METADATA_CUESHEET_TRACK_RESERVED_LEN: u32;
}
extern "C" {
  #[doc = "< == 8 (bits)"]
  pub static FLAC__STREAM_METADATA_CUESHEET_TRACK_NUM_INDICES_LEN: u32;
}
#[doc = " FLAC CUESHEET structure.  (See the\n <A HREF=\"https://xiph.org/flac/format.html#metadata_block_cuesheet\">format specification</A>\n for the full description of each field.)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_CueSheet {
  pub media_catalog_number: [::std::os::raw::c_char; 129usize],
  pub lead_in: FLAC__uint64,
  pub is_cd: FLAC__bool,
  pub num_tracks: u32,
  pub tracks: *mut FLAC__StreamMetadata_CueSheet_Track,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_CueSheet() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__StreamMetadata_CueSheet> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__StreamMetadata_CueSheet>(),
    160usize,
    concat!("Size of: ", stringify!(FLAC__StreamMetadata_CueSheet))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__StreamMetadata_CueSheet>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__StreamMetadata_CueSheet))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).media_catalog_number) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_CueSheet),
      "::",
      stringify!(media_catalog_number)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).lead_in) as usize - ptr as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_CueSheet),
      "::",
      stringify!(lead_in)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).is_cd) as usize - ptr as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_CueSheet),
      "::",
      stringify!(is_cd)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).num_tracks) as usize - ptr as usize },
    148usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_CueSheet),
      "::",
      stringify!(num_tracks)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).tracks) as usize - ptr as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_CueSheet),
      "::",
      stringify!(tracks)
    )
  );
}
extern "C" {
  #[doc = "< == 128*8 (bits)"]
  pub static FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN: u32;
}
extern "C" {
  #[doc = "< == 64 (bits)"]
  pub static FLAC__STREAM_METADATA_CUESHEET_LEAD_IN_LEN: u32;
}
extern "C" {
  #[doc = "< == 1 (bit)"]
  pub static FLAC__STREAM_METADATA_CUESHEET_IS_CD_LEN: u32;
}
extern "C" {
  #[doc = "< == 7+258*8 (bits)"]
  pub static FLAC__STREAM_METADATA_CUESHEET_RESERVED_LEN: u32;
}
extern "C" {
  #[doc = "< == 8 (bits)"]
  pub static FLAC__STREAM_METADATA_CUESHEET_NUM_TRACKS_LEN: u32;
}
#[doc = "< Other"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER:
  FLAC__StreamMetadata_Picture_Type = 0;
#[doc = "< 32x32 pixels 'file icon' (PNG only)"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD : FLAC__StreamMetadata_Picture_Type = 1 ;
#[doc = "< Other file icon"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON:
  FLAC__StreamMetadata_Picture_Type = 2;
#[doc = "< Cover (front)"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER:
  FLAC__StreamMetadata_Picture_Type = 3;
#[doc = "< Cover (back)"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER:
  FLAC__StreamMetadata_Picture_Type = 4;
#[doc = "< Leaflet page"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE:
  FLAC__StreamMetadata_Picture_Type = 5;
#[doc = "< Media (e.g. label side of CD)"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA:
  FLAC__StreamMetadata_Picture_Type = 6;
#[doc = "< Lead artist/lead performer/soloist"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST:
  FLAC__StreamMetadata_Picture_Type = 7;
#[doc = "< Artist/performer"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST:
  FLAC__StreamMetadata_Picture_Type = 8;
#[doc = "< Conductor"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR:
  FLAC__StreamMetadata_Picture_Type = 9;
#[doc = "< Band/Orchestra"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND:
  FLAC__StreamMetadata_Picture_Type = 10;
#[doc = "< Composer"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER:
  FLAC__StreamMetadata_Picture_Type = 11;
#[doc = "< Lyricist/text writer"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST:
  FLAC__StreamMetadata_Picture_Type = 12;
#[doc = "< Recording Location"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION : FLAC__StreamMetadata_Picture_Type = 13 ;
#[doc = "< During recording"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING:
  FLAC__StreamMetadata_Picture_Type = 14;
#[doc = "< During performance"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE : FLAC__StreamMetadata_Picture_Type = 15 ;
#[doc = "< Movie/video screen capture"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE : FLAC__StreamMetadata_Picture_Type = 16 ;
#[doc = "< A bright coloured fish"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_FISH:
  FLAC__StreamMetadata_Picture_Type = 17;
#[doc = "< Illustration"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION:
  FLAC__StreamMetadata_Picture_Type = 18;
#[doc = "< Band/artist logotype"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE:
  FLAC__StreamMetadata_Picture_Type = 19;
#[doc = "< Publisher/Studio logotype"]
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE : FLAC__StreamMetadata_Picture_Type = 20 ;
pub const FLAC__StreamMetadata_Picture_Type_FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED:
  FLAC__StreamMetadata_Picture_Type = 21;
#[doc = " An enumeration of the PICTURE types (see FLAC__StreamMetadataPicture and id3 v2.4 APIC tag)."]
pub type FLAC__StreamMetadata_Picture_Type = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__StreamMetadata_Picture_Type to a C string.\n\n  Using a FLAC__StreamMetadata_Picture_Type as the index to this array\n  will give the string equivalent.  The contents should not be\n  modified."]
  pub static FLAC__StreamMetadata_Picture_TypeString: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = " FLAC PICTURE structure.  (See the\n <A HREF=\"https://xiph.org/flac/format.html#metadata_block_picture\">format specification</A>\n for the full description of each field.)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_Picture {
  pub type_: FLAC__StreamMetadata_Picture_Type,
  pub mime_type: *mut ::std::os::raw::c_char,
  pub description: *mut FLAC__byte,
  pub width: FLAC__uint32,
  pub height: FLAC__uint32,
  pub depth: FLAC__uint32,
  pub colors: FLAC__uint32,
  pub data_length: FLAC__uint32,
  pub data: *mut FLAC__byte,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_Picture() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__StreamMetadata_Picture> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__StreamMetadata_Picture>(),
    56usize,
    concat!("Size of: ", stringify!(FLAC__StreamMetadata_Picture))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__StreamMetadata_Picture>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__StreamMetadata_Picture))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_Picture),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).mime_type) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_Picture),
      "::",
      stringify!(mime_type)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_Picture),
      "::",
      stringify!(description)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_Picture),
      "::",
      stringify!(width)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_Picture),
      "::",
      stringify!(height)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_Picture),
      "::",
      stringify!(depth)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).colors) as usize - ptr as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_Picture),
      "::",
      stringify!(colors)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).data_length) as usize - ptr as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_Picture),
      "::",
      stringify!(data_length)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_Picture),
      "::",
      stringify!(data)
    )
  );
}
extern "C" {
  #[doc = "< == 32 (bits)"]
  pub static FLAC__STREAM_METADATA_PICTURE_TYPE_LEN: u32;
}
extern "C" {
  #[doc = "< == 32 (bits)"]
  pub static FLAC__STREAM_METADATA_PICTURE_MIME_TYPE_LENGTH_LEN: u32;
}
extern "C" {
  #[doc = "< == 32 (bits)"]
  pub static FLAC__STREAM_METADATA_PICTURE_DESCRIPTION_LENGTH_LEN: u32;
}
extern "C" {
  #[doc = "< == 32 (bits)"]
  pub static FLAC__STREAM_METADATA_PICTURE_WIDTH_LEN: u32;
}
extern "C" {
  #[doc = "< == 32 (bits)"]
  pub static FLAC__STREAM_METADATA_PICTURE_HEIGHT_LEN: u32;
}
extern "C" {
  #[doc = "< == 32 (bits)"]
  pub static FLAC__STREAM_METADATA_PICTURE_DEPTH_LEN: u32;
}
extern "C" {
  #[doc = "< == 32 (bits)"]
  pub static FLAC__STREAM_METADATA_PICTURE_COLORS_LEN: u32;
}
extern "C" {
  #[doc = "< == 32 (bits)"]
  pub static FLAC__STREAM_METADATA_PICTURE_DATA_LENGTH_LEN: u32;
}
#[doc = " Structure that is used when a metadata block of unknown type is loaded.\n  The contents are opaque.  The structure is used only internally to\n  correctly handle unknown metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamMetadata_Unknown {
  pub data: *mut FLAC__byte,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata_Unknown() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__StreamMetadata_Unknown> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__StreamMetadata_Unknown>(),
    8usize,
    concat!("Size of: ", stringify!(FLAC__StreamMetadata_Unknown))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__StreamMetadata_Unknown>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__StreamMetadata_Unknown))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata_Unknown),
      "::",
      stringify!(data)
    )
  );
}
#[doc = " FLAC metadata block structure.  (c.f. <A HREF=\"https://xiph.org/flac/format.html#metadata_block\">format specification</A>)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FLAC__StreamMetadata {
  pub type_: FLAC__MetadataType,
  pub is_last: FLAC__bool,
  pub length: u32,
  pub data: FLAC__StreamMetadata__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FLAC__StreamMetadata__bindgen_ty_1 {
  pub stream_info: FLAC__StreamMetadata_StreamInfo,
  pub padding: FLAC__StreamMetadata_Padding,
  pub application: FLAC__StreamMetadata_Application,
  pub seek_table: FLAC__StreamMetadata_SeekTable,
  pub vorbis_comment: FLAC__StreamMetadata_VorbisComment,
  pub cue_sheet: FLAC__StreamMetadata_CueSheet,
  pub picture: FLAC__StreamMetadata_Picture,
  pub unknown: FLAC__StreamMetadata_Unknown,
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata__bindgen_ty_1() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__StreamMetadata__bindgen_ty_1> =
    ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__StreamMetadata__bindgen_ty_1>(),
    160usize,
    concat!("Size of: ", stringify!(FLAC__StreamMetadata__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__StreamMetadata__bindgen_ty_1>(),
    8usize,
    concat!(
      "Alignment of ",
      stringify!(FLAC__StreamMetadata__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).stream_info) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata__bindgen_ty_1),
      "::",
      stringify!(stream_info)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata__bindgen_ty_1),
      "::",
      stringify!(padding)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).application) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata__bindgen_ty_1),
      "::",
      stringify!(application)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).seek_table) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata__bindgen_ty_1),
      "::",
      stringify!(seek_table)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).vorbis_comment) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata__bindgen_ty_1),
      "::",
      stringify!(vorbis_comment)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).cue_sheet) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata__bindgen_ty_1),
      "::",
      stringify!(cue_sheet)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).picture) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata__bindgen_ty_1),
      "::",
      stringify!(picture)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).unknown) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata__bindgen_ty_1),
      "::",
      stringify!(unknown)
    )
  );
}
#[test]
fn bindgen_test_layout_FLAC__StreamMetadata() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__StreamMetadata> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__StreamMetadata>(),
    176usize,
    concat!("Size of: ", stringify!(FLAC__StreamMetadata))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__StreamMetadata>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__StreamMetadata))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).is_last) as usize - ptr as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata),
      "::",
      stringify!(is_last)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamMetadata),
      "::",
      stringify!(data)
    )
  );
}
extern "C" {
  #[doc = "< == 1 (bit)"]
  pub static FLAC__STREAM_METADATA_IS_LAST_LEN: u32;
}
extern "C" {
  #[doc = "< == 7 (bits)"]
  pub static FLAC__STREAM_METADATA_TYPE_LEN: u32;
}
extern "C" {
  #[doc = "< == 24 (bits)"]
  pub static FLAC__STREAM_METADATA_LENGTH_LEN: u32;
}
extern "C" {
  #[doc = " Tests that a sample rate is valid for FLAC.\n\n \\param sample_rate  The sample rate to test for compliance.\n \\retval FLAC__bool\n    \\c true if the given sample rate conforms to the specification, else\n    \\c false."]
  pub fn FLAC__format_sample_rate_is_valid(sample_rate: u32) -> FLAC__bool;
}
extern "C" {
  #[doc = " Tests that a blocksize at the given sample rate is valid for the FLAC\n  subset.\n\n \\param blocksize    The blocksize to test for compliance.\n \\param sample_rate  The sample rate is needed, since the valid subset\n                     blocksize depends on the sample rate.\n \\retval FLAC__bool\n    \\c true if the given blocksize conforms to the specification for the\n    subset at the given sample rate, else \\c false."]
  pub fn FLAC__format_blocksize_is_subset(blocksize: u32, sample_rate: u32) -> FLAC__bool;
}
extern "C" {
  #[doc = " Tests that a sample rate is valid for the FLAC subset.  The subset rules\n  for valid sample rates are slightly more complex since the rate has to\n  be expressible completely in the frame header.\n\n \\param sample_rate  The sample rate to test for compliance.\n \\retval FLAC__bool\n    \\c true if the given sample rate conforms to the specification for the\n    subset, else \\c false."]
  pub fn FLAC__format_sample_rate_is_subset(sample_rate: u32) -> FLAC__bool;
}
extern "C" {
  #[doc = " Check a Vorbis comment entry name to see if it conforms to the Vorbis\n  comment specification.\n\n  Vorbis comment names must be composed only of characters from\n  [0x20-0x3C,0x3E-0x7D].\n\n \\param name       A NUL-terminated string to be checked.\n \\assert\n    \\code name != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if entry name is illegal, else \\c true."]
  pub fn FLAC__format_vorbiscomment_entry_name_is_legal(
    name: *const ::std::os::raw::c_char,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Check a Vorbis comment entry value to see if it conforms to the Vorbis\n  comment specification.\n\n  Vorbis comment values must be valid UTF-8 sequences.\n\n \\param value      A string to be checked.\n \\param length     A the length of \\a value in bytes.  May be\n                   \\c (uint32_t)(-1) to indicate that \\a value is a plain\n                   UTF-8 NUL-terminated string.\n \\assert\n    \\code value != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if entry name is illegal, else \\c true."]
  pub fn FLAC__format_vorbiscomment_entry_value_is_legal(
    value: *const FLAC__byte,
    length: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Check a Vorbis comment entry to see if it conforms to the Vorbis\n  comment specification.\n\n  Vorbis comment entries must be of the form 'name=value', and 'name' and\n  'value' must be legal according to\n  FLAC__format_vorbiscomment_entry_name_is_legal() and\n  FLAC__format_vorbiscomment_entry_value_is_legal() respectively.\n\n \\param entry      An entry to be checked.\n \\param length     The length of \\a entry in bytes.\n \\assert\n    \\code value != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if entry name is illegal, else \\c true."]
  pub fn FLAC__format_vorbiscomment_entry_is_legal(
    entry: *const FLAC__byte,
    length: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Check a seek table to see if it conforms to the FLAC specification.\n  See the format specification for limits on the contents of the\n  seek table.\n\n \\param seek_table  A pointer to a seek table to be checked.\n \\assert\n    \\code seek_table != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if seek table is illegal, else \\c true."]
  pub fn FLAC__format_seektable_is_legal(
    seek_table: *const FLAC__StreamMetadata_SeekTable,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Sort a seek table's seek points according to the format specification.\n  This includes a \"unique-ification\" step to remove duplicates, i.e.\n  seek points with identical \\a sample_number values.  Duplicate seek\n  points are converted into placeholder points and sorted to the end of\n  the table.\n\n \\param seek_table  A pointer to a seek table to be sorted.\n \\assert\n    \\code seek_table != NULL \\endcode\n \\retval uint32_t\n    The number of duplicate seek points converted into placeholders."]
  pub fn FLAC__format_seektable_sort(seek_table: *mut FLAC__StreamMetadata_SeekTable) -> u32;
}
extern "C" {
  #[doc = " Check a cue sheet to see if it conforms to the FLAC specification.\n  See the format specification for limits on the contents of the\n  cue sheet.\n\n \\param cue_sheet  A pointer to an existing cue sheet to be checked.\n \\param check_cd_da_subset  If \\c true, check CUESHEET against more\n                   stringent requirements for a CD-DA (audio) disc.\n \\param violation  Address of a pointer to a string.  If there is a\n                   violation, a pointer to a string explanation of the\n                   violation will be returned here. \\a violation may be\n                   \\c NULL if you don't need the returned string.  Do not\n                   free the returned string; it will always point to static\n                   data.\n \\assert\n    \\code cue_sheet != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if cue sheet is illegal, else \\c true."]
  pub fn FLAC__format_cuesheet_is_legal(
    cue_sheet: *const FLAC__StreamMetadata_CueSheet,
    check_cd_da_subset: FLAC__bool,
    violation: *mut *const ::std::os::raw::c_char,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Check picture data to see if it conforms to the FLAC specification.\n  See the format specification for limits on the contents of the\n  PICTURE block.\n\n \\param picture    A pointer to existing picture data to be checked.\n \\param violation  Address of a pointer to a string.  If there is a\n                   violation, a pointer to a string explanation of the\n                   violation will be returned here. \\a violation may be\n                   \\c NULL if you don't need the returned string.  Do not\n                   free the returned string; it will always point to static\n                   data.\n \\assert\n    \\code picture != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if picture data is illegal, else \\c true."]
  pub fn FLAC__format_picture_is_legal(
    picture: *const FLAC__StreamMetadata_Picture,
    violation: *mut *const ::std::os::raw::c_char,
  ) -> FLAC__bool;
}
pub type _ino_t = ::std::os::raw::c_ushort;
pub type ino_t = _ino_t;
pub type _dev_t = ::std::os::raw::c_uint;
pub type dev_t = _dev_t;
pub type _off_t = ::std::os::raw::c_long;
pub type off_t = _off_t;
extern "C" {
  #[doc = " Read the STREAMINFO metadata block of the given FLAC file.  This function\n  will try to skip any ID3v2 tag at the head of the file.\n\n \\param filename    The path to the FLAC file to read.\n \\param streaminfo  A pointer to space for the STREAMINFO block.  Since\n                    FLAC__StreamMetadata is a simple structure with no\n                    memory allocation involved, you pass the address of\n                    an existing structure.  It need not be initialized.\n \\assert\n    \\code filename != NULL \\endcode\n    \\code streaminfo != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if a valid STREAMINFO block was read from \\a filename.  Returns\n    \\c false if there was a memory allocation error, a file decoder error,\n    or the file contained no STREAMINFO block.  (A memory allocation error\n    is possible because this function must set up a file decoder.)"]
  pub fn FLAC__metadata_get_streaminfo(
    filename: *const ::std::os::raw::c_char,
    streaminfo: *mut FLAC__StreamMetadata,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Read the VORBIS_COMMENT metadata block of the given FLAC file.  This\n  function will try to skip any ID3v2 tag at the head of the file.\n\n \\param filename    The path to the FLAC file to read.\n \\param tags        The address where the returned pointer will be\n                    stored.  The \\a tags object must be deleted by\n                    the caller using FLAC__metadata_object_delete().\n \\assert\n    \\code filename != NULL \\endcode\n    \\code tags != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if a valid VORBIS_COMMENT block was read from \\a filename,\n    and \\a *tags will be set to the address of the metadata structure.\n    Returns \\c false if there was a memory allocation error, a file\n    decoder error, or the file contained no VORBIS_COMMENT block, and\n    \\a *tags will be set to \\c NULL."]
  pub fn FLAC__metadata_get_tags(
    filename: *const ::std::os::raw::c_char,
    tags: *mut *mut FLAC__StreamMetadata,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Read the CUESHEET metadata block of the given FLAC file.  This\n  function will try to skip any ID3v2 tag at the head of the file.\n\n \\param filename    The path to the FLAC file to read.\n \\param cuesheet    The address where the returned pointer will be\n                    stored.  The \\a cuesheet object must be deleted by\n                    the caller using FLAC__metadata_object_delete().\n \\assert\n    \\code filename != NULL \\endcode\n    \\code cuesheet != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if a valid CUESHEET block was read from \\a filename,\n    and \\a *cuesheet will be set to the address of the metadata\n    structure.  Returns \\c false if there was a memory allocation\n    error, a file decoder error, or the file contained no CUESHEET\n    block, and \\a *cuesheet will be set to \\c NULL."]
  pub fn FLAC__metadata_get_cuesheet(
    filename: *const ::std::os::raw::c_char,
    cuesheet: *mut *mut FLAC__StreamMetadata,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Read a PICTURE metadata block of the given FLAC file.  This\n  function will try to skip any ID3v2 tag at the head of the file.\n  Since there can be more than one PICTURE block in a file, this\n  function takes a number of parameters that act as constraints to\n  the search.  The PICTURE block with the largest area matching all\n  the constraints will be returned, or \\a *picture will be set to\n  \\c NULL if there was no such block.\n\n \\param filename    The path to the FLAC file to read.\n \\param picture     The address where the returned pointer will be\n                    stored.  The \\a picture object must be deleted by\n                    the caller using FLAC__metadata_object_delete().\n \\param type        The desired picture type.  Use \\c -1 to mean\n                    \"any type\".\n \\param mime_type   The desired MIME type, e.g. \"image/jpeg\".  The\n                    string will be matched exactly.  Use \\c NULL to\n                    mean \"any MIME type\".\n \\param description The desired description.  The string will be\n                    matched exactly.  Use \\c NULL to mean \"any\n                    description\".\n \\param max_width   The maximum width in pixels desired.  Use\n                    \\c (uint32_t)(-1) to mean \"any width\".\n \\param max_height  The maximum height in pixels desired.  Use\n                    \\c (uint32_t)(-1) to mean \"any height\".\n \\param max_depth   The maximum color depth in bits-per-pixel desired.\n                    Use \\c (uint32_t)(-1) to mean \"any depth\".\n \\param max_colors  The maximum number of colors desired.  Use\n                    \\c (uint32_t)(-1) to mean \"any number of colors\".\n \\assert\n    \\code filename != NULL \\endcode\n    \\code picture != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if a valid PICTURE block was read from \\a filename,\n    and \\a *picture will be set to the address of the metadata\n    structure.  Returns \\c false if there was a memory allocation\n    error, a file decoder error, or the file contained no PICTURE\n    block, and \\a *picture will be set to \\c NULL."]
  pub fn FLAC__metadata_get_picture(
    filename: *const ::std::os::raw::c_char,
    picture: *mut *mut FLAC__StreamMetadata,
    type_: FLAC__StreamMetadata_Picture_Type,
    mime_type: *const ::std::os::raw::c_char,
    description: *const FLAC__byte,
    max_width: u32,
    max_height: u32,
    max_depth: u32,
    max_colors: u32,
  ) -> FLAC__bool;
}
#[doc = " \\defgroup flac_metadata_level1 FLAC/metadata.h: metadata level 1 interface\n  \\ingroup flac_metadata\n\n \\brief\n The level 1 interface provides read-write access to FLAC file metadata and\n operates directly on the FLAC file.\n\n The general usage of this interface is:\n\n - Create an iterator using FLAC__metadata_simple_iterator_new()\n - Attach it to a file using FLAC__metadata_simple_iterator_init() and check\n   the exit code.  Call FLAC__metadata_simple_iterator_is_writable() to\n   see if the file is writable, or only read access is allowed.\n - Use FLAC__metadata_simple_iterator_next() and\n   FLAC__metadata_simple_iterator_prev() to traverse the blocks.\n   This is does not read the actual blocks themselves.\n   FLAC__metadata_simple_iterator_next() is relatively fast.\n   FLAC__metadata_simple_iterator_prev() is slower since it needs to search\n   forward from the front of the file.\n - Use FLAC__metadata_simple_iterator_get_block_type() or\n   FLAC__metadata_simple_iterator_get_block() to access the actual data at\n   the current iterator position.  The returned object is yours to modify\n   and free.\n - Use FLAC__metadata_simple_iterator_set_block() to write a modified block\n   back.  You must have write permission to the original file.  Make sure to\n   read the whole comment to FLAC__metadata_simple_iterator_set_block()\n   below.\n - Use FLAC__metadata_simple_iterator_insert_block_after() to add new blocks.\n   Use the object creation functions from\n   \\link flac_metadata_object here \\endlink to generate new objects.\n - Use FLAC__metadata_simple_iterator_delete_block() to remove the block\n   currently referred to by the iterator, or replace it with padding.\n - Destroy the iterator with FLAC__metadata_simple_iterator_delete() when\n   finished.\n\n \\note\n The FLAC file remains open the whole time between\n FLAC__metadata_simple_iterator_init() and\n FLAC__metadata_simple_iterator_delete(), so make sure you are not altering\n the file during this time.\n\n \\note\n Do not modify the \\a is_last, \\a length, or \\a type fields of returned\n FLAC__StreamMetadata objects.  These are managed automatically.\n\n \\note\n If any of the modification functions\n (FLAC__metadata_simple_iterator_set_block(),\n FLAC__metadata_simple_iterator_delete_block(),\n FLAC__metadata_simple_iterator_insert_block_after(), etc.) return \\c false,\n you should delete the iterator as it may no longer be valid.\n\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__Metadata_SimpleIterator {
  _unused: [u8; 0],
}
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_OK:
  FLAC__Metadata_SimpleIteratorStatus = 0;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_ILLEGAL_INPUT : FLAC__Metadata_SimpleIteratorStatus = 1 ;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_ERROR_OPENING_FILE : FLAC__Metadata_SimpleIteratorStatus = 2 ;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_NOT_A_FLAC_FILE : FLAC__Metadata_SimpleIteratorStatus = 3 ;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_NOT_WRITABLE:
  FLAC__Metadata_SimpleIteratorStatus = 4;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_BAD_METADATA:
  FLAC__Metadata_SimpleIteratorStatus = 5;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_READ_ERROR:
  FLAC__Metadata_SimpleIteratorStatus = 6;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_SEEK_ERROR:
  FLAC__Metadata_SimpleIteratorStatus = 7;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_WRITE_ERROR:
  FLAC__Metadata_SimpleIteratorStatus = 8;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_RENAME_ERROR:
  FLAC__Metadata_SimpleIteratorStatus = 9;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_UNLINK_ERROR:
  FLAC__Metadata_SimpleIteratorStatus = 10;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_MEMORY_ALLOCATION_ERROR : FLAC__Metadata_SimpleIteratorStatus = 11 ;
pub const FLAC__Metadata_SimpleIteratorStatus_FLAC__METADATA_SIMPLE_ITERATOR_STATUS_INTERNAL_ERROR : FLAC__Metadata_SimpleIteratorStatus = 12 ;
#[doc = " Status type for FLAC__Metadata_SimpleIterator.\n\n  The iterator's current status can be obtained by calling FLAC__metadata_simple_iterator_status()."]
pub type FLAC__Metadata_SimpleIteratorStatus = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__Metadata_SimpleIteratorStatus to a C string.\n\n  Using a FLAC__Metadata_SimpleIteratorStatus as the index to this array\n  will give the string equivalent.  The contents should not be modified."]
  pub static FLAC__Metadata_SimpleIteratorStatusString: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
  #[doc = " Create a new iterator instance.\n\n \\retval FLAC__Metadata_SimpleIterator*\n    \\c NULL if there was an error allocating memory, else the new instance."]
  pub fn FLAC__metadata_simple_iterator_new() -> *mut FLAC__Metadata_SimpleIterator;
}
extern "C" {
  #[doc = " Free an iterator instance.  Deletes the object pointed to by \\a iterator.\n\n \\param iterator  A pointer to an existing iterator.\n \\assert\n    \\code iterator != NULL \\endcode"]
  pub fn FLAC__metadata_simple_iterator_delete(iterator: *mut FLAC__Metadata_SimpleIterator);
}
extern "C" {
  #[doc = " Get the current status of the iterator.  Call this after a function\n  returns \\c false to get the reason for the error.  Also resets the status\n  to FLAC__METADATA_SIMPLE_ITERATOR_STATUS_OK.\n\n \\param iterator  A pointer to an existing iterator.\n \\assert\n    \\code iterator != NULL \\endcode\n \\retval FLAC__Metadata_SimpleIteratorStatus\n    The current status of the iterator."]
  pub fn FLAC__metadata_simple_iterator_status(
    iterator: *mut FLAC__Metadata_SimpleIterator,
  ) -> FLAC__Metadata_SimpleIteratorStatus;
}
extern "C" {
  #[doc = " Initialize the iterator to point to the first metadata block in the\n  given FLAC file.\n\n  On Windows, filename must be a UTF-8 encoded filename, which libFLAC\n  internally translates to an appropriate representation to use with\n  _wfopen. On all other systems, filename is passed to fopen without\n  any translation.\n\n \\param iterator             A pointer to an existing iterator.\n \\param filename             The path to the FLAC file.\n \\param read_only            If \\c true, the FLAC file will be opened\n                             in read-only mode; if \\c false, the FLAC\n                             file will be opened for edit even if no\n                             edits are performed.\n \\param preserve_file_stats  If \\c true, the owner and modification\n                             time will be preserved even if the FLAC\n                             file is written to.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\code filename != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if a memory allocation error occurs, the file can't be\n    opened, or another error occurs, else \\c true."]
  pub fn FLAC__metadata_simple_iterator_init(
    iterator: *mut FLAC__Metadata_SimpleIterator,
    filename: *const ::std::os::raw::c_char,
    read_only: FLAC__bool,
    preserve_file_stats: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Returns \\c true if the FLAC file is writable.  If \\c false, calls to\n  FLAC__metadata_simple_iterator_set_block() and\n  FLAC__metadata_simple_iterator_insert_block_after() will fail.\n\n \\param iterator             A pointer to an existing iterator.\n \\assert\n    \\code iterator != NULL \\endcode\n \\retval FLAC__bool\n    See above."]
  pub fn FLAC__metadata_simple_iterator_is_writable(
    iterator: *const FLAC__Metadata_SimpleIterator,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Moves the iterator forward one metadata block, returning \\c false if\n  already at the end.\n\n \\param iterator  A pointer to an existing initialized iterator.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_simple_iterator_init()\n \\retval FLAC__bool\n    \\c false if already at the last metadata block of the chain, else\n    \\c true."]
  pub fn FLAC__metadata_simple_iterator_next(
    iterator: *mut FLAC__Metadata_SimpleIterator,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Moves the iterator backward one metadata block, returning \\c false if\n  already at the beginning.\n\n \\param iterator  A pointer to an existing initialized iterator.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_simple_iterator_init()\n \\retval FLAC__bool\n    \\c false if already at the first metadata block of the chain, else\n    \\c true."]
  pub fn FLAC__metadata_simple_iterator_prev(
    iterator: *mut FLAC__Metadata_SimpleIterator,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Returns a flag telling if the current metadata block is the last.\n\n \\param iterator  A pointer to an existing initialized iterator.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_simple_iterator_init()\n \\retval FLAC__bool\n    \\c true if the current metadata block is the last in the file,\n    else \\c false."]
  pub fn FLAC__metadata_simple_iterator_is_last(
    iterator: *const FLAC__Metadata_SimpleIterator,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Get the offset of the metadata block at the current position.  This\n  avoids reading the actual block data which can save time for large\n  blocks.\n\n \\param iterator  A pointer to an existing initialized iterator.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_simple_iterator_init()\n \\retval off_t\n    The offset of the metadata block at the current iterator position.\n    This is the byte offset relative to the beginning of the file of\n    the current metadata block's header."]
  pub fn FLAC__metadata_simple_iterator_get_block_offset(
    iterator: *const FLAC__Metadata_SimpleIterator,
  ) -> off_t;
}
extern "C" {
  #[doc = " Get the type of the metadata block at the current position.  This\n  avoids reading the actual block data which can save time for large\n  blocks.\n\n \\param iterator  A pointer to an existing initialized iterator.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_simple_iterator_init()\n \\retval FLAC__MetadataType\n    The type of the metadata block at the current iterator position."]
  pub fn FLAC__metadata_simple_iterator_get_block_type(
    iterator: *const FLAC__Metadata_SimpleIterator,
  ) -> FLAC__MetadataType;
}
extern "C" {
  #[doc = " Get the length of the metadata block at the current position.  This\n  avoids reading the actual block data which can save time for large\n  blocks.\n\n \\param iterator  A pointer to an existing initialized iterator.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_simple_iterator_init()\n \\retval uint32_t\n    The length of the metadata block at the current iterator position.\n    The is same length as that in the\n    <a href=\"http://xiph.org/flhttps://xiph.org/flac/format.html#metadata_block_header\">metadata block header</a>,\n    i.e. the length of the metadata body that follows the header."]
  pub fn FLAC__metadata_simple_iterator_get_block_length(
    iterator: *const FLAC__Metadata_SimpleIterator,
  ) -> u32;
}
extern "C" {
  #[doc = " Get the application ID of the \\c APPLICATION block at the current\n  position.  This avoids reading the actual block data which can save\n  time for large blocks.\n\n \\param iterator  A pointer to an existing initialized iterator.\n \\param id        A pointer to a buffer of at least \\c 4 bytes where\n                  the ID will be stored.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\code id != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_simple_iterator_init()\n \\retval FLAC__bool\n    \\c true if the ID was successfully read, else \\c false, in which\n    case you should check FLAC__metadata_simple_iterator_status() to\n    find out why.  If the status is\n    \\c FLAC__METADATA_SIMPLE_ITERATOR_STATUS_ILLEGAL_INPUT, then the\n    current metadata block is not an \\c APPLICATION block.  Otherwise\n    if the status is\n    \\c FLAC__METADATA_SIMPLE_ITERATOR_STATUS_READ_ERROR or\n    \\c FLAC__METADATA_SIMPLE_ITERATOR_STATUS_SEEK_ERROR, an I/O error\n    occurred and the iterator can no longer be used."]
  pub fn FLAC__metadata_simple_iterator_get_application_id(
    iterator: *mut FLAC__Metadata_SimpleIterator,
    id: *mut FLAC__byte,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Get the metadata block at the current position.  You can modify the\n  block but must use FLAC__metadata_simple_iterator_set_block() to\n  write it back to the FLAC file.\n\n  You must call FLAC__metadata_object_delete() on the returned object\n  when you are finished with it.\n\n \\param iterator  A pointer to an existing initialized iterator.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_simple_iterator_init()\n \\retval FLAC__StreamMetadata*\n    The current metadata block, or \\c NULL if there was a memory\n    allocation error."]
  pub fn FLAC__metadata_simple_iterator_get_block(
    iterator: *mut FLAC__Metadata_SimpleIterator,
  ) -> *mut FLAC__StreamMetadata;
}
extern "C" {
  #[doc = " Write a block back to the FLAC file.  This function tries to be\n  as efficient as possible; how the block is actually written is\n  shown by the following:\n\n  Existing block is a STREAMINFO block and the new block is a\n  STREAMINFO block: the new block is written in place.  Make sure\n  you know what you're doing when changing the values of a\n  STREAMINFO block.\n\n  Existing block is a STREAMINFO block and the new block is a\n  not a STREAMINFO block: this is an error since the first block\n  must be a STREAMINFO block.  Returns \\c false without altering the\n  file.\n\n  Existing block is not a STREAMINFO block and the new block is a\n  STREAMINFO block: this is an error since there may be only one\n  STREAMINFO block.  Returns \\c false without altering the file.\n\n  Existing block and new block are the same length: the existing\n  block will be replaced by the new block, written in place.\n\n  Existing block is longer than new block: if use_padding is \\c true,\n  the existing block will be overwritten in place with the new\n  block followed by a PADDING block, if possible, to make the total\n  size the same as the existing block.  Remember that a padding\n  block requires at least four bytes so if the difference in size\n  between the new block and existing block is less than that, the\n  entire file will have to be rewritten, using the new block's\n  exact size.  If use_padding is \\c false, the entire file will be\n  rewritten, replacing the existing block by the new block.\n\n  Existing block is shorter than new block: if use_padding is \\c true,\n  the function will try and expand the new block into the following\n  PADDING block, if it exists and doing so won't shrink the PADDING\n  block to less than 4 bytes.  If there is no following PADDING\n  block, or it will shrink to less than 4 bytes, or use_padding is\n  \\c false, the entire file is rewritten, replacing the existing block\n  with the new block.  Note that in this case any following PADDING\n  block is preserved as is.\n\n  After writing the block, the iterator will remain in the same\n  place, i.e. pointing to the new block.\n\n \\param iterator     A pointer to an existing initialized iterator.\n \\param block        The block to set.\n \\param use_padding  See above.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_simple_iterator_init()\n    \\code block != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if successful, else \\c false."]
  pub fn FLAC__metadata_simple_iterator_set_block(
    iterator: *mut FLAC__Metadata_SimpleIterator,
    block: *mut FLAC__StreamMetadata,
    use_padding: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " This is similar to FLAC__metadata_simple_iterator_set_block()\n  except that instead of writing over an existing block, it appends\n  a block after the existing block.  \\a use_padding is again used to\n  tell the function to try an expand into following padding in an\n  attempt to avoid rewriting the entire file.\n\n  This function will fail and return \\c false if given a STREAMINFO\n  block.\n\n  After writing the block, the iterator will be pointing to the\n  new block.\n\n \\param iterator     A pointer to an existing initialized iterator.\n \\param block        The block to set.\n \\param use_padding  See above.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_simple_iterator_init()\n    \\code block != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if successful, else \\c false."]
  pub fn FLAC__metadata_simple_iterator_insert_block_after(
    iterator: *mut FLAC__Metadata_SimpleIterator,
    block: *mut FLAC__StreamMetadata,
    use_padding: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Deletes the block at the current position.  This will cause the\n  entire FLAC file to be rewritten, unless \\a use_padding is \\c true,\n  in which case the block will be replaced by an equal-sized PADDING\n  block.  The iterator will be left pointing to the block before the\n  one just deleted.\n\n  You may not delete the STREAMINFO block.\n\n \\param iterator     A pointer to an existing initialized iterator.\n \\param use_padding  See above.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_simple_iterator_init()\n \\retval FLAC__bool\n    \\c true if successful, else \\c false."]
  pub fn FLAC__metadata_simple_iterator_delete_block(
    iterator: *mut FLAC__Metadata_SimpleIterator,
    use_padding: FLAC__bool,
  ) -> FLAC__bool;
}
#[doc = " \\defgroup flac_metadata_level2 FLAC/metadata.h: metadata level 2 interface\n  \\ingroup flac_metadata\n\n \\brief\n The level 2 interface provides read-write access to FLAC file metadata;\n all metadata is read into memory, operated on in memory, and then written\n to file, which is more efficient than level 1 when editing multiple blocks.\n\n Currently Ogg FLAC is supported for read only, via\n FLAC__metadata_chain_read_ogg() but a subsequent\n FLAC__metadata_chain_write() will fail.\n\n The general usage of this interface is:\n\n - Create a new chain using FLAC__metadata_chain_new().  A chain is a\n   linked list of FLAC metadata blocks.\n - Read all metadata into the chain from a FLAC file using\n   FLAC__metadata_chain_read() or FLAC__metadata_chain_read_ogg() and\n   check the status.\n - Optionally, consolidate the padding using\n   FLAC__metadata_chain_merge_padding() or\n   FLAC__metadata_chain_sort_padding().\n - Create a new iterator using FLAC__metadata_iterator_new()\n - Initialize the iterator to point to the first element in the chain\n   using FLAC__metadata_iterator_init()\n - Traverse the chain using FLAC__metadata_iterator_next and\n   FLAC__metadata_iterator_prev().\n - Get a block for reading or modification using\n   FLAC__metadata_iterator_get_block().  The pointer to the object\n   inside the chain is returned, so the block is yours to modify.\n   Changes will be reflected in the FLAC file when you write the\n   chain.  You can also add and delete blocks (see functions below).\n - When done, write out the chain using FLAC__metadata_chain_write().\n   Make sure to read the whole comment to the function below.\n - Delete the chain using FLAC__metadata_chain_delete().\n\n \\note\n Even though the FLAC file is not open while the chain is being\n manipulated, you must not alter the file externally during\n this time.  The chain assumes the FLAC file will not change\n between the time of FLAC__metadata_chain_read()/FLAC__metadata_chain_read_ogg()\n and FLAC__metadata_chain_write().\n\n \\note\n Do not modify the is_last, length, or type fields of returned\n FLAC__StreamMetadata objects.  These are managed automatically.\n\n \\note\n The metadata objects returned by FLAC__metadata_iterator_get_block()\n are owned by the chain; do not FLAC__metadata_object_delete() them.\n In the same way, blocks passed to FLAC__metadata_iterator_set_block()\n become owned by the chain and they will be deleted when the chain is\n deleted.\n\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__Metadata_Chain {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__Metadata_Iterator {
  _unused: [u8; 0],
}
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_OK: FLAC__Metadata_ChainStatus = 0;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_ILLEGAL_INPUT:
  FLAC__Metadata_ChainStatus = 1;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_ERROR_OPENING_FILE:
  FLAC__Metadata_ChainStatus = 2;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_NOT_A_FLAC_FILE:
  FLAC__Metadata_ChainStatus = 3;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_NOT_WRITABLE:
  FLAC__Metadata_ChainStatus = 4;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_BAD_METADATA:
  FLAC__Metadata_ChainStatus = 5;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_READ_ERROR:
  FLAC__Metadata_ChainStatus = 6;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_SEEK_ERROR:
  FLAC__Metadata_ChainStatus = 7;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_WRITE_ERROR:
  FLAC__Metadata_ChainStatus = 8;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_RENAME_ERROR:
  FLAC__Metadata_ChainStatus = 9;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_UNLINK_ERROR:
  FLAC__Metadata_ChainStatus = 10;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_MEMORY_ALLOCATION_ERROR:
  FLAC__Metadata_ChainStatus = 11;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_INTERNAL_ERROR:
  FLAC__Metadata_ChainStatus = 12;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_INVALID_CALLBACKS:
  FLAC__Metadata_ChainStatus = 13;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_READ_WRITE_MISMATCH:
  FLAC__Metadata_ChainStatus = 14;
pub const FLAC__Metadata_ChainStatus_FLAC__METADATA_CHAIN_STATUS_WRONG_WRITE_CALL:
  FLAC__Metadata_ChainStatus = 15;
pub type FLAC__Metadata_ChainStatus = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__Metadata_ChainStatus to a C string.\n\n  Using a FLAC__Metadata_ChainStatus as the index to this array\n  will give the string equivalent.  The contents should not be modified."]
  pub static FLAC__Metadata_ChainStatusString: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
  #[doc = " Create a new chain instance.\n\n \\retval FLAC__Metadata_Chain*\n    \\c NULL if there was an error allocating memory, else the new instance."]
  pub fn FLAC__metadata_chain_new() -> *mut FLAC__Metadata_Chain;
}
extern "C" {
  #[doc = " Free a chain instance.  Deletes the object pointed to by \\a chain.\n\n \\param chain  A pointer to an existing chain.\n \\assert\n    \\code chain != NULL \\endcode"]
  pub fn FLAC__metadata_chain_delete(chain: *mut FLAC__Metadata_Chain);
}
extern "C" {
  #[doc = " Get the current status of the chain.  Call this after a function\n  returns \\c false to get the reason for the error.  Also resets the\n  status to FLAC__METADATA_CHAIN_STATUS_OK.\n\n \\param chain    A pointer to an existing chain.\n \\assert\n    \\code chain != NULL \\endcode\n \\retval FLAC__Metadata_ChainStatus\n    The current status of the chain."]
  pub fn FLAC__metadata_chain_status(
    chain: *mut FLAC__Metadata_Chain,
  ) -> FLAC__Metadata_ChainStatus;
}
extern "C" {
  #[doc = " Read all metadata from a FLAC file into the chain.\n\n  On Windows, filename must be a UTF-8 encoded filename, which libFLAC\n  internally translates to an appropriate representation to use with\n  _wfopen. On all other systems, filename is passed to fopen without\n  any translation.\n\n \\param chain    A pointer to an existing chain.\n \\param filename The path to the FLAC file to read.\n \\assert\n    \\code chain != NULL \\endcode\n    \\code filename != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if a valid list of metadata blocks was read from\n    \\a filename, else \\c false.  On failure, check the status with\n    FLAC__metadata_chain_status()."]
  pub fn FLAC__metadata_chain_read(
    chain: *mut FLAC__Metadata_Chain,
    filename: *const ::std::os::raw::c_char,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Read all metadata from an Ogg FLAC file into the chain.\n\n  On Windows, filename must be a UTF-8 encoded filename, which libFLAC\n  internally translates to an appropriate representation to use with\n  _wfopen. On all other systems, filename is passed to fopen without\n  any translation.\n\n \\note Ogg FLAC metadata data writing is not supported yet and\n FLAC__metadata_chain_write() will fail.\n\n \\param chain    A pointer to an existing chain.\n \\param filename The path to the Ogg FLAC file to read.\n \\assert\n    \\code chain != NULL \\endcode\n    \\code filename != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if a valid list of metadata blocks was read from\n    \\a filename, else \\c false.  On failure, check the status with\n    FLAC__metadata_chain_status()."]
  pub fn FLAC__metadata_chain_read_ogg(
    chain: *mut FLAC__Metadata_Chain,
    filename: *const ::std::os::raw::c_char,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Read all metadata from a FLAC stream into the chain via I/O callbacks.\n\n  The \\a handle need only be open for reading, but must be seekable.\n  The equivalent minimum stdio fopen() file mode is \\c \"r\" (or \\c \"rb\"\n  for Windows).\n\n \\param chain    A pointer to an existing chain.\n \\param handle   The I/O handle of the FLAC stream to read.  The\n                 handle will NOT be closed after the metadata is read;\n                 that is the duty of the caller.\n \\param callbacks\n                 A set of callbacks to use for I/O.  The mandatory\n                 callbacks are \\a read, \\a seek, and \\a tell.\n \\assert\n    \\code chain != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if a valid list of metadata blocks was read from\n    \\a handle, else \\c false.  On failure, check the status with\n    FLAC__metadata_chain_status()."]
  pub fn FLAC__metadata_chain_read_with_callbacks(
    chain: *mut FLAC__Metadata_Chain,
    handle: FLAC__IOHandle,
    callbacks: FLAC__IOCallbacks,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Read all metadata from an Ogg FLAC stream into the chain via I/O callbacks.\n\n  The \\a handle need only be open for reading, but must be seekable.\n  The equivalent minimum stdio fopen() file mode is \\c \"r\" (or \\c \"rb\"\n  for Windows).\n\n \\note Ogg FLAC metadata data writing is not supported yet and\n FLAC__metadata_chain_write() will fail.\n\n \\param chain    A pointer to an existing chain.\n \\param handle   The I/O handle of the Ogg FLAC stream to read.  The\n                 handle will NOT be closed after the metadata is read;\n                 that is the duty of the caller.\n \\param callbacks\n                 A set of callbacks to use for I/O.  The mandatory\n                 callbacks are \\a read, \\a seek, and \\a tell.\n \\assert\n    \\code chain != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if a valid list of metadata blocks was read from\n    \\a handle, else \\c false.  On failure, check the status with\n    FLAC__metadata_chain_status()."]
  pub fn FLAC__metadata_chain_read_ogg_with_callbacks(
    chain: *mut FLAC__Metadata_Chain,
    handle: FLAC__IOHandle,
    callbacks: FLAC__IOCallbacks,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Checks if writing the given chain would require the use of a\n  temporary file, or if it could be written in place.\n\n  Under certain conditions, padding can be utilized so that writing\n  edited metadata back to the FLAC file does not require rewriting the\n  entire file.  If rewriting is required, then a temporary workfile is\n  required.  When writing metadata using callbacks, you must check\n  this function to know whether to call\n  FLAC__metadata_chain_write_with_callbacks() or\n  FLAC__metadata_chain_write_with_callbacks_and_tempfile().  When\n  writing with FLAC__metadata_chain_write(), the temporary file is\n  handled internally.\n\n \\param chain    A pointer to an existing chain.\n \\param use_padding\n                 Whether or not padding will be allowed to be used\n                 during the write.  The value of \\a use_padding given\n                 here must match the value later passed to\n                 FLAC__metadata_chain_write_with_callbacks() or\n                 FLAC__metadata_chain_write_with_callbacks_with_tempfile().\n \\assert\n    \\code chain != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if writing the current chain would require a tempfile, or\n    \\c false if metadata can be written in place."]
  pub fn FLAC__metadata_chain_check_if_tempfile_needed(
    chain: *mut FLAC__Metadata_Chain,
    use_padding: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Write all metadata out to the FLAC file.  This function tries to be as\n  efficient as possible; how the metadata is actually written is shown by\n  the following:\n\n  If the current chain is the same size as the existing metadata, the new\n  data is written in place.\n\n  If the current chain is longer than the existing metadata, and\n  \\a use_padding is \\c true, and the last block is a PADDING block of\n  sufficient length, the function will truncate the final padding block\n  so that the overall size of the metadata is the same as the existing\n  metadata, and then just rewrite the metadata.  Otherwise, if not all of\n  the above conditions are met, the entire FLAC file must be rewritten.\n  If you want to use padding this way it is a good idea to call\n  FLAC__metadata_chain_sort_padding() first so that you have the maximum\n  amount of padding to work with, unless you need to preserve ordering\n  of the PADDING blocks for some reason.\n\n  If the current chain is shorter than the existing metadata, and\n  \\a use_padding is \\c true, and the final block is a PADDING block, the padding\n  is extended to make the overall size the same as the existing data.  If\n  \\a use_padding is \\c true and the last block is not a PADDING block, a new\n  PADDING block is added to the end of the new data to make it the same\n  size as the existing data (if possible, see the note to\n  FLAC__metadata_simple_iterator_set_block() about the four byte limit)\n  and the new data is written in place.  If none of the above apply or\n  \\a use_padding is \\c false, the entire FLAC file is rewritten.\n\n  If \\a preserve_file_stats is \\c true, the owner and modification time will\n  be preserved even if the FLAC file is written.\n\n  For this write function to be used, the chain must have been read with\n  FLAC__metadata_chain_read()/FLAC__metadata_chain_read_ogg(), not\n  FLAC__metadata_chain_read_with_callbacks()/FLAC__metadata_chain_read_ogg_with_callbacks().\n\n \\param chain               A pointer to an existing chain.\n \\param use_padding         See above.\n \\param preserve_file_stats See above.\n \\assert\n    \\code chain != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if the write succeeded, else \\c false.  On failure,\n    check the status with FLAC__metadata_chain_status()."]
  pub fn FLAC__metadata_chain_write(
    chain: *mut FLAC__Metadata_Chain,
    use_padding: FLAC__bool,
    preserve_file_stats: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Write all metadata out to a FLAC stream via callbacks.\n\n  (See FLAC__metadata_chain_write() for the details on how padding is\n  used to write metadata in place if possible.)\n\n  The \\a handle must be open for updating and be seekable.  The\n  equivalent minimum stdio fopen() file mode is \\c \"r+\" (or \\c \"r+b\"\n  for Windows).\n\n  For this write function to be used, the chain must have been read with\n  FLAC__metadata_chain_read_with_callbacks()/FLAC__metadata_chain_read_ogg_with_callbacks(),\n  not FLAC__metadata_chain_read()/FLAC__metadata_chain_read_ogg().\n  Also, FLAC__metadata_chain_check_if_tempfile_needed() must have returned\n  \\c false.\n\n \\param chain        A pointer to an existing chain.\n \\param use_padding  See FLAC__metadata_chain_write()\n \\param handle       The I/O handle of the FLAC stream to write.  The\n                     handle will NOT be closed after the metadata is\n                     written; that is the duty of the caller.\n \\param callbacks    A set of callbacks to use for I/O.  The mandatory\n                     callbacks are \\a write and \\a seek.\n \\assert\n    \\code chain != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if the write succeeded, else \\c false.  On failure,\n    check the status with FLAC__metadata_chain_status()."]
  pub fn FLAC__metadata_chain_write_with_callbacks(
    chain: *mut FLAC__Metadata_Chain,
    use_padding: FLAC__bool,
    handle: FLAC__IOHandle,
    callbacks: FLAC__IOCallbacks,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Write all metadata out to a FLAC stream via callbacks.\n\n  (See FLAC__metadata_chain_write() for the details on how padding is\n  used to write metadata in place if possible.)\n\n  This version of the write-with-callbacks function must be used when\n  FLAC__metadata_chain_check_if_tempfile_needed() returns true.  In\n  this function, you must supply an I/O handle corresponding to the\n  FLAC file to edit, and a temporary handle to which the new FLAC\n  file will be written.  It is the caller's job to move this temporary\n  FLAC file on top of the original FLAC file to complete the metadata\n  edit.\n\n  The \\a handle must be open for reading and be seekable.  The\n  equivalent minimum stdio fopen() file mode is \\c \"r\" (or \\c \"rb\"\n  for Windows).\n\n  The \\a temp_handle must be open for writing.  The\n  equivalent minimum stdio fopen() file mode is \\c \"w\" (or \\c \"wb\"\n  for Windows).  It should be an empty stream, or at least positioned\n  at the start-of-file (in which case it is the caller's duty to\n  truncate it on return).\n\n  For this write function to be used, the chain must have been read with\n  FLAC__metadata_chain_read_with_callbacks()/FLAC__metadata_chain_read_ogg_with_callbacks(),\n  not FLAC__metadata_chain_read()/FLAC__metadata_chain_read_ogg().\n  Also, FLAC__metadata_chain_check_if_tempfile_needed() must have returned\n  \\c true.\n\n \\param chain        A pointer to an existing chain.\n \\param use_padding  See FLAC__metadata_chain_write()\n \\param handle       The I/O handle of the original FLAC stream to read.\n                     The handle will NOT be closed after the metadata is\n                     written; that is the duty of the caller.\n \\param callbacks    A set of callbacks to use for I/O on \\a handle.\n                     The mandatory callbacks are \\a read, \\a seek, and\n                     \\a eof.\n \\param temp_handle  The I/O handle of the FLAC stream to write.  The\n                     handle will NOT be closed after the metadata is\n                     written; that is the duty of the caller.\n \\param temp_callbacks\n                     A set of callbacks to use for I/O on temp_handle.\n                     The only mandatory callback is \\a write.\n \\assert\n    \\code chain != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if the write succeeded, else \\c false.  On failure,\n    check the status with FLAC__metadata_chain_status()."]
  pub fn FLAC__metadata_chain_write_with_callbacks_and_tempfile(
    chain: *mut FLAC__Metadata_Chain,
    use_padding: FLAC__bool,
    handle: FLAC__IOHandle,
    callbacks: FLAC__IOCallbacks,
    temp_handle: FLAC__IOHandle,
    temp_callbacks: FLAC__IOCallbacks,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Merge adjacent PADDING blocks into a single block.\n\n \\note This function does not write to the FLAC file, it only\n modifies the chain.\n\n \\warning Any iterator on the current chain will become invalid after this\n call.  You should delete the iterator and get a new one.\n\n \\param chain               A pointer to an existing chain.\n \\assert\n    \\code chain != NULL \\endcode"]
  pub fn FLAC__metadata_chain_merge_padding(chain: *mut FLAC__Metadata_Chain);
}
extern "C" {
  #[doc = " This function will move all PADDING blocks to the end on the metadata,\n  then merge them into a single block.\n\n \\note This function does not write to the FLAC file, it only\n modifies the chain.\n\n \\warning Any iterator on the current chain will become invalid after this\n call.  You should delete the iterator and get a new one.\n\n \\param chain  A pointer to an existing chain.\n \\assert\n    \\code chain != NULL \\endcode"]
  pub fn FLAC__metadata_chain_sort_padding(chain: *mut FLAC__Metadata_Chain);
}
extern "C" {
  #[doc = " Create a new iterator instance.\n\n \\retval FLAC__Metadata_Iterator*\n    \\c NULL if there was an error allocating memory, else the new instance."]
  pub fn FLAC__metadata_iterator_new() -> *mut FLAC__Metadata_Iterator;
}
extern "C" {
  #[doc = " Free an iterator instance.  Deletes the object pointed to by \\a iterator.\n\n \\param iterator  A pointer to an existing iterator.\n \\assert\n    \\code iterator != NULL \\endcode"]
  pub fn FLAC__metadata_iterator_delete(iterator: *mut FLAC__Metadata_Iterator);
}
extern "C" {
  #[doc = " Initialize the iterator to point to the first metadata block in the\n  given chain.\n\n \\param iterator  A pointer to an existing iterator.\n \\param chain     A pointer to an existing and initialized (read) chain.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\code chain != NULL \\endcode"]
  pub fn FLAC__metadata_iterator_init(
    iterator: *mut FLAC__Metadata_Iterator,
    chain: *mut FLAC__Metadata_Chain,
  );
}
extern "C" {
  #[doc = " Moves the iterator forward one metadata block, returning \\c false if\n  already at the end.\n\n \\param iterator  A pointer to an existing initialized iterator.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_iterator_init()\n \\retval FLAC__bool\n    \\c false if already at the last metadata block of the chain, else\n    \\c true."]
  pub fn FLAC__metadata_iterator_next(iterator: *mut FLAC__Metadata_Iterator) -> FLAC__bool;
}
extern "C" {
  #[doc = " Moves the iterator backward one metadata block, returning \\c false if\n  already at the beginning.\n\n \\param iterator  A pointer to an existing initialized iterator.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_iterator_init()\n \\retval FLAC__bool\n    \\c false if already at the first metadata block of the chain, else\n    \\c true."]
  pub fn FLAC__metadata_iterator_prev(iterator: *mut FLAC__Metadata_Iterator) -> FLAC__bool;
}
extern "C" {
  #[doc = " Get the type of the metadata block at the current position.\n\n \\param iterator  A pointer to an existing initialized iterator.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_iterator_init()\n \\retval FLAC__MetadataType\n    The type of the metadata block at the current iterator position."]
  pub fn FLAC__metadata_iterator_get_block_type(
    iterator: *const FLAC__Metadata_Iterator,
  ) -> FLAC__MetadataType;
}
extern "C" {
  #[doc = " Get the metadata block at the current position.  You can modify\n  the block in place but must write the chain before the changes\n  are reflected to the FLAC file.  You do not need to call\n  FLAC__metadata_iterator_set_block() to reflect the changes;\n  the pointer returned by FLAC__metadata_iterator_get_block()\n  points directly into the chain.\n\n \\warning\n Do not call FLAC__metadata_object_delete() on the returned object;\n to delete a block use FLAC__metadata_iterator_delete_block().\n\n \\param iterator  A pointer to an existing initialized iterator.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_iterator_init()\n \\retval FLAC__StreamMetadata*\n    The current metadata block."]
  pub fn FLAC__metadata_iterator_get_block(
    iterator: *mut FLAC__Metadata_Iterator,
  ) -> *mut FLAC__StreamMetadata;
}
extern "C" {
  #[doc = " Set the metadata block at the current position, replacing the existing\n  block.  The new block passed in becomes owned by the chain and it will be\n  deleted when the chain is deleted.\n\n \\param iterator  A pointer to an existing initialized iterator.\n \\param block     A pointer to a metadata block.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_iterator_init()\n    \\code block != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the conditions in the above description are not met, or\n    a memory allocation error occurs, otherwise \\c true."]
  pub fn FLAC__metadata_iterator_set_block(
    iterator: *mut FLAC__Metadata_Iterator,
    block: *mut FLAC__StreamMetadata,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Removes the current block from the chain.  If \\a replace_with_padding is\n  \\c true, the block will instead be replaced with a padding block of equal\n  size.  You can not delete the STREAMINFO block.  The iterator will be\n  left pointing to the block before the one just \"deleted\", even if\n  \\a replace_with_padding is \\c true.\n\n \\param iterator              A pointer to an existing initialized iterator.\n \\param replace_with_padding  See above.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_iterator_init()\n \\retval FLAC__bool\n    \\c false if the conditions in the above description are not met,\n    otherwise \\c true."]
  pub fn FLAC__metadata_iterator_delete_block(
    iterator: *mut FLAC__Metadata_Iterator,
    replace_with_padding: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Insert a new block before the current block.  You cannot insert a block\n  before the first STREAMINFO block.  You cannot insert a STREAMINFO block\n  as there can be only one, the one that already exists at the head when you\n  read in a chain.  The chain takes ownership of the new block and it will be\n  deleted when the chain is deleted.  The iterator will be left pointing to\n  the new block.\n\n \\param iterator  A pointer to an existing initialized iterator.\n \\param block     A pointer to a metadata block to insert.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_iterator_init()\n \\retval FLAC__bool\n    \\c false if the conditions in the above description are not met, or\n    a memory allocation error occurs, otherwise \\c true."]
  pub fn FLAC__metadata_iterator_insert_block_before(
    iterator: *mut FLAC__Metadata_Iterator,
    block: *mut FLAC__StreamMetadata,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Insert a new block after the current block.  You cannot insert a STREAMINFO\n  block as there can be only one, the one that already exists at the head when\n  you read in a chain.  The chain takes ownership of the new block and it will\n  be deleted when the chain is deleted.  The iterator will be left pointing to\n  the new block.\n\n \\param iterator  A pointer to an existing initialized iterator.\n \\param block     A pointer to a metadata block to insert.\n \\assert\n    \\code iterator != NULL \\endcode\n    \\a iterator has been successfully initialized with\n    FLAC__metadata_iterator_init()\n \\retval FLAC__bool\n    \\c false if the conditions in the above description are not met, or\n    a memory allocation error occurs, otherwise \\c true."]
  pub fn FLAC__metadata_iterator_insert_block_after(
    iterator: *mut FLAC__Metadata_Iterator,
    block: *mut FLAC__StreamMetadata,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Create a new metadata object instance of the given type.\n\n  The object will be \"empty\"; i.e. values and data pointers will be \\c 0,\n  with the exception of FLAC__METADATA_TYPE_VORBIS_COMMENT, which will have\n  the vendor string set (but zero comments).\n\n  Do not pass in a value greater than or equal to\n  \\a FLAC__METADATA_TYPE_UNDEFINED unless you really know what you're\n  doing.\n\n \\param type  Type of object to create\n \\retval FLAC__StreamMetadata*\n    \\c NULL if there was an error allocating memory or the type code is\n    greater than FLAC__MAX_METADATA_TYPE_CODE, else the new instance."]
  pub fn FLAC__metadata_object_new(type_: FLAC__MetadataType) -> *mut FLAC__StreamMetadata;
}
extern "C" {
  #[doc = " Create a copy of an existing metadata object.\n\n  The copy is a \"deep\" copy, i.e. dynamically allocated data within the\n  object is also copied.  The caller takes ownership of the new block and\n  is responsible for freeing it with FLAC__metadata_object_delete().\n\n \\param object  Pointer to object to copy.\n \\assert\n    \\code object != NULL \\endcode\n \\retval FLAC__StreamMetadata*\n    \\c NULL if there was an error allocating memory, else the new instance."]
  pub fn FLAC__metadata_object_clone(
    object: *const FLAC__StreamMetadata,
  ) -> *mut FLAC__StreamMetadata;
}
extern "C" {
  #[doc = " Free a metadata object.  Deletes the object pointed to by \\a object.\n\n  The delete is a \"deep\" delete, i.e. dynamically allocated data within the\n  object is also deleted.\n\n \\param object  A pointer to an existing object.\n \\assert\n    \\code object != NULL \\endcode"]
  pub fn FLAC__metadata_object_delete(object: *mut FLAC__StreamMetadata);
}
extern "C" {
  #[doc = " Compares two metadata objects.\n\n  The compare is \"deep\", i.e. dynamically allocated data within the\n  object is also compared.\n\n \\param block1  A pointer to an existing object.\n \\param block2  A pointer to an existing object.\n \\assert\n    \\code block1 != NULL \\endcode\n    \\code block2 != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if objects are identical, else \\c false."]
  pub fn FLAC__metadata_object_is_equal(
    block1: *const FLAC__StreamMetadata,
    block2: *const FLAC__StreamMetadata,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Sets the application data of an APPLICATION block.\n\n  If \\a copy is \\c true, a copy of the data is stored; otherwise, the object\n  takes ownership of the pointer.  The existing data will be freed if this\n  function is successful, otherwise the original data will remain if \\a copy\n  is \\c true and malloc() fails.\n\n \\note It is safe to pass a const pointer to \\a data if \\a copy is \\c true.\n\n \\param object  A pointer to an existing APPLICATION object.\n \\param data    A pointer to the data to set.\n \\param length  The length of \\a data in bytes.\n \\param copy    See above.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_APPLICATION \\endcode\n    \\code (data != NULL && length > 0) ||\n (data == NULL && length == 0 && copy == false) \\endcode\n \\retval FLAC__bool\n    \\c false if \\a copy is \\c true and malloc() fails, else \\c true."]
  pub fn FLAC__metadata_object_application_set_data(
    object: *mut FLAC__StreamMetadata,
    data: *mut FLAC__byte,
    length: u32,
    copy: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Resize the seekpoint array.\n\n  If the size shrinks, elements will truncated; if it grows, new placeholder\n  points will be added to the end. If this function returns false, the\n  object is left untouched.\n\n \\param object          A pointer to an existing SEEKTABLE object.\n \\param new_num_points  The desired length of the array; may be \\c 0.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode\n    \\code (object->data.seek_table.points == NULL && object->data.seek_table.num_points == 0) ||\n (object->data.seek_table.points != NULL && object->data.seek_table.num_points > 0) \\endcode\n \\retval FLAC__bool\n    \\c false if memory allocation error, else \\c true."]
  pub fn FLAC__metadata_object_seektable_resize_points(
    object: *mut FLAC__StreamMetadata,
    new_num_points: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set a seekpoint in a seektable.\n\n \\param object     A pointer to an existing SEEKTABLE object.\n \\param point_num  Index into seekpoint array to set.\n \\param point      The point to set.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode\n    \\code object->data.seek_table.num_points > point_num \\endcode"]
  pub fn FLAC__metadata_object_seektable_set_point(
    object: *mut FLAC__StreamMetadata,
    point_num: u32,
    point: FLAC__StreamMetadata_SeekPoint,
  );
}
extern "C" {
  #[doc = " Insert a seekpoint into a seektable.\n\n \\param object     A pointer to an existing SEEKTABLE object.\n \\param point_num  Index into seekpoint array to set.\n \\param point      The point to set.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode\n    \\code object->data.seek_table.num_points >= point_num \\endcode\n \\retval FLAC__bool\n    \\c false if memory allocation error, else \\c true."]
  pub fn FLAC__metadata_object_seektable_insert_point(
    object: *mut FLAC__StreamMetadata,
    point_num: u32,
    point: FLAC__StreamMetadata_SeekPoint,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Delete a seekpoint from a seektable.\n\n \\param object     A pointer to an existing SEEKTABLE object.\n \\param point_num  Index into seekpoint array to set.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode\n    \\code object->data.seek_table.num_points > point_num \\endcode\n \\retval FLAC__bool\n    \\c false if memory allocation error, else \\c true."]
  pub fn FLAC__metadata_object_seektable_delete_point(
    object: *mut FLAC__StreamMetadata,
    point_num: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Check a seektable to see if it conforms to the FLAC specification.\n  See the format specification for limits on the contents of the\n  seektable.\n\n \\param object  A pointer to an existing SEEKTABLE object.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode\n \\retval FLAC__bool\n    \\c false if seek table is illegal, else \\c true."]
  pub fn FLAC__metadata_object_seektable_is_legal(
    object: *const FLAC__StreamMetadata,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Append a number of placeholder points to the end of a seek table.\n\n \\note\n As with the other ..._seektable_template_... functions, you should\n call FLAC__metadata_object_seektable_template_sort() when finished\n to make the seek table legal.\n\n \\param object  A pointer to an existing SEEKTABLE object.\n \\param num     The number of placeholder points to append.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode\n \\retval FLAC__bool\n    \\c false if memory allocation fails, else \\c true."]
  pub fn FLAC__metadata_object_seektable_template_append_placeholders(
    object: *mut FLAC__StreamMetadata,
    num: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Append a specific seek point template to the end of a seek table.\n\n \\note\n As with the other ..._seektable_template_... functions, you should\n call FLAC__metadata_object_seektable_template_sort() when finished\n to make the seek table legal.\n\n \\param object  A pointer to an existing SEEKTABLE object.\n \\param sample_number  The sample number of the seek point template.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode\n \\retval FLAC__bool\n    \\c false if memory allocation fails, else \\c true."]
  pub fn FLAC__metadata_object_seektable_template_append_point(
    object: *mut FLAC__StreamMetadata,
    sample_number: FLAC__uint64,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Append specific seek point templates to the end of a seek table.\n\n \\note\n As with the other ..._seektable_template_... functions, you should\n call FLAC__metadata_object_seektable_template_sort() when finished\n to make the seek table legal.\n\n \\param object  A pointer to an existing SEEKTABLE object.\n \\param sample_numbers  An array of sample numbers for the seek points.\n \\param num     The number of seek point templates to append.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode\n \\retval FLAC__bool\n    \\c false if memory allocation fails, else \\c true."]
  pub fn FLAC__metadata_object_seektable_template_append_points(
    object: *mut FLAC__StreamMetadata,
    sample_numbers: *mut FLAC__uint64,
    num: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Append a set of evenly-spaced seek point templates to the end of a\n  seek table.\n\n \\note\n As with the other ..._seektable_template_... functions, you should\n call FLAC__metadata_object_seektable_template_sort() when finished\n to make the seek table legal.\n\n \\param object  A pointer to an existing SEEKTABLE object.\n \\param num     The number of placeholder points to append.\n \\param total_samples  The total number of samples to be encoded;\n                       the seekpoints will be spaced approximately\n                       \\a total_samples / \\a num samples apart.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode\n    \\code total_samples > 0 \\endcode\n \\retval FLAC__bool\n    \\c false if memory allocation fails, else \\c true."]
  pub fn FLAC__metadata_object_seektable_template_append_spaced_points(
    object: *mut FLAC__StreamMetadata,
    num: u32,
    total_samples: FLAC__uint64,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Append a set of evenly-spaced seek point templates to the end of a\n  seek table.\n\n \\note\n As with the other ..._seektable_template_... functions, you should\n call FLAC__metadata_object_seektable_template_sort() when finished\n to make the seek table legal.\n\n \\param object  A pointer to an existing SEEKTABLE object.\n \\param samples The number of samples apart to space the placeholder\n                points.  The first point will be at sample \\c 0, the\n                second at sample \\a samples, then 2*\\a samples, and\n                so on.  As long as \\a samples and \\a total_samples\n                are greater than \\c 0, there will always be at least\n                one seekpoint at sample \\c 0.\n \\param total_samples  The total number of samples to be encoded;\n                       the seekpoints will be spaced\n                       \\a samples samples apart.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode\n    \\code samples > 0 \\endcode\n    \\code total_samples > 0 \\endcode\n \\retval FLAC__bool\n    \\c false if memory allocation fails, else \\c true."]
  pub fn FLAC__metadata_object_seektable_template_append_spaced_points_by_samples(
    object: *mut FLAC__StreamMetadata,
    samples: u32,
    total_samples: FLAC__uint64,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Sort a seek table's seek points according to the format specification,\n  removing duplicates.\n\n \\param object   A pointer to a seek table to be sorted.\n \\param compact  If \\c false, behaves like FLAC__format_seektable_sort().\n                 If \\c true, duplicates are deleted and the seek table is\n                 shrunk appropriately; the number of placeholder points\n                 present in the seek table will be the same after the call\n                 as before.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_SEEKTABLE \\endcode\n \\retval FLAC__bool\n    \\c false if realloc() fails, else \\c true."]
  pub fn FLAC__metadata_object_seektable_template_sort(
    object: *mut FLAC__StreamMetadata,
    compact: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Sets the vendor string in a VORBIS_COMMENT block.\n\n  For convenience, a trailing NUL is added to the entry if it doesn't have\n  one already.\n\n  If \\a copy is \\c true, a copy of the entry is stored; otherwise, the object\n  takes ownership of the \\c entry.entry pointer.\n\n  \\note If this function returns \\c false, the caller still owns the\n  pointer.\n\n \\param object  A pointer to an existing VORBIS_COMMENT object.\n \\param entry   The entry to set the vendor string to.\n \\param copy    See above.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode\n    \\code (entry.entry != NULL && entry.length > 0) ||\n (entry.entry == NULL && entry.length == 0) \\endcode\n \\retval FLAC__bool\n    \\c false if memory allocation fails or \\a entry does not comply with the\n    Vorbis comment specification, else \\c true."]
  pub fn FLAC__metadata_object_vorbiscomment_set_vendor_string(
    object: *mut FLAC__StreamMetadata,
    entry: FLAC__StreamMetadata_VorbisComment_Entry,
    copy: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Resize the comment array.\n\n  If the size shrinks, elements will truncated; if it grows, new empty\n  fields will be added to the end.  If this function returns false, the\n  object is left untouched.\n\n \\param object            A pointer to an existing VORBIS_COMMENT object.\n \\param new_num_comments  The desired length of the array; may be \\c 0.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode\n    \\code (object->data.vorbis_comment.comments == NULL && object->data.vorbis_comment.num_comments == 0) ||\n (object->data.vorbis_comment.comments != NULL && object->data.vorbis_comment.num_comments > 0) \\endcode\n \\retval FLAC__bool\n    \\c false if memory allocation fails, else \\c true."]
  pub fn FLAC__metadata_object_vorbiscomment_resize_comments(
    object: *mut FLAC__StreamMetadata,
    new_num_comments: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Sets a comment in a VORBIS_COMMENT block.\n\n  For convenience, a trailing NUL is added to the entry if it doesn't have\n  one already.\n\n  If \\a copy is \\c true, a copy of the entry is stored; otherwise, the object\n  takes ownership of the \\c entry.entry pointer.\n\n  \\note If this function returns \\c false, the caller still owns the\n  pointer.\n\n \\param object       A pointer to an existing VORBIS_COMMENT object.\n \\param comment_num  Index into comment array to set.\n \\param entry        The entry to set the comment to.\n \\param copy         See above.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode\n    \\code comment_num < object->data.vorbis_comment.num_comments \\endcode\n    \\code (entry.entry != NULL && entry.length > 0) ||\n (entry.entry == NULL && entry.length == 0) \\endcode\n \\retval FLAC__bool\n    \\c false if memory allocation fails or \\a entry does not comply with the\n    Vorbis comment specification, else \\c true."]
  pub fn FLAC__metadata_object_vorbiscomment_set_comment(
    object: *mut FLAC__StreamMetadata,
    comment_num: u32,
    entry: FLAC__StreamMetadata_VorbisComment_Entry,
    copy: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Insert a comment in a VORBIS_COMMENT block at the given index.\n\n  For convenience, a trailing NUL is added to the entry if it doesn't have\n  one already.\n\n  If \\a copy is \\c true, a copy of the entry is stored; otherwise, the object\n  takes ownership of the \\c entry.entry pointer.\n\n  \\note If this function returns \\c false, the caller still owns the\n  pointer.\n\n \\param object       A pointer to an existing VORBIS_COMMENT object.\n \\param comment_num  The index at which to insert the comment.  The comments\n                     at and after \\a comment_num move right one position.\n                     To append a comment to the end, set \\a comment_num to\n                     \\c object->data.vorbis_comment.num_comments .\n \\param entry        The comment to insert.\n \\param copy         See above.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode\n    \\code object->data.vorbis_comment.num_comments >= comment_num \\endcode\n    \\code (entry.entry != NULL && entry.length > 0) ||\n (entry.entry == NULL && entry.length == 0 && copy == false) \\endcode\n \\retval FLAC__bool\n    \\c false if memory allocation fails or \\a entry does not comply with the\n    Vorbis comment specification, else \\c true."]
  pub fn FLAC__metadata_object_vorbiscomment_insert_comment(
    object: *mut FLAC__StreamMetadata,
    comment_num: u32,
    entry: FLAC__StreamMetadata_VorbisComment_Entry,
    copy: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Appends a comment to a VORBIS_COMMENT block.\n\n  For convenience, a trailing NUL is added to the entry if it doesn't have\n  one already.\n\n  If \\a copy is \\c true, a copy of the entry is stored; otherwise, the object\n  takes ownership of the \\c entry.entry pointer.\n\n  \\note If this function returns \\c false, the caller still owns the\n  pointer.\n\n \\param object       A pointer to an existing VORBIS_COMMENT object.\n \\param entry        The comment to insert.\n \\param copy         See above.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode\n    \\code (entry.entry != NULL && entry.length > 0) ||\n (entry.entry == NULL && entry.length == 0 && copy == false) \\endcode\n \\retval FLAC__bool\n    \\c false if memory allocation fails or \\a entry does not comply with the\n    Vorbis comment specification, else \\c true."]
  pub fn FLAC__metadata_object_vorbiscomment_append_comment(
    object: *mut FLAC__StreamMetadata,
    entry: FLAC__StreamMetadata_VorbisComment_Entry,
    copy: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Replaces comments in a VORBIS_COMMENT block with a new one.\n\n  For convenience, a trailing NUL is added to the entry if it doesn't have\n  one already.\n\n  Depending on the value of \\a all, either all or just the first comment\n  whose field name(s) match the given entry's name will be replaced by the\n  given entry.  If no comments match, \\a entry will simply be appended.\n\n  If \\a copy is \\c true, a copy of the entry is stored; otherwise, the object\n  takes ownership of the \\c entry.entry pointer.\n\n  \\note If this function returns \\c false, the caller still owns the\n  pointer.\n\n \\param object       A pointer to an existing VORBIS_COMMENT object.\n \\param entry        The comment to insert.\n \\param all          If \\c true, all comments whose field name matches\n                     \\a entry's field name will be removed, and \\a entry will\n                     be inserted at the position of the first matching\n                     comment.  If \\c false, only the first comment whose\n                     field name matches \\a entry's field name will be\n                     replaced with \\a entry.\n \\param copy         See above.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode\n    \\code (entry.entry != NULL && entry.length > 0) ||\n (entry.entry == NULL && entry.length == 0 && copy == false) \\endcode\n \\retval FLAC__bool\n    \\c false if memory allocation fails or \\a entry does not comply with the\n    Vorbis comment specification, else \\c true."]
  pub fn FLAC__metadata_object_vorbiscomment_replace_comment(
    object: *mut FLAC__StreamMetadata,
    entry: FLAC__StreamMetadata_VorbisComment_Entry,
    all: FLAC__bool,
    copy: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Delete a comment in a VORBIS_COMMENT block at the given index.\n\n \\param object       A pointer to an existing VORBIS_COMMENT object.\n \\param comment_num  The index of the comment to delete.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode\n    \\code object->data.vorbis_comment.num_comments > comment_num \\endcode\n \\retval FLAC__bool\n    \\c false if realloc() fails, else \\c true."]
  pub fn FLAC__metadata_object_vorbiscomment_delete_comment(
    object: *mut FLAC__StreamMetadata,
    comment_num: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Creates a Vorbis comment entry from NUL-terminated name and value strings.\n\n  On return, the filled-in \\a entry->entry pointer will point to malloc()ed\n  memory and shall be owned by the caller.  For convenience the entry will\n  have a terminating NUL.\n\n \\param entry              A pointer to a Vorbis comment entry.  The entry's\n                           \\c entry pointer should not point to allocated\n                           memory as it will be overwritten.\n \\param field_name         The field name in ASCII, \\c NUL terminated.\n \\param field_value        The field value in UTF-8, \\c NUL terminated.\n \\assert\n    \\code entry != NULL \\endcode\n    \\code field_name != NULL \\endcode\n    \\code field_value != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if malloc() fails, or if \\a field_name or \\a field_value does\n    not comply with the Vorbis comment specification, else \\c true."]
  pub fn FLAC__metadata_object_vorbiscomment_entry_from_name_value_pair(
    entry: *mut FLAC__StreamMetadata_VorbisComment_Entry,
    field_name: *const ::std::os::raw::c_char,
    field_value: *const ::std::os::raw::c_char,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Splits a Vorbis comment entry into NUL-terminated name and value strings.\n\n  The returned pointers to name and value will be allocated by malloc()\n  and shall be owned by the caller.\n\n \\param entry              An existing Vorbis comment entry.\n \\param field_name         The address of where the returned pointer to the\n                           field name will be stored.\n \\param field_value        The address of where the returned pointer to the\n                           field value will be stored.\n \\assert\n    \\code (entry.entry != NULL && entry.length > 0) \\endcode\n    \\code memchr(entry.entry, '=', entry.length) != NULL \\endcode\n    \\code field_name != NULL \\endcode\n    \\code field_value != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if memory allocation fails or \\a entry does not comply with the\n    Vorbis comment specification, else \\c true."]
  pub fn FLAC__metadata_object_vorbiscomment_entry_to_name_value_pair(
    entry: FLAC__StreamMetadata_VorbisComment_Entry,
    field_name: *mut *mut ::std::os::raw::c_char,
    field_value: *mut *mut ::std::os::raw::c_char,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Check if the given Vorbis comment entry's field name matches the given\n  field name.\n\n \\param entry              An existing Vorbis comment entry.\n \\param field_name         The field name to check.\n \\param field_name_length  The length of \\a field_name, not including the\n                           terminating \\c NUL.\n \\assert\n    \\code (entry.entry != NULL && entry.length > 0) \\endcode\n \\retval FLAC__bool\n    \\c true if the field names match, else \\c false"]
  pub fn FLAC__metadata_object_vorbiscomment_entry_matches(
    entry: FLAC__StreamMetadata_VorbisComment_Entry,
    field_name: *const ::std::os::raw::c_char,
    field_name_length: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Find a Vorbis comment with the given field name.\n\n  The search begins at entry number \\a offset; use an offset of 0 to\n  search from the beginning of the comment array.\n\n \\param object      A pointer to an existing VORBIS_COMMENT object.\n \\param offset      The offset into the comment array from where to start\n                    the search.\n \\param field_name  The field name of the comment to find.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode\n    \\code field_name != NULL \\endcode\n \\retval int\n    The offset in the comment array of the first comment whose field\n    name matches \\a field_name, or \\c -1 if no match was found."]
  pub fn FLAC__metadata_object_vorbiscomment_find_entry_from(
    object: *const FLAC__StreamMetadata,
    offset: u32,
    field_name: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Remove first Vorbis comment matching the given field name.\n\n \\param object      A pointer to an existing VORBIS_COMMENT object.\n \\param field_name  The field name of comment to delete.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode\n \\retval int\n    \\c -1 for memory allocation error, \\c 0 for no matching entries,\n    \\c 1 for one matching entry deleted."]
  pub fn FLAC__metadata_object_vorbiscomment_remove_entry_matching(
    object: *mut FLAC__StreamMetadata,
    field_name: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Remove all Vorbis comments matching the given field name.\n\n \\param object      A pointer to an existing VORBIS_COMMENT object.\n \\param field_name  The field name of comments to delete.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \\endcode\n \\retval int\n    \\c -1 for memory allocation error, \\c 0 for no matching entries,\n    else the number of matching entries deleted."]
  pub fn FLAC__metadata_object_vorbiscomment_remove_entries_matching(
    object: *mut FLAC__StreamMetadata,
    field_name: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Create a new CUESHEET track instance.\n\n  The object will be \"empty\"; i.e. values and data pointers will be \\c 0.\n\n \\retval FLAC__StreamMetadata_CueSheet_Track*\n    \\c NULL if there was an error allocating memory, else the new instance."]
  pub fn FLAC__metadata_object_cuesheet_track_new() -> *mut FLAC__StreamMetadata_CueSheet_Track;
}
extern "C" {
  #[doc = " Create a copy of an existing CUESHEET track object.\n\n  The copy is a \"deep\" copy, i.e. dynamically allocated data within the\n  object is also copied.  The caller takes ownership of the new object and\n  is responsible for freeing it with\n  FLAC__metadata_object_cuesheet_track_delete().\n\n \\param object  Pointer to object to copy.\n \\assert\n    \\code object != NULL \\endcode\n \\retval FLAC__StreamMetadata_CueSheet_Track*\n    \\c NULL if there was an error allocating memory, else the new instance."]
  pub fn FLAC__metadata_object_cuesheet_track_clone(
    object: *const FLAC__StreamMetadata_CueSheet_Track,
  ) -> *mut FLAC__StreamMetadata_CueSheet_Track;
}
extern "C" {
  #[doc = " Delete a CUESHEET track object\n\n \\param object       A pointer to an existing CUESHEET track object.\n \\assert\n    \\code object != NULL \\endcode"]
  pub fn FLAC__metadata_object_cuesheet_track_delete(
    object: *mut FLAC__StreamMetadata_CueSheet_Track,
  );
}
extern "C" {
  #[doc = " Resize a track's index point array.\n\n  If the size shrinks, elements will truncated; if it grows, new blank\n  indices will be added to the end. If this function returns false, the\n  track object is left untouched.\n\n \\param object           A pointer to an existing CUESHEET object.\n \\param track_num        The index of the track to modify.  NOTE: this is not\n                         necessarily the same as the track's \\a number field.\n \\param new_num_indices  The desired length of the array; may be \\c 0.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode\n    \\code object->data.cue_sheet.num_tracks > track_num \\endcode\n    \\code (object->data.cue_sheet.tracks[track_num].indices == NULL && object->data.cue_sheet.tracks[track_num].num_indices == 0) ||\n (object->data.cue_sheet.tracks[track_num].indices != NULL && object->data.cue_sheet.tracks[track_num].num_indices > 0) \\endcode\n \\retval FLAC__bool\n    \\c false if memory allocation error, else \\c true."]
  pub fn FLAC__metadata_object_cuesheet_track_resize_indices(
    object: *mut FLAC__StreamMetadata,
    track_num: u32,
    new_num_indices: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Insert an index point in a CUESHEET track at the given index.\n\n \\param object       A pointer to an existing CUESHEET object.\n \\param track_num    The index of the track to modify.  NOTE: this is not\n                     necessarily the same as the track's \\a number field.\n \\param index_num    The index into the track's index array at which to\n                     insert the index point.  NOTE: this is not necessarily\n                     the same as the index point's \\a number field.  The\n                     indices at and after \\a index_num move right one\n                     position.  To append an index point to the end, set\n                     \\a index_num to\n                     \\c object->data.cue_sheet.tracks[track_num].num_indices .\n \\param index        The index point to insert.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode\n    \\code object->data.cue_sheet.num_tracks > track_num \\endcode\n    \\code object->data.cue_sheet.tracks[track_num].num_indices >= index_num \\endcode\n \\retval FLAC__bool\n    \\c false if realloc() fails, else \\c true."]
  pub fn FLAC__metadata_object_cuesheet_track_insert_index(
    object: *mut FLAC__StreamMetadata,
    track_num: u32,
    index_num: u32,
    index: FLAC__StreamMetadata_CueSheet_Index,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Insert a blank index point in a CUESHEET track at the given index.\n\n  A blank index point is one in which all field values are zero.\n\n \\param object       A pointer to an existing CUESHEET object.\n \\param track_num    The index of the track to modify.  NOTE: this is not\n                     necessarily the same as the track's \\a number field.\n \\param index_num    The index into the track's index array at which to\n                     insert the index point.  NOTE: this is not necessarily\n                     the same as the index point's \\a number field.  The\n                     indices at and after \\a index_num move right one\n                     position.  To append an index point to the end, set\n                     \\a index_num to\n                     \\c object->data.cue_sheet.tracks[track_num].num_indices .\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode\n    \\code object->data.cue_sheet.num_tracks > track_num \\endcode\n    \\code object->data.cue_sheet.tracks[track_num].num_indices >= index_num \\endcode\n \\retval FLAC__bool\n    \\c false if realloc() fails, else \\c true."]
  pub fn FLAC__metadata_object_cuesheet_track_insert_blank_index(
    object: *mut FLAC__StreamMetadata,
    track_num: u32,
    index_num: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Delete an index point in a CUESHEET track at the given index.\n\n \\param object       A pointer to an existing CUESHEET object.\n \\param track_num    The index into the track array of the track to\n                     modify.  NOTE: this is not necessarily the same\n                     as the track's \\a number field.\n \\param index_num    The index into the track's index array of the index\n                     to delete.  NOTE: this is not necessarily the same\n                     as the index's \\a number field.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode\n    \\code object->data.cue_sheet.num_tracks > track_num \\endcode\n    \\code object->data.cue_sheet.tracks[track_num].num_indices > index_num \\endcode\n \\retval FLAC__bool\n    \\c false if realloc() fails, else \\c true."]
  pub fn FLAC__metadata_object_cuesheet_track_delete_index(
    object: *mut FLAC__StreamMetadata,
    track_num: u32,
    index_num: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Resize the track array.\n\n  If the size shrinks, elements will truncated; if it grows, new blank\n  tracks will be added to the end.  If this function returns false, the\n  object is left untouched.\n\n \\param object            A pointer to an existing CUESHEET object.\n \\param new_num_tracks    The desired length of the array; may be \\c 0.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode\n    \\code (object->data.cue_sheet.tracks == NULL && object->data.cue_sheet.num_tracks == 0) ||\n (object->data.cue_sheet.tracks != NULL && object->data.cue_sheet.num_tracks > 0) \\endcode\n \\retval FLAC__bool\n    \\c false if memory allocation error, else \\c true."]
  pub fn FLAC__metadata_object_cuesheet_resize_tracks(
    object: *mut FLAC__StreamMetadata,
    new_num_tracks: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Sets a track in a CUESHEET block.\n\n  If \\a copy is \\c true, a copy of the track is stored; otherwise, the object\n  takes ownership of the \\a track pointer.\n\n \\param object       A pointer to an existing CUESHEET object.\n \\param track_num    Index into track array to set.  NOTE: this is not\n                     necessarily the same as the track's \\a number field.\n \\param track        The track to set the track to.  You may safely pass in\n                     a const pointer if \\a copy is \\c true.\n \\param copy         See above.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode\n    \\code track_num < object->data.cue_sheet.num_tracks \\endcode\n    \\code (track->indices != NULL && track->num_indices > 0) ||\n (track->indices == NULL && track->num_indices == 0) \\endcode\n \\retval FLAC__bool\n    \\c false if \\a copy is \\c true and malloc() fails, else \\c true."]
  pub fn FLAC__metadata_object_cuesheet_set_track(
    object: *mut FLAC__StreamMetadata,
    track_num: u32,
    track: *mut FLAC__StreamMetadata_CueSheet_Track,
    copy: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Insert a track in a CUESHEET block at the given index.\n\n  If \\a copy is \\c true, a copy of the track is stored; otherwise, the object\n  takes ownership of the \\a track pointer.\n\n \\param object       A pointer to an existing CUESHEET object.\n \\param track_num    The index at which to insert the track.  NOTE: this\n                     is not necessarily the same as the track's \\a number\n                     field.  The tracks at and after \\a track_num move right\n                     one position.  To append a track to the end, set\n                     \\a track_num to \\c object->data.cue_sheet.num_tracks .\n \\param track        The track to insert.  You may safely pass in a const\n                     pointer if \\a copy is \\c true.\n \\param copy         See above.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode\n    \\code object->data.cue_sheet.num_tracks >= track_num \\endcode\n \\retval FLAC__bool\n    \\c false if \\a copy is \\c true and malloc() fails, else \\c true."]
  pub fn FLAC__metadata_object_cuesheet_insert_track(
    object: *mut FLAC__StreamMetadata,
    track_num: u32,
    track: *mut FLAC__StreamMetadata_CueSheet_Track,
    copy: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Insert a blank track in a CUESHEET block at the given index.\n\n  A blank track is one in which all field values are zero.\n\n \\param object       A pointer to an existing CUESHEET object.\n \\param track_num    The index at which to insert the track.  NOTE: this\n                     is not necessarily the same as the track's \\a number\n                     field.  The tracks at and after \\a track_num move right\n                     one position.  To append a track to the end, set\n                     \\a track_num to \\c object->data.cue_sheet.num_tracks .\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode\n    \\code object->data.cue_sheet.num_tracks >= track_num \\endcode\n \\retval FLAC__bool\n    \\c false if \\a copy is \\c true and malloc() fails, else \\c true."]
  pub fn FLAC__metadata_object_cuesheet_insert_blank_track(
    object: *mut FLAC__StreamMetadata,
    track_num: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Delete a track in a CUESHEET block at the given index.\n\n \\param object       A pointer to an existing CUESHEET object.\n \\param track_num    The index into the track array of the track to\n                     delete.  NOTE: this is not necessarily the same\n                     as the track's \\a number field.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode\n    \\code object->data.cue_sheet.num_tracks > track_num \\endcode\n \\retval FLAC__bool\n    \\c false if realloc() fails, else \\c true."]
  pub fn FLAC__metadata_object_cuesheet_delete_track(
    object: *mut FLAC__StreamMetadata,
    track_num: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Check a cue sheet to see if it conforms to the FLAC specification.\n  See the format specification for limits on the contents of the\n  cue sheet.\n\n \\param object     A pointer to an existing CUESHEET object.\n \\param check_cd_da_subset  If \\c true, check CUESHEET against more\n                   stringent requirements for a CD-DA (audio) disc.\n \\param violation  Address of a pointer to a string.  If there is a\n                   violation, a pointer to a string explanation of the\n                   violation will be returned here. \\a violation may be\n                   \\c NULL if you don't need the returned string.  Do not\n                   free the returned string; it will always point to static\n                   data.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode\n \\retval FLAC__bool\n    \\c false if cue sheet is illegal, else \\c true."]
  pub fn FLAC__metadata_object_cuesheet_is_legal(
    object: *const FLAC__StreamMetadata,
    check_cd_da_subset: FLAC__bool,
    violation: *mut *const ::std::os::raw::c_char,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Calculate and return the CDDB/freedb ID for a cue sheet.  The function\n  assumes the cue sheet corresponds to a CD; the result is undefined\n  if the cuesheet's is_cd bit is not set.\n\n \\param object     A pointer to an existing CUESHEET object.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_CUESHEET \\endcode\n \\retval FLAC__uint32\n    The unsigned integer representation of the CDDB/freedb ID"]
  pub fn FLAC__metadata_object_cuesheet_calculate_cddb_id(
    object: *const FLAC__StreamMetadata,
  ) -> FLAC__uint32;
}
extern "C" {
  #[doc = " Sets the MIME type of a PICTURE block.\n\n  If \\a copy is \\c true, a copy of the string is stored; otherwise, the object\n  takes ownership of the pointer.  The existing string will be freed if this\n  function is successful, otherwise the original string will remain if \\a copy\n  is \\c true and malloc() fails.\n\n \\note It is safe to pass a const pointer to \\a mime_type if \\a copy is \\c true.\n\n \\param object      A pointer to an existing PICTURE object.\n \\param mime_type   A pointer to the MIME type string.  The string must be\n                    ASCII characters 0x20-0x7e, NUL-terminated.  No validation\n                    is done.\n \\param copy        See above.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_PICTURE \\endcode\n    \\code (mime_type != NULL) \\endcode\n \\retval FLAC__bool\n    \\c false if \\a copy is \\c true and malloc() fails, else \\c true."]
  pub fn FLAC__metadata_object_picture_set_mime_type(
    object: *mut FLAC__StreamMetadata,
    mime_type: *mut ::std::os::raw::c_char,
    copy: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Sets the description of a PICTURE block.\n\n  If \\a copy is \\c true, a copy of the string is stored; otherwise, the object\n  takes ownership of the pointer.  The existing string will be freed if this\n  function is successful, otherwise the original string will remain if \\a copy\n  is \\c true and malloc() fails.\n\n \\note It is safe to pass a const pointer to \\a description if \\a copy is \\c true.\n\n \\param object      A pointer to an existing PICTURE object.\n \\param description A pointer to the description string.  The string must be\n                    valid UTF-8, NUL-terminated.  No validation is done.\n \\param copy        See above.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_PICTURE \\endcode\n    \\code (description != NULL) \\endcode\n \\retval FLAC__bool\n    \\c false if \\a copy is \\c true and malloc() fails, else \\c true."]
  pub fn FLAC__metadata_object_picture_set_description(
    object: *mut FLAC__StreamMetadata,
    description: *mut FLAC__byte,
    copy: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Sets the picture data of a PICTURE block.\n\n  If \\a copy is \\c true, a copy of the data is stored; otherwise, the object\n  takes ownership of the pointer.  Also sets the \\a data_length field of the\n  metadata object to what is passed in as the \\a length parameter.  The\n  existing data will be freed if this function is successful, otherwise the\n  original data and data_length will remain if \\a copy is \\c true and\n  malloc() fails.\n\n \\note It is safe to pass a const pointer to \\a data if \\a copy is \\c true.\n\n \\param object  A pointer to an existing PICTURE object.\n \\param data    A pointer to the data to set.\n \\param length  The length of \\a data in bytes.\n \\param copy    See above.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_PICTURE \\endcode\n    \\code (data != NULL && length > 0) ||\n (data == NULL && length == 0 && copy == false) \\endcode\n \\retval FLAC__bool\n    \\c false if \\a copy is \\c true and malloc() fails, else \\c true."]
  pub fn FLAC__metadata_object_picture_set_data(
    object: *mut FLAC__StreamMetadata,
    data: *mut FLAC__byte,
    length: FLAC__uint32,
    copy: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Check a PICTURE block to see if it conforms to the FLAC specification.\n  See the format specification for limits on the contents of the\n  PICTURE block.\n\n \\param object     A pointer to existing PICTURE block to be checked.\n \\param violation  Address of a pointer to a string.  If there is a\n                   violation, a pointer to a string explanation of the\n                   violation will be returned here. \\a violation may be\n                   \\c NULL if you don't need the returned string.  Do not\n                   free the returned string; it will always point to static\n                   data.\n \\assert\n    \\code object != NULL \\endcode\n    \\code object->type == FLAC__METADATA_TYPE_PICTURE \\endcode\n \\retval FLAC__bool\n    \\c false if PICTURE block is illegal, else \\c true."]
  pub fn FLAC__metadata_object_picture_is_legal(
    object: *const FLAC__StreamMetadata,
    violation: *mut *const ::std::os::raw::c_char,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Get the raw (binary) representation of a FLAC__StreamMetadata objeect.\n  After use, free() the returned buffer. The length of the buffer is\n  the length of the input metadata object plus 4 bytes for the header.\n\n \\param object     A pointer to metadata block to be converted.\n \\assert\n    \\code object != NULL \\endcode\n \\retval FLAC__byte*\n    \\c  NULL if there was an error, else a pointer to a buffer holding\n        the requested data."]
  pub fn FLAC__metadata_object_get_raw(object: *const FLAC__StreamMetadata) -> *mut FLAC__byte;
}
extern "C" {
  #[doc = " Turn a raw (binary) representation into a FLAC__StreamMetadata objeect.\n  The returned object must be deleted with FLAC__metadata_object_delete()\n  after use.\n\n \\param buffer     A pointer to a buffer containing a binary representation\n                   to be converted to a FLAC__StreamMetadata object\n \\param length     The length of the supplied buffer\n \\retval FLAC__StreamMetadata*\n    \\c  NULL if there was an error, else a pointer to a FLAC__StreamMetadata\n        holding the requested data."]
  pub fn FLAC__metadata_object_set_raw(
    buffer: *mut FLAC__byte,
    length: FLAC__uint32,
  ) -> *mut FLAC__StreamMetadata;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
  pub _Placeholder: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__iobuf() {
  const UNINIT: ::std::mem::MaybeUninit<_iobuf> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<_iobuf>(),
    8usize,
    concat!("Size of: ", stringify!(_iobuf))
  );
  assert_eq!(
    ::std::mem::align_of::<_iobuf>(),
    8usize,
    concat!("Alignment of ", stringify!(_iobuf))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr)._Placeholder) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_iobuf),
      "::",
      stringify!(_Placeholder)
    )
  );
}
pub type FILE = _iobuf;
extern "C" {
  pub fn __acrt_iob_func(_Ix: ::std::os::raw::c_uint) -> *mut FILE;
}
extern "C" {
  pub fn fgetwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
  pub fn _fgetwchar() -> wint_t;
}
extern "C" {
  pub fn fputwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
  pub fn _fputwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
  pub fn getwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
  pub fn getwchar() -> wint_t;
}
extern "C" {
  pub fn fgetws(
    _Buffer: *mut wchar_t,
    _BufferCount: ::std::os::raw::c_int,
    _Stream: *mut FILE,
  ) -> *mut wchar_t;
}
extern "C" {
  pub fn fputws(_Buffer: *const wchar_t, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _getws_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> *mut wchar_t;
}
extern "C" {
  pub fn putwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
  pub fn putwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
  pub fn _putws(_Buffer: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ungetwc(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
  pub fn _wfdopen(_FileHandle: ::std::os::raw::c_int, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
  pub fn _wfopen(_FileName: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
  pub fn _wfopen_s(
    _Stream: *mut *mut FILE,
    _FileName: *const wchar_t,
    _Mode: *const wchar_t,
  ) -> errno_t;
}
extern "C" {
  pub fn _wfreopen(
    _FileName: *const wchar_t,
    _Mode: *const wchar_t,
    _OldStream: *mut FILE,
  ) -> *mut FILE;
}
extern "C" {
  pub fn _wfreopen_s(
    _Stream: *mut *mut FILE,
    _FileName: *const wchar_t,
    _Mode: *const wchar_t,
    _OldStream: *mut FILE,
  ) -> errno_t;
}
extern "C" {
  pub fn _wfsopen(
    _FileName: *const wchar_t,
    _Mode: *const wchar_t,
    _ShFlag: ::std::os::raw::c_int,
  ) -> *mut FILE;
}
extern "C" {
  pub fn _wpopen(_Command: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
  pub fn _wremove(_FileName: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _wtempnam(_Directory: *const wchar_t, _FilePrefix: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn _wtmpnam_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> errno_t;
}
extern "C" {
  pub fn _wtmpnam(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
  pub fn _fgetwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
  pub fn _fputwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
  pub fn _getwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
  pub fn _putwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
  pub fn _ungetwc_nolock(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
  pub fn __stdio_common_vfwprintf(
    _Options: ::std::os::raw::c_ulonglong,
    _Stream: *mut FILE,
    _Format: *const wchar_t,
    _Locale: _locale_t,
    _ArgList: va_list,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __stdio_common_vfwprintf_s(
    _Options: ::std::os::raw::c_ulonglong,
    _Stream: *mut FILE,
    _Format: *const wchar_t,
    _Locale: _locale_t,
    _ArgList: va_list,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __stdio_common_vfwprintf_p(
    _Options: ::std::os::raw::c_ulonglong,
    _Stream: *mut FILE,
    _Format: *const wchar_t,
    _Locale: _locale_t,
    _ArgList: va_list,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __stdio_common_vfwscanf(
    _Options: ::std::os::raw::c_ulonglong,
    _Stream: *mut FILE,
    _Format: *const wchar_t,
    _Locale: _locale_t,
    _ArgList: va_list,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __stdio_common_vswprintf(
    _Options: ::std::os::raw::c_ulonglong,
    _Buffer: *mut wchar_t,
    _BufferCount: usize,
    _Format: *const wchar_t,
    _Locale: _locale_t,
    _ArgList: va_list,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __stdio_common_vswprintf_s(
    _Options: ::std::os::raw::c_ulonglong,
    _Buffer: *mut wchar_t,
    _BufferCount: usize,
    _Format: *const wchar_t,
    _Locale: _locale_t,
    _ArgList: va_list,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __stdio_common_vsnwprintf_s(
    _Options: ::std::os::raw::c_ulonglong,
    _Buffer: *mut wchar_t,
    _BufferCount: usize,
    _MaxCount: usize,
    _Format: *const wchar_t,
    _Locale: _locale_t,
    _ArgList: va_list,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __stdio_common_vswprintf_p(
    _Options: ::std::os::raw::c_ulonglong,
    _Buffer: *mut wchar_t,
    _BufferCount: usize,
    _Format: *const wchar_t,
    _Locale: _locale_t,
    _ArgList: va_list,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __stdio_common_vswscanf(
    _Options: ::std::os::raw::c_ulonglong,
    _Buffer: *const wchar_t,
    _BufferCount: usize,
    _Format: *const wchar_t,
    _Locale: _locale_t,
    _ArgList: va_list,
  ) -> ::std::os::raw::c_int;
}
pub type fpos_t = ::std::os::raw::c_longlong;
extern "C" {
  pub fn _get_stream_buffer_pointers(
    _Stream: *mut FILE,
    _Base: *mut *mut *mut ::std::os::raw::c_char,
    _Pointer: *mut *mut *mut ::std::os::raw::c_char,
    _Count: *mut *mut ::std::os::raw::c_int,
  ) -> errno_t;
}
extern "C" {
  pub fn clearerr_s(_Stream: *mut FILE) -> errno_t;
}
extern "C" {
  pub fn fopen_s(
    _Stream: *mut *mut FILE,
    _FileName: *const ::std::os::raw::c_char,
    _Mode: *const ::std::os::raw::c_char,
  ) -> errno_t;
}
extern "C" {
  pub fn fread_s(
    _Buffer: *mut ::std::os::raw::c_void,
    _BufferSize: usize,
    _ElementSize: usize,
    _ElementCount: usize,
    _Stream: *mut FILE,
  ) -> usize;
}
extern "C" {
  pub fn freopen_s(
    _Stream: *mut *mut FILE,
    _FileName: *const ::std::os::raw::c_char,
    _Mode: *const ::std::os::raw::c_char,
    _OldStream: *mut FILE,
  ) -> errno_t;
}
extern "C" {
  pub fn gets_s(
    _Buffer: *mut ::std::os::raw::c_char,
    _Size: rsize_t,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn tmpfile_s(_Stream: *mut *mut FILE) -> errno_t;
}
extern "C" {
  pub fn tmpnam_s(_Buffer: *mut ::std::os::raw::c_char, _Size: rsize_t) -> errno_t;
}
extern "C" {
  pub fn clearerr(_Stream: *mut FILE);
}
extern "C" {
  pub fn fclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _fdopen(
    _FileHandle: ::std::os::raw::c_int,
    _Mode: *const ::std::os::raw::c_char,
  ) -> *mut FILE;
}
extern "C" {
  pub fn feof(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ferror(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fflush(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fgetc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fgetpos(_Stream: *mut FILE, _Position: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fgets(
    _Buffer: *mut ::std::os::raw::c_char,
    _MaxCount: ::std::os::raw::c_int,
    _Stream: *mut FILE,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn _fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _flushall() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fopen(
    _FileName: *const ::std::os::raw::c_char,
    _Mode: *const ::std::os::raw::c_char,
  ) -> *mut FILE;
}
extern "C" {
  pub fn fputc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _fputchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fputs(_Buffer: *const ::std::os::raw::c_char, _Stream: *mut FILE)
    -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fread(
    _Buffer: *mut ::std::os::raw::c_void,
    _ElementSize: ::std::os::raw::c_ulonglong,
    _ElementCount: ::std::os::raw::c_ulonglong,
    _Stream: *mut FILE,
  ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
  pub fn freopen(
    _FileName: *const ::std::os::raw::c_char,
    _Mode: *const ::std::os::raw::c_char,
    _Stream: *mut FILE,
  ) -> *mut FILE;
}
extern "C" {
  pub fn _fsopen(
    _FileName: *const ::std::os::raw::c_char,
    _Mode: *const ::std::os::raw::c_char,
    _ShFlag: ::std::os::raw::c_int,
  ) -> *mut FILE;
}
extern "C" {
  pub fn fsetpos(_Stream: *mut FILE, _Position: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fseek(
    _Stream: *mut FILE,
    _Offset: ::std::os::raw::c_long,
    _Origin: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _fseeki64(
    _Stream: *mut FILE,
    _Offset: ::std::os::raw::c_longlong,
    _Origin: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ftell(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn _ftelli64(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn fwrite(
    _Buffer: *const ::std::os::raw::c_void,
    _ElementSize: ::std::os::raw::c_ulonglong,
    _ElementCount: ::std::os::raw::c_ulonglong,
    _Stream: *mut FILE,
  ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
  pub fn getc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _getmaxstdio() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _pclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _popen(
    _Command: *const ::std::os::raw::c_char,
    _Mode: *const ::std::os::raw::c_char,
  ) -> *mut FILE;
}
extern "C" {
  pub fn putc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn putchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn puts(_Buffer: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _putw(_Word: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn remove(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn rename(
    _OldFileName: *const ::std::os::raw::c_char,
    _NewFileName: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn rewind(_Stream: *mut FILE);
}
extern "C" {
  pub fn _rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn setbuf(_Stream: *mut FILE, _Buffer: *mut ::std::os::raw::c_char);
}
extern "C" {
  pub fn _setmaxstdio(_Maximum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn setvbuf(
    _Stream: *mut FILE,
    _Buffer: *mut ::std::os::raw::c_char,
    _Mode: ::std::os::raw::c_int,
    _Size: usize,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _tempnam(
    _DirectoryName: *const ::std::os::raw::c_char,
    _FilePrefix: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn tmpfile() -> *mut FILE;
}
extern "C" {
  pub fn tmpnam(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn ungetc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _lock_file(_Stream: *mut FILE);
}
extern "C" {
  pub fn _unlock_file(_Stream: *mut FILE);
}
extern "C" {
  pub fn _fclose_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _fflush_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _fgetc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _fputc_nolock(
    _Character: ::std::os::raw::c_int,
    _Stream: *mut FILE,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _fread_nolock(
    _Buffer: *mut ::std::os::raw::c_void,
    _ElementSize: usize,
    _ElementCount: usize,
    _Stream: *mut FILE,
  ) -> usize;
}
extern "C" {
  pub fn _fread_nolock_s(
    _Buffer: *mut ::std::os::raw::c_void,
    _BufferSize: usize,
    _ElementSize: usize,
    _ElementCount: usize,
    _Stream: *mut FILE,
  ) -> usize;
}
extern "C" {
  pub fn _fseek_nolock(
    _Stream: *mut FILE,
    _Offset: ::std::os::raw::c_long,
    _Origin: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _fseeki64_nolock(
    _Stream: *mut FILE,
    _Offset: ::std::os::raw::c_longlong,
    _Origin: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _ftell_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn _ftelli64_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn _fwrite_nolock(
    _Buffer: *const ::std::os::raw::c_void,
    _ElementSize: usize,
    _ElementCount: usize,
    _Stream: *mut FILE,
  ) -> usize;
}
extern "C" {
  pub fn _getc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _putc_nolock(
    _Character: ::std::os::raw::c_int,
    _Stream: *mut FILE,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _ungetc_nolock(
    _Character: ::std::os::raw::c_int,
    _Stream: *mut FILE,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __p__commode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
  pub fn __stdio_common_vfprintf(
    _Options: ::std::os::raw::c_ulonglong,
    _Stream: *mut FILE,
    _Format: *const ::std::os::raw::c_char,
    _Locale: _locale_t,
    _ArgList: va_list,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __stdio_common_vfprintf_s(
    _Options: ::std::os::raw::c_ulonglong,
    _Stream: *mut FILE,
    _Format: *const ::std::os::raw::c_char,
    _Locale: _locale_t,
    _ArgList: va_list,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __stdio_common_vfprintf_p(
    _Options: ::std::os::raw::c_ulonglong,
    _Stream: *mut FILE,
    _Format: *const ::std::os::raw::c_char,
    _Locale: _locale_t,
    _ArgList: va_list,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _set_printf_count_output(_Value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _get_printf_count_output() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __stdio_common_vfscanf(
    _Options: ::std::os::raw::c_ulonglong,
    _Stream: *mut FILE,
    _Format: *const ::std::os::raw::c_char,
    _Locale: _locale_t,
    _Arglist: va_list,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __stdio_common_vsprintf(
    _Options: ::std::os::raw::c_ulonglong,
    _Buffer: *mut ::std::os::raw::c_char,
    _BufferCount: usize,
    _Format: *const ::std::os::raw::c_char,
    _Locale: _locale_t,
    _ArgList: va_list,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __stdio_common_vsprintf_s(
    _Options: ::std::os::raw::c_ulonglong,
    _Buffer: *mut ::std::os::raw::c_char,
    _BufferCount: usize,
    _Format: *const ::std::os::raw::c_char,
    _Locale: _locale_t,
    _ArgList: va_list,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __stdio_common_vsnprintf_s(
    _Options: ::std::os::raw::c_ulonglong,
    _Buffer: *mut ::std::os::raw::c_char,
    _BufferCount: usize,
    _MaxCount: usize,
    _Format: *const ::std::os::raw::c_char,
    _Locale: _locale_t,
    _ArgList: va_list,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __stdio_common_vsprintf_p(
    _Options: ::std::os::raw::c_ulonglong,
    _Buffer: *mut ::std::os::raw::c_char,
    _BufferCount: usize,
    _Format: *const ::std::os::raw::c_char,
    _Locale: _locale_t,
    _ArgList: va_list,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __stdio_common_vsscanf(
    _Options: ::std::os::raw::c_ulonglong,
    _Buffer: *const ::std::os::raw::c_char,
    _BufferCount: usize,
    _Format: *const ::std::os::raw::c_char,
    _Locale: _locale_t,
    _ArgList: va_list,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn tempnam(
    _Directory: *const ::std::os::raw::c_char,
    _FilePrefix: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fdopen(
    _FileHandle: ::std::os::raw::c_int,
    _Format: *const ::std::os::raw::c_char,
  ) -> *mut FILE;
}
extern "C" {
  pub fn fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn flushall() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn putw(_Ch: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn rmtmp() -> ::std::os::raw::c_int;
}
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_SEARCH_FOR_METADATA:
  FLAC__StreamDecoderState = 0;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_READ_METADATA: FLAC__StreamDecoderState = 1;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC:
  FLAC__StreamDecoderState = 2;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_READ_FRAME: FLAC__StreamDecoderState = 3;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_END_OF_STREAM: FLAC__StreamDecoderState = 4;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_OGG_ERROR: FLAC__StreamDecoderState = 5;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_SEEK_ERROR: FLAC__StreamDecoderState = 6;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_ABORTED: FLAC__StreamDecoderState = 7;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR:
  FLAC__StreamDecoderState = 8;
pub const FLAC__StreamDecoderState_FLAC__STREAM_DECODER_UNINITIALIZED: FLAC__StreamDecoderState = 9;
#[doc = " State values for a FLAC__StreamDecoder\n\n The decoder's state can be obtained by calling FLAC__stream_decoder_get_state()."]
pub type FLAC__StreamDecoderState = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__StreamDecoderState to a C string.\n\n  Using a FLAC__StreamDecoderState as the index to this array\n  will give the string equivalent.  The contents should not be modified."]
  pub static FLAC__StreamDecoderStateString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_OK:
  FLAC__StreamDecoderInitStatus = 0;
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER:
  FLAC__StreamDecoderInitStatus = 1;
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS:
  FLAC__StreamDecoderInitStatus = 2;
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR:
  FLAC__StreamDecoderInitStatus = 3;
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE:
  FLAC__StreamDecoderInitStatus = 4;
pub const FLAC__StreamDecoderInitStatus_FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED:
  FLAC__StreamDecoderInitStatus = 5;
#[doc = " Possible return values for the FLAC__stream_decoder_init_*() functions."]
pub type FLAC__StreamDecoderInitStatus = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__StreamDecoderInitStatus to a C string.\n\n  Using a FLAC__StreamDecoderInitStatus as the index to this array\n  will give the string equivalent.  The contents should not be modified."]
  pub static FLAC__StreamDecoderInitStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderReadStatus_FLAC__STREAM_DECODER_READ_STATUS_CONTINUE:
  FLAC__StreamDecoderReadStatus = 0;
pub const FLAC__StreamDecoderReadStatus_FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM:
  FLAC__StreamDecoderReadStatus = 1;
pub const FLAC__StreamDecoderReadStatus_FLAC__STREAM_DECODER_READ_STATUS_ABORT:
  FLAC__StreamDecoderReadStatus = 2;
#[doc = " Return values for the FLAC__StreamDecoder read callback."]
pub type FLAC__StreamDecoderReadStatus = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__StreamDecoderReadStatus to a C string.\n\n  Using a FLAC__StreamDecoderReadStatus as the index to this array\n  will give the string equivalent.  The contents should not be modified."]
  pub static FLAC__StreamDecoderReadStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderSeekStatus_FLAC__STREAM_DECODER_SEEK_STATUS_OK:
  FLAC__StreamDecoderSeekStatus = 0;
pub const FLAC__StreamDecoderSeekStatus_FLAC__STREAM_DECODER_SEEK_STATUS_ERROR:
  FLAC__StreamDecoderSeekStatus = 1;
pub const FLAC__StreamDecoderSeekStatus_FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED:
  FLAC__StreamDecoderSeekStatus = 2;
#[doc = " Return values for the FLAC__StreamDecoder seek callback."]
pub type FLAC__StreamDecoderSeekStatus = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__StreamDecoderSeekStatus to a C string.\n\n  Using a FLAC__StreamDecoderSeekStatus as the index to this array\n  will give the string equivalent.  The contents should not be modified."]
  pub static FLAC__StreamDecoderSeekStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderTellStatus_FLAC__STREAM_DECODER_TELL_STATUS_OK:
  FLAC__StreamDecoderTellStatus = 0;
pub const FLAC__StreamDecoderTellStatus_FLAC__STREAM_DECODER_TELL_STATUS_ERROR:
  FLAC__StreamDecoderTellStatus = 1;
pub const FLAC__StreamDecoderTellStatus_FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED:
  FLAC__StreamDecoderTellStatus = 2;
#[doc = " Return values for the FLAC__StreamDecoder tell callback."]
pub type FLAC__StreamDecoderTellStatus = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__StreamDecoderTellStatus to a C string.\n\n  Using a FLAC__StreamDecoderTellStatus as the index to this array\n  will give the string equivalent.  The contents should not be modified."]
  pub static FLAC__StreamDecoderTellStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderLengthStatus_FLAC__STREAM_DECODER_LENGTH_STATUS_OK:
  FLAC__StreamDecoderLengthStatus = 0;
pub const FLAC__StreamDecoderLengthStatus_FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR:
  FLAC__StreamDecoderLengthStatus = 1;
pub const FLAC__StreamDecoderLengthStatus_FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED:
  FLAC__StreamDecoderLengthStatus = 2;
#[doc = " Return values for the FLAC__StreamDecoder length callback."]
pub type FLAC__StreamDecoderLengthStatus = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__StreamDecoderLengthStatus to a C string.\n\n  Using a FLAC__StreamDecoderLengthStatus as the index to this array\n  will give the string equivalent.  The contents should not be modified."]
  pub static FLAC__StreamDecoderLengthStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderWriteStatus_FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE:
  FLAC__StreamDecoderWriteStatus = 0;
pub const FLAC__StreamDecoderWriteStatus_FLAC__STREAM_DECODER_WRITE_STATUS_ABORT:
  FLAC__StreamDecoderWriteStatus = 1;
#[doc = " Return values for the FLAC__StreamDecoder write callback."]
pub type FLAC__StreamDecoderWriteStatus = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__StreamDecoderWriteStatus to a C string.\n\n  Using a FLAC__StreamDecoderWriteStatus as the index to this array\n  will give the string equivalent.  The contents should not be modified."]
  pub static FLAC__StreamDecoderWriteStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamDecoderErrorStatus_FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC:
  FLAC__StreamDecoderErrorStatus = 0;
pub const FLAC__StreamDecoderErrorStatus_FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER:
  FLAC__StreamDecoderErrorStatus = 1;
pub const FLAC__StreamDecoderErrorStatus_FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH:
  FLAC__StreamDecoderErrorStatus = 2;
pub const FLAC__StreamDecoderErrorStatus_FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM:
  FLAC__StreamDecoderErrorStatus = 3;
pub const FLAC__StreamDecoderErrorStatus_FLAC__STREAM_DECODER_ERROR_STATUS_BAD_METADATA:
  FLAC__StreamDecoderErrorStatus = 4;
#[doc = " Possible values passed back to the FLAC__StreamDecoder error callback.\n  \\c FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC is the generic catch-\n  all.  The rest could be caused by bad sync (false synchronization on\n  data that is not the start of a frame) or corrupted data.  The error\n  itself is the decoder's best guess at what happened assuming a correct\n  sync.  For example \\c FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER\n  could be caused by a correct sync on the start of a frame, but some\n  data in the frame header was corrupted.  Or it could be the result of\n  syncing on a point the stream that looked like the starting of a frame\n  but was not.  \\c FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM\n  could be because the decoder encountered a valid frame made by a future\n  version of the encoder which it cannot parse, or because of a false\n  sync making it appear as though an encountered frame was generated by\n  a future encoder. \\c FLAC__STREAM_DECODER_ERROR_STATUS_BAD_METADATA is\n  caused by finding data that doesn't fit a metadata block (too large\n  or too small) or finding inconsistencies in the metadata, for example\n  a PICTURE block with an image that exceeds the size of the metadata\n  block."]
pub type FLAC__StreamDecoderErrorStatus = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__StreamDecoderErrorStatus to a C string.\n\n  Using a FLAC__StreamDecoderErrorStatus as the index to this array\n  will give the string equivalent.  The contents should not be modified."]
  pub static FLAC__StreamDecoderErrorStatusString: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = " class FLAC__StreamDecoder\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamDecoderProtected {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamDecoderPrivate {
  _unused: [u8; 0],
}
#[doc = " The opaque structure definition for the stream decoder type.\n  See the \\link flac_stream_decoder stream decoder module \\endlink\n  for a detailed description."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamDecoder {
  pub protected_: *mut FLAC__StreamDecoderProtected,
  pub private_: *mut FLAC__StreamDecoderPrivate,
}
#[test]
fn bindgen_test_layout_FLAC__StreamDecoder() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__StreamDecoder> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__StreamDecoder>(),
    16usize,
    concat!("Size of: ", stringify!(FLAC__StreamDecoder))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__StreamDecoder>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__StreamDecoder))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).protected_) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamDecoder),
      "::",
      stringify!(protected_)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).private_) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamDecoder),
      "::",
      stringify!(private_)
    )
  );
}
#[doc = " Signature for the read callback.\n\n  A function pointer matching this signature must be passed to\n  FLAC__stream_decoder_init*_stream(). The supplied function will be\n  called when the decoder needs more input data.  The address of the\n  buffer to be filled is supplied, along with the number of bytes the\n  buffer can hold.  The callback may choose to supply less data and\n  modify the byte count but must be careful not to overflow the buffer.\n  The callback then returns a status code chosen from\n  FLAC__StreamDecoderReadStatus.\n\n Here is an example of a read callback for stdio streams:\n \\code\n FLAC__StreamDecoderReadStatus read_cb(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data)\n {\n   FILE *file = ((MyClientData*)client_data)->file;\n   if(*bytes > 0) {\n     *bytes = fread(buffer, sizeof(FLAC__byte), *bytes, file);\n     if(ferror(file))\n       return FLAC__STREAM_DECODER_READ_STATUS_ABORT;\n     else if(*bytes == 0)\n       return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;\n     else\n       return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;\n   }\n   else\n     return FLAC__STREAM_DECODER_READ_STATUS_ABORT;\n }\n \\endcode\n\n \\note In general, FLAC__StreamDecoder functions which change the\n state should not be called on the \\a decoder while in the callback.\n\n \\param  decoder  The decoder instance calling the callback.\n \\param  buffer   A pointer to a location for the callee to store\n                  data to be decoded.\n \\param  bytes    A pointer to the size of the buffer.  On entry\n                  to the callback, it contains the maximum number\n                  of bytes that may be stored in \\a buffer.  The\n                  callee must set it to the actual number of bytes\n                  stored (0 in case of error or end-of-stream) before\n                  returning.\n \\param  client_data  The callee's client data set through\n                      FLAC__stream_decoder_init_*().\n \\retval FLAC__StreamDecoderReadStatus\n    The callee's return status.  Note that the callback should return\n    \\c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM if and only if\n    zero bytes were read and there is no more data to be read."]
pub type FLAC__StreamDecoderReadCallback = ::std::option::Option<
  unsafe extern "C" fn(
    decoder: *const FLAC__StreamDecoder,
    buffer: *mut FLAC__byte,
    bytes: *mut usize,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamDecoderReadStatus,
>;
#[doc = " Signature for the seek callback.\n\n  A function pointer matching this signature may be passed to\n  FLAC__stream_decoder_init*_stream().  The supplied function will be\n  called when the decoder needs to seek the input stream.  The decoder\n  will pass the absolute byte offset to seek to, 0 meaning the\n  beginning of the stream.\n\n Here is an example of a seek callback for stdio streams:\n \\code\n FLAC__StreamDecoderSeekStatus seek_cb(const FLAC__StreamDecoder *decoder, FLAC__uint64 absolute_byte_offset, void *client_data)\n {\n   FILE *file = ((MyClientData*)client_data)->file;\n   if(file == stdin)\n     return FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED;\n   else if(fseeko(file, (off_t)absolute_byte_offset, SEEK_SET) < 0)\n     return FLAC__STREAM_DECODER_SEEK_STATUS_ERROR;\n   else\n     return FLAC__STREAM_DECODER_SEEK_STATUS_OK;\n }\n \\endcode\n\n \\note In general, FLAC__StreamDecoder functions which change the\n state should not be called on the \\a decoder while in the callback.\n\n \\param  decoder  The decoder instance calling the callback.\n \\param  absolute_byte_offset  The offset from the beginning of the stream\n                               to seek to.\n \\param  client_data  The callee's client data set through\n                      FLAC__stream_decoder_init_*().\n \\retval FLAC__StreamDecoderSeekStatus\n    The callee's return status."]
pub type FLAC__StreamDecoderSeekCallback = ::std::option::Option<
  unsafe extern "C" fn(
    decoder: *const FLAC__StreamDecoder,
    absolute_byte_offset: FLAC__uint64,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamDecoderSeekStatus,
>;
#[doc = " Signature for the tell callback.\n\n  A function pointer matching this signature may be passed to\n  FLAC__stream_decoder_init*_stream().  The supplied function will be\n  called when the decoder wants to know the current position of the\n  stream.  The callback should return the byte offset from the\n  beginning of the stream.\n\n Here is an example of a tell callback for stdio streams:\n \\code\n FLAC__StreamDecoderTellStatus tell_cb(const FLAC__StreamDecoder *decoder, FLAC__uint64 *absolute_byte_offset, void *client_data)\n {\n   FILE *file = ((MyClientData*)client_data)->file;\n   off_t pos;\n   if(file == stdin)\n     return FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED;\n   else if((pos = ftello(file)) < 0)\n     return FLAC__STREAM_DECODER_TELL_STATUS_ERROR;\n   else {\n     *absolute_byte_offset = (FLAC__uint64)pos;\n     return FLAC__STREAM_DECODER_TELL_STATUS_OK;\n   }\n }\n \\endcode\n\n \\note In general, FLAC__StreamDecoder functions which change the\n state should not be called on the \\a decoder while in the callback.\n\n \\param  decoder  The decoder instance calling the callback.\n \\param  absolute_byte_offset  A pointer to storage for the current offset\n                               from the beginning of the stream.\n \\param  client_data  The callee's client data set through\n                      FLAC__stream_decoder_init_*().\n \\retval FLAC__StreamDecoderTellStatus\n    The callee's return status."]
pub type FLAC__StreamDecoderTellCallback = ::std::option::Option<
  unsafe extern "C" fn(
    decoder: *const FLAC__StreamDecoder,
    absolute_byte_offset: *mut FLAC__uint64,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamDecoderTellStatus,
>;
#[doc = " Signature for the length callback.\n\n  A function pointer matching this signature may be passed to\n  FLAC__stream_decoder_init*_stream().  The supplied function will be\n  called when the decoder wants to know the total length of the stream\n  in bytes.\n\n Here is an example of a length callback for stdio streams:\n \\code\n FLAC__StreamDecoderLengthStatus length_cb(const FLAC__StreamDecoder *decoder, FLAC__uint64 *stream_length, void *client_data)\n {\n   FILE *file = ((MyClientData*)client_data)->file;\n   struct stat filestats;\n\n   if(file == stdin)\n     return FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED;\n   else if(fstat(fileno(file), &filestats) != 0)\n     return FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR;\n   else {\n     *stream_length = (FLAC__uint64)filestats.st_size;\n     return FLAC__STREAM_DECODER_LENGTH_STATUS_OK;\n   }\n }\n \\endcode\n\n \\note In general, FLAC__StreamDecoder functions which change the\n state should not be called on the \\a decoder while in the callback.\n\n \\param  decoder  The decoder instance calling the callback.\n \\param  stream_length  A pointer to storage for the length of the stream\n                        in bytes.\n \\param  client_data  The callee's client data set through\n                      FLAC__stream_decoder_init_*().\n \\retval FLAC__StreamDecoderLengthStatus\n    The callee's return status."]
pub type FLAC__StreamDecoderLengthCallback = ::std::option::Option<
  unsafe extern "C" fn(
    decoder: *const FLAC__StreamDecoder,
    stream_length: *mut FLAC__uint64,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamDecoderLengthStatus,
>;
#[doc = " Signature for the EOF callback.\n\n  A function pointer matching this signature may be passed to\n  FLAC__stream_decoder_init*_stream().  The supplied function will be\n  called when the decoder needs to know if the end of the stream has\n  been reached.\n\n Here is an example of a EOF callback for stdio streams:\n FLAC__bool eof_cb(const FLAC__StreamDecoder *decoder, void *client_data)\n \\code\n {\n   FILE *file = ((MyClientData*)client_data)->file;\n   return feof(file)? true : false;\n }\n \\endcode\n\n \\note In general, FLAC__StreamDecoder functions which change the\n state should not be called on the \\a decoder while in the callback.\n\n \\param  decoder  The decoder instance calling the callback.\n \\param  client_data  The callee's client data set through\n                      FLAC__stream_decoder_init_*().\n \\retval FLAC__bool\n    \\c true if the currently at the end of the stream, else \\c false."]
pub type FLAC__StreamDecoderEofCallback = ::std::option::Option<
  unsafe extern "C" fn(
    decoder: *const FLAC__StreamDecoder,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__bool,
>;
#[doc = " Signature for the write callback.\n\n  A function pointer matching this signature must be passed to one of\n  the FLAC__stream_decoder_init_*() functions.\n  The supplied function will be called when the decoder has decoded a\n  single audio frame.  The decoder will pass the frame metadata as well\n  as an array of pointers (one for each channel) pointing to the\n  decoded audio.\n\n \\note In general, FLAC__StreamDecoder functions which change the\n state should not be called on the \\a decoder while in the callback.\n\n \\param  decoder  The decoder instance calling the callback.\n \\param  frame    The description of the decoded frame.  See\n                  FLAC__Frame.\n \\param  buffer   An array of pointers to decoded channels of data.\n                  Each pointer will point to an array of signed\n                  samples of length \\a frame->header.blocksize.\n                  Channels will be ordered according to the FLAC\n                  specification; see the documentation for the\n                  <A HREF=\"https://xiph.org/flac/format.html#frame_header\">frame header</A>.\n \\param  client_data  The callee's client data set through\n                      FLAC__stream_decoder_init_*().\n \\retval FLAC__StreamDecoderWriteStatus\n    The callee's return status."]
pub type FLAC__StreamDecoderWriteCallback = ::std::option::Option<
  unsafe extern "C" fn(
    decoder: *const FLAC__StreamDecoder,
    frame: *const FLAC__Frame,
    buffer: *const *const FLAC__int32,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamDecoderWriteStatus,
>;
#[doc = " Signature for the metadata callback.\n\n  A function pointer matching this signature must be passed to one of\n  the FLAC__stream_decoder_init_*() functions.\n  The supplied function will be called when the decoder has decoded a\n  metadata block.  In a valid FLAC file there will always be one\n  \\c STREAMINFO block, followed by zero or more other metadata blocks.\n  These will be supplied by the decoder in the same order as they\n  appear in the stream and always before the first audio frame (i.e.\n  write callback).  The metadata block that is passed in must not be\n  modified, and it doesn't live beyond the callback, so you should make\n  a copy of it with FLAC__metadata_object_clone() if you will need it\n  elsewhere.  Since metadata blocks can potentially be large, by\n  default the decoder only calls the metadata callback for the\n  \\c STREAMINFO block; you can instruct the decoder to pass or filter\n  other blocks with FLAC__stream_decoder_set_metadata_*() calls.\n\n \\note In general, FLAC__StreamDecoder functions which change the\n state should not be called on the \\a decoder while in the callback.\n\n \\param  decoder  The decoder instance calling the callback.\n \\param  metadata The decoded metadata block.\n \\param  client_data  The callee's client data set through\n                      FLAC__stream_decoder_init_*()."]
pub type FLAC__StreamDecoderMetadataCallback = ::std::option::Option<
  unsafe extern "C" fn(
    decoder: *const FLAC__StreamDecoder,
    metadata: *const FLAC__StreamMetadata,
    client_data: *mut ::std::os::raw::c_void,
  ),
>;
#[doc = " Signature for the error callback.\n\n  A function pointer matching this signature must be passed to one of\n  the FLAC__stream_decoder_init_*() functions.\n  The supplied function will be called whenever an error occurs during\n  decoding.\n\n \\note In general, FLAC__StreamDecoder functions which change the\n state should not be called on the \\a decoder while in the callback.\n\n \\param  decoder  The decoder instance calling the callback.\n \\param  status   The error encountered by the decoder.\n \\param  client_data  The callee's client data set through\n                      FLAC__stream_decoder_init_*()."]
pub type FLAC__StreamDecoderErrorCallback = ::std::option::Option<
  unsafe extern "C" fn(
    decoder: *const FLAC__StreamDecoder,
    status: FLAC__StreamDecoderErrorStatus,
    client_data: *mut ::std::os::raw::c_void,
  ),
>;
extern "C" {
  #[doc = " Create a new stream decoder instance.  The instance is created with\n  default settings; see the individual FLAC__stream_decoder_set_*()\n  functions for each setting's default.\n\n \\retval FLAC__StreamDecoder*\n    \\c NULL if there was an error allocating memory, else the new instance."]
  pub fn FLAC__stream_decoder_new() -> *mut FLAC__StreamDecoder;
}
extern "C" {
  #[doc = " Free a decoder instance.  Deletes the object pointed to by \\a decoder.\n\n \\param decoder  A pointer to an existing decoder.\n \\assert\n    \\code decoder != NULL \\endcode"]
  pub fn FLAC__stream_decoder_delete(decoder: *mut FLAC__StreamDecoder);
}
extern "C" {
  #[doc = " Set the serial number for the FLAC stream within the Ogg container.\n  The default behavior is to use the serial number of the first Ogg\n  page.  Setting a serial number here will explicitly specify which\n  stream is to be decoded.\n\n \\note\n This does not need to be set for native FLAC decoding.\n\n \\default \\c use serial number of first page\n \\param  decoder        A decoder instance to set.\n \\param  serial_number  See above.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the decoder is already initialized, else \\c true."]
  pub fn FLAC__stream_decoder_set_ogg_serial_number(
    decoder: *mut FLAC__StreamDecoder,
    serial_number: ::std::os::raw::c_long,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set the \"MD5 signature checking\" flag.  If \\c true, the decoder will\n  compute the MD5 signature of the unencoded audio data while decoding\n  and compare it to the signature from the STREAMINFO block, if it\n  exists, during FLAC__stream_decoder_finish().\n\n  MD5 signature checking will be turned off (until the next\n  FLAC__stream_decoder_reset()) if there is no signature in the\n  STREAMINFO block or when a seek is attempted.\n\n  Clients that do not use the MD5 check should leave this off to speed\n  up decoding.\n\n \\default \\c false\n \\param  decoder  A decoder instance to set.\n \\param  value    Flag value (see above).\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the decoder is already initialized, else \\c true."]
  pub fn FLAC__stream_decoder_set_md5_checking(
    decoder: *mut FLAC__StreamDecoder,
    value: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Direct the decoder to pass on all metadata blocks of type \\a type.\n\n \\default By default, only the \\c STREAMINFO block is returned via the\n          metadata callback.\n \\param  decoder  A decoder instance to set.\n \\param  type     See above.\n \\assert\n    \\code decoder != NULL \\endcode\n    \\a type is valid\n \\retval FLAC__bool\n    \\c false if the decoder is already initialized, else \\c true."]
  pub fn FLAC__stream_decoder_set_metadata_respond(
    decoder: *mut FLAC__StreamDecoder,
    type_: FLAC__MetadataType,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Direct the decoder to pass on all APPLICATION metadata blocks of the\n  given \\a id.\n\n \\default By default, only the \\c STREAMINFO block is returned via the\n          metadata callback.\n \\param  decoder  A decoder instance to set.\n \\param  id       See above.\n \\assert\n    \\code decoder != NULL \\endcode\n    \\code id != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the decoder is already initialized, else \\c true."]
  pub fn FLAC__stream_decoder_set_metadata_respond_application(
    decoder: *mut FLAC__StreamDecoder,
    id: *const FLAC__byte,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Direct the decoder to pass on all metadata blocks of any type.\n\n \\default By default, only the \\c STREAMINFO block is returned via the\n          metadata callback.\n \\param  decoder  A decoder instance to set.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the decoder is already initialized, else \\c true."]
  pub fn FLAC__stream_decoder_set_metadata_respond_all(
    decoder: *mut FLAC__StreamDecoder,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Direct the decoder to filter out all metadata blocks of type \\a type.\n\n \\default By default, only the \\c STREAMINFO block is returned via the\n          metadata callback.\n \\param  decoder  A decoder instance to set.\n \\param  type     See above.\n \\assert\n    \\code decoder != NULL \\endcode\n    \\a type is valid\n \\retval FLAC__bool\n    \\c false if the decoder is already initialized, else \\c true."]
  pub fn FLAC__stream_decoder_set_metadata_ignore(
    decoder: *mut FLAC__StreamDecoder,
    type_: FLAC__MetadataType,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Direct the decoder to filter out all APPLICATION metadata blocks of\n  the given \\a id.\n\n \\default By default, only the \\c STREAMINFO block is returned via the\n          metadata callback.\n \\param  decoder  A decoder instance to set.\n \\param  id       See above.\n \\assert\n    \\code decoder != NULL \\endcode\n    \\code id != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the decoder is already initialized, else \\c true."]
  pub fn FLAC__stream_decoder_set_metadata_ignore_application(
    decoder: *mut FLAC__StreamDecoder,
    id: *const FLAC__byte,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Direct the decoder to filter out all metadata blocks of any type.\n\n \\default By default, only the \\c STREAMINFO block is returned via the\n          metadata callback.\n \\param  decoder  A decoder instance to set.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the decoder is already initialized, else \\c true."]
  pub fn FLAC__stream_decoder_set_metadata_ignore_all(
    decoder: *mut FLAC__StreamDecoder,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Get the current decoder state.\n\n \\param  decoder  A decoder instance to query.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__StreamDecoderState\n    The current decoder state."]
  pub fn FLAC__stream_decoder_get_state(
    decoder: *const FLAC__StreamDecoder,
  ) -> FLAC__StreamDecoderState;
}
extern "C" {
  #[doc = " Get the current decoder state as a C string.\n\n \\param  decoder  A decoder instance to query.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval const char *\n    The decoder state as a C string.  Do not modify the contents."]
  pub fn FLAC__stream_decoder_get_resolved_state_string(
    decoder: *const FLAC__StreamDecoder,
  ) -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Get the \"MD5 signature checking\" flag.\n  This is the value of the setting, not whether or not the decoder is\n  currently checking the MD5 (remember, it can be turned off automatically\n  by a seek).  When the decoder is reset the flag will be restored to the\n  value returned by this function.\n\n \\param  decoder  A decoder instance to query.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__bool\n    See above."]
  pub fn FLAC__stream_decoder_get_md5_checking(decoder: *const FLAC__StreamDecoder) -> FLAC__bool;
}
extern "C" {
  #[doc = " Get the total number of samples in the stream being decoded.\n  Will only be valid after decoding has started and will contain the\n  value from the \\c STREAMINFO block.  A value of \\c 0 means \"unknown\".\n\n \\param  decoder  A decoder instance to query.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval uint32_t\n    See above."]
  pub fn FLAC__stream_decoder_get_total_samples(
    decoder: *const FLAC__StreamDecoder,
  ) -> FLAC__uint64;
}
extern "C" {
  #[doc = " Get the current number of channels in the stream being decoded.\n  Will only be valid after decoding has started and will contain the\n  value from the most recently decoded frame header.\n\n \\param  decoder  A decoder instance to query.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval uint32_t\n    See above."]
  pub fn FLAC__stream_decoder_get_channels(decoder: *const FLAC__StreamDecoder) -> u32;
}
extern "C" {
  #[doc = " Get the current channel assignment in the stream being decoded.\n  Will only be valid after decoding has started and will contain the\n  value from the most recently decoded frame header.\n\n \\param  decoder  A decoder instance to query.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__ChannelAssignment\n    See above."]
  pub fn FLAC__stream_decoder_get_channel_assignment(
    decoder: *const FLAC__StreamDecoder,
  ) -> FLAC__ChannelAssignment;
}
extern "C" {
  #[doc = " Get the current sample resolution in the stream being decoded.\n  Will only be valid after decoding has started and will contain the\n  value from the most recently decoded frame header.\n\n \\param  decoder  A decoder instance to query.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval uint32_t\n    See above."]
  pub fn FLAC__stream_decoder_get_bits_per_sample(decoder: *const FLAC__StreamDecoder) -> u32;
}
extern "C" {
  #[doc = " Get the current sample rate in Hz of the stream being decoded.\n  Will only be valid after decoding has started and will contain the\n  value from the most recently decoded frame header.\n\n \\param  decoder  A decoder instance to query.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval uint32_t\n    See above."]
  pub fn FLAC__stream_decoder_get_sample_rate(decoder: *const FLAC__StreamDecoder) -> u32;
}
extern "C" {
  #[doc = " Get the current blocksize of the stream being decoded.\n  Will only be valid after decoding has started and will contain the\n  value from the most recently decoded frame header.\n\n \\param  decoder  A decoder instance to query.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval uint32_t\n    See above."]
  pub fn FLAC__stream_decoder_get_blocksize(decoder: *const FLAC__StreamDecoder) -> u32;
}
extern "C" {
  #[doc = " Returns the decoder's current read position within the stream.\n  The position is the byte offset from the start of the stream.\n  Bytes before this position have been fully decoded.  Note that\n  there may still be undecoded bytes in the decoder's read FIFO.\n  The returned position is correct even after a seek.\n\n  \\warning This function currently only works for native FLAC,\n           not Ogg FLAC streams.\n\n \\param  decoder   A decoder instance to query.\n \\param  position  Address at which to return the desired position.\n \\assert\n    \\code decoder != NULL \\endcode\n    \\code position != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if successful, \\c false if the stream is not native FLAC,\n    or there was an error from the 'tell' callback or it returned\n    \\c FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED."]
  pub fn FLAC__stream_decoder_get_decode_position(
    decoder: *const FLAC__StreamDecoder,
    position: *mut FLAC__uint64,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Return client_data from decoder.\n  The data pointed to by the pointer should not be modified.\n\n \\param  decoder  A decoder instance.\n \\retval const void *\n    The callee's client data set through FLAC__stream_decoder_init_*().\n    Do not modify the contents."]
  pub fn FLAC__stream_decoder_get_client_data(
    decoder: *mut FLAC__StreamDecoder,
  ) -> *const ::std::os::raw::c_void;
}
extern "C" {
  #[doc = " Initialize the decoder instance to decode native FLAC streams.\n\n  This flavor of initialization sets up the decoder to decode from a\n  native FLAC stream. I/O is performed via callbacks to the client.\n  For decoding from a plain file via filename or open FILE*,\n  FLAC__stream_decoder_init_file() and FLAC__stream_decoder_init_FILE()\n  provide a simpler interface.\n\n  This function should be called after FLAC__stream_decoder_new() and\n  FLAC__stream_decoder_set_*() but before any of the\n  FLAC__stream_decoder_process_*() functions.  Will set and return the\n  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA\n  if initialization succeeded.\n\n \\param  decoder            An uninitialized decoder instance.\n \\param  read_callback      See FLAC__StreamDecoderReadCallback.  This\n                            pointer must not be \\c NULL.\n \\param  seek_callback      See FLAC__StreamDecoderSeekCallback.  This\n                            pointer may be \\c NULL if seeking is not\n                            supported.  If \\a seek_callback is not \\c NULL then a\n                            \\a tell_callback, \\a length_callback, and \\a eof_callback must also be supplied.\n                            Alternatively, a dummy seek callback that just\n                            returns \\c FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED\n                            may also be supplied, all though this is slightly\n                            less efficient for the decoder.\n \\param  tell_callback      See FLAC__StreamDecoderTellCallback.  This\n                            pointer may be \\c NULL if not supported by the client.  If\n                            \\a seek_callback is not \\c NULL then a\n                            \\a tell_callback must also be supplied.\n                            Alternatively, a dummy tell callback that just\n                            returns \\c FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED\n                            may also be supplied, all though this is slightly\n                            less efficient for the decoder.\n \\param  length_callback    See FLAC__StreamDecoderLengthCallback.  This\n                            pointer may be \\c NULL if not supported by the client.  If\n                            \\a seek_callback is not \\c NULL then a\n                            \\a length_callback must also be supplied.\n                            Alternatively, a dummy length callback that just\n                            returns \\c FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED\n                            may also be supplied, all though this is slightly\n                            less efficient for the decoder.\n \\param  eof_callback       See FLAC__StreamDecoderEofCallback.  This\n                            pointer may be \\c NULL if not supported by the client.  If\n                            \\a seek_callback is not \\c NULL then a\n                            \\a eof_callback must also be supplied.\n                            Alternatively, a dummy length callback that just\n                            returns \\c false\n                            may also be supplied, all though this is slightly\n                            less efficient for the decoder.\n \\param  write_callback     See FLAC__StreamDecoderWriteCallback.  This\n                            pointer must not be \\c NULL.\n \\param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This\n                            pointer may be \\c NULL if the callback is not\n                            desired.\n \\param  error_callback     See FLAC__StreamDecoderErrorCallback.  This\n                            pointer must not be \\c NULL.\n \\param  client_data        This value will be supplied to callbacks in their\n                            \\a client_data argument.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__StreamDecoderInitStatus\n    \\c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;\n    see FLAC__StreamDecoderInitStatus for the meanings of other return values."]
  pub fn FLAC__stream_decoder_init_stream(
    decoder: *mut FLAC__StreamDecoder,
    read_callback: FLAC__StreamDecoderReadCallback,
    seek_callback: FLAC__StreamDecoderSeekCallback,
    tell_callback: FLAC__StreamDecoderTellCallback,
    length_callback: FLAC__StreamDecoderLengthCallback,
    eof_callback: FLAC__StreamDecoderEofCallback,
    write_callback: FLAC__StreamDecoderWriteCallback,
    metadata_callback: FLAC__StreamDecoderMetadataCallback,
    error_callback: FLAC__StreamDecoderErrorCallback,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
  #[doc = " Initialize the decoder instance to decode Ogg FLAC streams.\n\n  This flavor of initialization sets up the decoder to decode from a\n  FLAC stream in an Ogg container. I/O is performed via callbacks to the\n  client.  For decoding from a plain file via filename or open FILE*,\n  FLAC__stream_decoder_init_ogg_file() and FLAC__stream_decoder_init_ogg_FILE()\n  provide a simpler interface.\n\n  This function should be called after FLAC__stream_decoder_new() and\n  FLAC__stream_decoder_set_*() but before any of the\n  FLAC__stream_decoder_process_*() functions.  Will set and return the\n  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA\n  if initialization succeeded.\n\n  \\note Support for Ogg FLAC in the library is optional.  If this\n  library has been built without support for Ogg FLAC, this function\n  will return \\c FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER.\n\n \\param  decoder            An uninitialized decoder instance.\n \\param  read_callback      See FLAC__StreamDecoderReadCallback.  This\n                            pointer must not be \\c NULL.\n \\param  seek_callback      See FLAC__StreamDecoderSeekCallback.  This\n                            pointer may be \\c NULL if seeking is not\n                            supported.  If \\a seek_callback is not \\c NULL then a\n                            \\a tell_callback, \\a length_callback, and \\a eof_callback must also be supplied.\n                            Alternatively, a dummy seek callback that just\n                            returns \\c FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED\n                            may also be supplied, all though this is slightly\n                            less efficient for the decoder.\n \\param  tell_callback      See FLAC__StreamDecoderTellCallback.  This\n                            pointer may be \\c NULL if not supported by the client.  If\n                            \\a seek_callback is not \\c NULL then a\n                            \\a tell_callback must also be supplied.\n                            Alternatively, a dummy tell callback that just\n                            returns \\c FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED\n                            may also be supplied, all though this is slightly\n                            less efficient for the decoder.\n \\param  length_callback    See FLAC__StreamDecoderLengthCallback.  This\n                            pointer may be \\c NULL if not supported by the client.  If\n                            \\a seek_callback is not \\c NULL then a\n                            \\a length_callback must also be supplied.\n                            Alternatively, a dummy length callback that just\n                            returns \\c FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED\n                            may also be supplied, all though this is slightly\n                            less efficient for the decoder.\n \\param  eof_callback       See FLAC__StreamDecoderEofCallback.  This\n                            pointer may be \\c NULL if not supported by the client.  If\n                            \\a seek_callback is not \\c NULL then a\n                            \\a eof_callback must also be supplied.\n                            Alternatively, a dummy length callback that just\n                            returns \\c false\n                            may also be supplied, all though this is slightly\n                            less efficient for the decoder.\n \\param  write_callback     See FLAC__StreamDecoderWriteCallback.  This\n                            pointer must not be \\c NULL.\n \\param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This\n                            pointer may be \\c NULL if the callback is not\n                            desired.\n \\param  error_callback     See FLAC__StreamDecoderErrorCallback.  This\n                            pointer must not be \\c NULL.\n \\param  client_data        This value will be supplied to callbacks in their\n                            \\a client_data argument.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__StreamDecoderInitStatus\n    \\c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;\n    see FLAC__StreamDecoderInitStatus for the meanings of other return values."]
  pub fn FLAC__stream_decoder_init_ogg_stream(
    decoder: *mut FLAC__StreamDecoder,
    read_callback: FLAC__StreamDecoderReadCallback,
    seek_callback: FLAC__StreamDecoderSeekCallback,
    tell_callback: FLAC__StreamDecoderTellCallback,
    length_callback: FLAC__StreamDecoderLengthCallback,
    eof_callback: FLAC__StreamDecoderEofCallback,
    write_callback: FLAC__StreamDecoderWriteCallback,
    metadata_callback: FLAC__StreamDecoderMetadataCallback,
    error_callback: FLAC__StreamDecoderErrorCallback,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
  #[doc = " Initialize the decoder instance to decode native FLAC files.\n\n  This flavor of initialization sets up the decoder to decode from a\n  plain native FLAC file.  For non-stdio streams, you must use\n  FLAC__stream_decoder_init_stream() and provide callbacks for the I/O.\n\n  This function should be called after FLAC__stream_decoder_new() and\n  FLAC__stream_decoder_set_*() but before any of the\n  FLAC__stream_decoder_process_*() functions.  Will set and return the\n  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA\n  if initialization succeeded.\n\n \\param  decoder            An uninitialized decoder instance.\n \\param  file               An open FLAC file.  The file should have been\n                            opened with mode \\c \"rb\" and rewound.  The file\n                            becomes owned by the decoder and should not be\n                            manipulated by the client while decoding.\n                            Unless \\a file is \\c stdin, it will be closed\n                            when FLAC__stream_decoder_finish() is called.\n                            Note however that seeking will not work when\n                            decoding from \\c stdin since it is not seekable.\n \\param  write_callback     See FLAC__StreamDecoderWriteCallback.  This\n                            pointer must not be \\c NULL.\n \\param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This\n                            pointer may be \\c NULL if the callback is not\n                            desired.\n \\param  error_callback     See FLAC__StreamDecoderErrorCallback.  This\n                            pointer must not be \\c NULL.\n \\param  client_data        This value will be supplied to callbacks in their\n                            \\a client_data argument.\n \\assert\n    \\code decoder != NULL \\endcode\n    \\code file != NULL \\endcode\n \\retval FLAC__StreamDecoderInitStatus\n    \\c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;\n    see FLAC__StreamDecoderInitStatus for the meanings of other return values."]
  pub fn FLAC__stream_decoder_init_FILE(
    decoder: *mut FLAC__StreamDecoder,
    file: *mut FILE,
    write_callback: FLAC__StreamDecoderWriteCallback,
    metadata_callback: FLAC__StreamDecoderMetadataCallback,
    error_callback: FLAC__StreamDecoderErrorCallback,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
  #[doc = " Initialize the decoder instance to decode Ogg FLAC files.\n\n  This flavor of initialization sets up the decoder to decode from a\n  plain Ogg FLAC file.  For non-stdio streams, you must use\n  FLAC__stream_decoder_init_ogg_stream() and provide callbacks for the I/O.\n\n  This function should be called after FLAC__stream_decoder_new() and\n  FLAC__stream_decoder_set_*() but before any of the\n  FLAC__stream_decoder_process_*() functions.  Will set and return the\n  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA\n  if initialization succeeded.\n\n  \\note Support for Ogg FLAC in the library is optional.  If this\n  library has been built without support for Ogg FLAC, this function\n  will return \\c FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER.\n\n \\param  decoder            An uninitialized decoder instance.\n \\param  file               An open FLAC file.  The file should have been\n                            opened with mode \\c \"rb\" and rewound.  The file\n                            becomes owned by the decoder and should not be\n                            manipulated by the client while decoding.\n                            Unless \\a file is \\c stdin, it will be closed\n                            when FLAC__stream_decoder_finish() is called.\n                            Note however that seeking will not work when\n                            decoding from \\c stdin since it is not seekable.\n \\param  write_callback     See FLAC__StreamDecoderWriteCallback.  This\n                            pointer must not be \\c NULL.\n \\param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This\n                            pointer may be \\c NULL if the callback is not\n                            desired.\n \\param  error_callback     See FLAC__StreamDecoderErrorCallback.  This\n                            pointer must not be \\c NULL.\n \\param  client_data        This value will be supplied to callbacks in their\n                            \\a client_data argument.\n \\assert\n    \\code decoder != NULL \\endcode\n    \\code file != NULL \\endcode\n \\retval FLAC__StreamDecoderInitStatus\n    \\c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;\n    see FLAC__StreamDecoderInitStatus for the meanings of other return values."]
  pub fn FLAC__stream_decoder_init_ogg_FILE(
    decoder: *mut FLAC__StreamDecoder,
    file: *mut FILE,
    write_callback: FLAC__StreamDecoderWriteCallback,
    metadata_callback: FLAC__StreamDecoderMetadataCallback,
    error_callback: FLAC__StreamDecoderErrorCallback,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
  #[doc = " Initialize the decoder instance to decode native FLAC files.\n\n  This flavor of initialization sets up the decoder to decode from a plain\n  native FLAC file.  If POSIX fopen() semantics are not sufficient, you must\n  use FLAC__stream_decoder_init_FILE(), or FLAC__stream_decoder_init_stream()\n  and provide callbacks for the I/O.\n\n  On Windows, filename must be a UTF-8 encoded filename, which libFLAC\n  internally translates to an appropriate representation to use with\n  _wfopen. On all other systems, filename is passed to fopen without\n  any translation.\n\n  This function should be called after FLAC__stream_decoder_new() and\n  FLAC__stream_decoder_set_*() but before any of the\n  FLAC__stream_decoder_process_*() functions.  Will set and return the\n  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA\n  if initialization succeeded.\n\n \\param  decoder            An uninitialized decoder instance.\n \\param  filename           The name of the file to decode from.  The file will\n                            be opened with fopen().  Use \\c NULL to decode from\n                            \\c stdin.  Note that \\c stdin is not seekable.\n \\param  write_callback     See FLAC__StreamDecoderWriteCallback.  This\n                            pointer must not be \\c NULL.\n \\param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This\n                            pointer may be \\c NULL if the callback is not\n                            desired.\n \\param  error_callback     See FLAC__StreamDecoderErrorCallback.  This\n                            pointer must not be \\c NULL.\n \\param  client_data        This value will be supplied to callbacks in their\n                            \\a client_data argument.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__StreamDecoderInitStatus\n    \\c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;\n    see FLAC__StreamDecoderInitStatus for the meanings of other return values."]
  pub fn FLAC__stream_decoder_init_file(
    decoder: *mut FLAC__StreamDecoder,
    filename: *const ::std::os::raw::c_char,
    write_callback: FLAC__StreamDecoderWriteCallback,
    metadata_callback: FLAC__StreamDecoderMetadataCallback,
    error_callback: FLAC__StreamDecoderErrorCallback,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
  #[doc = " Initialize the decoder instance to decode Ogg FLAC files.\n\n  This flavor of initialization sets up the decoder to decode from a plain\n  Ogg FLAC file.  If POSIX fopen() semantics are not sufficient, you must use\n  FLAC__stream_decoder_init_ogg_FILE(), or FLAC__stream_decoder_init_ogg_stream()\n  and provide callbacks for the I/O.\n\n  On Windows, filename must be a UTF-8 encoded filename, which libFLAC\n  internally translates to an appropriate representation to use with\n  _wfopen. On all other systems, filename is passed to fopen without\n  any translation.\n\n  This function should be called after FLAC__stream_decoder_new() and\n  FLAC__stream_decoder_set_*() but before any of the\n  FLAC__stream_decoder_process_*() functions.  Will set and return the\n  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA\n  if initialization succeeded.\n\n  \\note Support for Ogg FLAC in the library is optional.  If this\n  library has been built without support for Ogg FLAC, this function\n  will return \\c FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER.\n\n \\param  decoder            An uninitialized decoder instance.\n \\param  filename           The name of the file to decode from.  The file will\n                            be opened with fopen().  Use \\c NULL to decode from\n                            \\c stdin.  Note that \\c stdin is not seekable.\n \\param  write_callback     See FLAC__StreamDecoderWriteCallback.  This\n                            pointer must not be \\c NULL.\n \\param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This\n                            pointer may be \\c NULL if the callback is not\n                            desired.\n \\param  error_callback     See FLAC__StreamDecoderErrorCallback.  This\n                            pointer must not be \\c NULL.\n \\param  client_data        This value will be supplied to callbacks in their\n                            \\a client_data argument.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__StreamDecoderInitStatus\n    \\c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;\n    see FLAC__StreamDecoderInitStatus for the meanings of other return values."]
  pub fn FLAC__stream_decoder_init_ogg_file(
    decoder: *mut FLAC__StreamDecoder,
    filename: *const ::std::os::raw::c_char,
    write_callback: FLAC__StreamDecoderWriteCallback,
    metadata_callback: FLAC__StreamDecoderMetadataCallback,
    error_callback: FLAC__StreamDecoderErrorCallback,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamDecoderInitStatus;
}
extern "C" {
  #[doc = " Finish the decoding process.\n  Flushes the decoding buffer, releases resources, resets the decoder\n  settings to their defaults, and returns the decoder state to\n  FLAC__STREAM_DECODER_UNINITIALIZED.\n\n  In the event of a prematurely-terminated decode, it is not strictly\n  necessary to call this immediately before FLAC__stream_decoder_delete()\n  but it is good practice to match every FLAC__stream_decoder_init_*()\n  with a FLAC__stream_decoder_finish().\n\n \\param  decoder  An uninitialized decoder instance.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if MD5 checking is on AND a STREAMINFO block was available\n    AND the MD5 signature in the STREAMINFO block was non-zero AND the\n    signature does not match the one computed by the decoder; else\n    \\c true."]
  pub fn FLAC__stream_decoder_finish(decoder: *mut FLAC__StreamDecoder) -> FLAC__bool;
}
extern "C" {
  #[doc = " Flush the stream input.\n  The decoder's input buffer will be cleared and the state set to\n  \\c FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC.  This will also turn\n  off MD5 checking.\n\n \\param  decoder  A decoder instance.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if successful, else \\c false if a memory allocation\n    error occurs (in which case the state will be set to\n    \\c FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR)."]
  pub fn FLAC__stream_decoder_flush(decoder: *mut FLAC__StreamDecoder) -> FLAC__bool;
}
extern "C" {
  #[doc = " Reset the decoding process.\n  The decoder's input buffer will be cleared and the state set to\n  \\c FLAC__STREAM_DECODER_SEARCH_FOR_METADATA.  This is similar to\n  FLAC__stream_decoder_finish() except that the settings are\n  preserved; there is no need to call FLAC__stream_decoder_init_*()\n  before decoding again.  MD5 checking will be restored to its original\n  setting.\n\n  If the decoder is seekable, or was initialized with\n  FLAC__stream_decoder_init*_FILE() or FLAC__stream_decoder_init*_file(),\n  the decoder will also attempt to seek to the beginning of the file.\n  If this rewind fails, this function will return \\c false.  It follows\n  that FLAC__stream_decoder_reset() cannot be used when decoding from\n  \\c stdin.\n\n  If the decoder was initialized with FLAC__stream_encoder_init*_stream()\n  and is not seekable (i.e. no seek callback was provided or the seek\n  callback returns \\c FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED), it\n  is the duty of the client to start feeding data from the beginning of\n  the stream on the next FLAC__stream_decoder_process_*() call.\n\n \\param  decoder  A decoder instance.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if successful, else \\c false if a memory allocation occurs\n    (in which case the state will be set to\n    \\c FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR) or a seek error\n    occurs (the state will be unchanged)."]
  pub fn FLAC__stream_decoder_reset(decoder: *mut FLAC__StreamDecoder) -> FLAC__bool;
}
extern "C" {
  #[doc = " Decode one metadata block or audio frame.\n  This version instructs the decoder to decode a either a single metadata\n  block or a single frame and stop, unless the callbacks return a fatal\n  error or the read callback returns\n  \\c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM.\n\n  As the decoder needs more input it will call the read callback.\n  Depending on what was decoded, the metadata or write callback will be\n  called with the decoded metadata block or audio frame.\n\n  Unless there is a fatal read error or end of stream, this function\n  will return once one whole frame is decoded.  In other words, if the\n  stream is not synchronized or points to a corrupt frame header, the\n  decoder will continue to try and resync until it gets to a valid\n  frame, then decode one frame, then return.  If the decoder points to\n  a frame whose frame CRC in the frame footer does not match the\n  computed frame CRC, this function will issue a\n  FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH error to the\n  error callback, and return, having decoded one complete, although\n  corrupt, frame.  (Such corrupted frames are sent as silence of the\n  correct length to the write callback.)\n\n \\param  decoder  An initialized decoder instance.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if any fatal read, write, or memory allocation error\n    occurred (meaning decoding must stop), else \\c true; for more\n    information about the decoder, check the decoder state with\n    FLAC__stream_decoder_get_state()."]
  pub fn FLAC__stream_decoder_process_single(decoder: *mut FLAC__StreamDecoder) -> FLAC__bool;
}
extern "C" {
  #[doc = " Decode until the end of the metadata.\n  This version instructs the decoder to decode from the current position\n  and continue until all the metadata has been read, or until the\n  callbacks return a fatal error or the read callback returns\n  \\c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM.\n\n  As the decoder needs more input it will call the read callback.\n  As each metadata block is decoded, the metadata callback will be called\n  with the decoded metadata.\n\n \\param  decoder  An initialized decoder instance.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if any fatal read, write, or memory allocation error\n    occurred (meaning decoding must stop), else \\c true; for more\n    information about the decoder, check the decoder state with\n    FLAC__stream_decoder_get_state()."]
  pub fn FLAC__stream_decoder_process_until_end_of_metadata(
    decoder: *mut FLAC__StreamDecoder,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Decode until the end of the stream.\n  This version instructs the decoder to decode from the current position\n  and continue until the end of stream (the read callback returns\n  \\c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM), or until the\n  callbacks return a fatal error.\n\n  As the decoder needs more input it will call the read callback.\n  As each metadata block and frame is decoded, the metadata or write\n  callback will be called with the decoded metadata or frame.\n\n \\param  decoder  An initialized decoder instance.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if any fatal read, write, or memory allocation error\n    occurred (meaning decoding must stop), else \\c true; for more\n    information about the decoder, check the decoder state with\n    FLAC__stream_decoder_get_state()."]
  pub fn FLAC__stream_decoder_process_until_end_of_stream(
    decoder: *mut FLAC__StreamDecoder,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Skip one audio frame.\n  This version instructs the decoder to 'skip' a single frame and stop,\n  unless the callbacks return a fatal error or the read callback returns\n  \\c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM.\n\n  The decoding flow is the same as what occurs when\n  FLAC__stream_decoder_process_single() is called to process an audio\n  frame, except that this function does not decode the parsed data into\n  PCM or call the write callback.  The integrity of the frame is still\n  checked the same way as in the other process functions.\n\n  This function will return once one whole frame is skipped, in the\n  same way that FLAC__stream_decoder_process_single() will return once\n  one whole frame is decoded.\n\n  This function can be used in more quickly determining FLAC frame\n  boundaries when decoding of the actual data is not needed, for\n  example when an application is separating a FLAC stream into frames\n  for editing or storing in a container.  To do this, the application\n  can use FLAC__stream_decoder_skip_single_frame() to quickly advance\n  to the next frame, then use\n  FLAC__stream_decoder_get_decode_position() to find the new frame\n  boundary.\n\n  This function should only be called when the stream has advanced\n  past all the metadata, otherwise it will return \\c false.\n\n \\param  decoder  An initialized decoder instance not in a metadata\n                  state.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if any fatal read, write, or memory allocation error\n    occurred (meaning decoding must stop), or if the decoder\n    is in the FLAC__STREAM_DECODER_SEARCH_FOR_METADATA or\n    FLAC__STREAM_DECODER_READ_METADATA state, else \\c true; for more\n    information about the decoder, check the decoder state with\n    FLAC__stream_decoder_get_state()."]
  pub fn FLAC__stream_decoder_skip_single_frame(decoder: *mut FLAC__StreamDecoder) -> FLAC__bool;
}
extern "C" {
  #[doc = " Flush the input and seek to an absolute sample.\n  Decoding will resume at the given sample.  Note that because of\n  this, the next write callback may contain a partial block.  The\n  client must support seeking the input or this function will fail\n  and return \\c false.  Furthermore, if the decoder state is\n  \\c FLAC__STREAM_DECODER_SEEK_ERROR, then the decoder must be flushed\n  with FLAC__stream_decoder_flush() or reset with\n  FLAC__stream_decoder_reset() before decoding can continue.\n\n \\param  decoder  A decoder instance.\n \\param  sample   The target sample number to seek to.\n \\assert\n    \\code decoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c true if successful, else \\c false."]
  pub fn FLAC__stream_decoder_seek_absolute(
    decoder: *mut FLAC__StreamDecoder,
    sample: FLAC__uint64,
  ) -> FLAC__bool;
}
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_OK: FLAC__StreamEncoderState = 0;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_UNINITIALIZED: FLAC__StreamEncoderState = 1;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_OGG_ERROR: FLAC__StreamEncoderState = 2;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR:
  FLAC__StreamEncoderState = 3;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA:
  FLAC__StreamEncoderState = 4;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_CLIENT_ERROR: FLAC__StreamEncoderState = 5;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_IO_ERROR: FLAC__StreamEncoderState = 6;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_FRAMING_ERROR: FLAC__StreamEncoderState = 7;
pub const FLAC__StreamEncoderState_FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR:
  FLAC__StreamEncoderState = 8;
#[doc = " State values for a FLAC__StreamEncoder.\n\n The encoder's state can be obtained by calling FLAC__stream_encoder_get_state().\n\n If the encoder gets into any other state besides \\c FLAC__STREAM_ENCODER_OK\n or \\c FLAC__STREAM_ENCODER_UNINITIALIZED, it becomes invalid for encoding and\n must be deleted with FLAC__stream_encoder_delete()."]
pub type FLAC__StreamEncoderState = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__StreamEncoderState to a C string.\n\n  Using a FLAC__StreamEncoderState as the index to this array\n  will give the string equivalent.  The contents should not be modified."]
  pub static FLAC__StreamEncoderStateString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_OK:
  FLAC__StreamEncoderInitStatus = 0;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR:
  FLAC__StreamEncoderInitStatus = 1;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER:
  FLAC__StreamEncoderInitStatus = 2;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS:
  FLAC__StreamEncoderInitStatus = 3;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS : FLAC__StreamEncoderInitStatus = 4 ;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE:
  FLAC__StreamEncoderInitStatus = 5;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE:
  FLAC__StreamEncoderInitStatus = 6;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE:
  FLAC__StreamEncoderInitStatus = 7;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER:
  FLAC__StreamEncoderInitStatus = 8;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION : FLAC__StreamEncoderInitStatus = 9 ;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER : FLAC__StreamEncoderInitStatus = 10 ;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE:
  FLAC__StreamEncoderInitStatus = 11;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA:
  FLAC__StreamEncoderInitStatus = 12;
pub const FLAC__StreamEncoderInitStatus_FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED:
  FLAC__StreamEncoderInitStatus = 13;
#[doc = " Possible return values for the FLAC__stream_encoder_init_*() functions."]
pub type FLAC__StreamEncoderInitStatus = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__StreamEncoderInitStatus to a C string.\n\n  Using a FLAC__StreamEncoderInitStatus as the index to this array\n  will give the string equivalent.  The contents should not be modified."]
  pub static FLAC__StreamEncoderInitStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamEncoderReadStatus_FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE:
  FLAC__StreamEncoderReadStatus = 0;
pub const FLAC__StreamEncoderReadStatus_FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM:
  FLAC__StreamEncoderReadStatus = 1;
pub const FLAC__StreamEncoderReadStatus_FLAC__STREAM_ENCODER_READ_STATUS_ABORT:
  FLAC__StreamEncoderReadStatus = 2;
pub const FLAC__StreamEncoderReadStatus_FLAC__STREAM_ENCODER_READ_STATUS_UNSUPPORTED:
  FLAC__StreamEncoderReadStatus = 3;
#[doc = " Return values for the FLAC__StreamEncoder read callback."]
pub type FLAC__StreamEncoderReadStatus = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__StreamEncoderReadStatus to a C string.\n\n  Using a FLAC__StreamEncoderReadStatus as the index to this array\n  will give the string equivalent.  The contents should not be modified."]
  pub static FLAC__StreamEncoderReadStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamEncoderWriteStatus_FLAC__STREAM_ENCODER_WRITE_STATUS_OK:
  FLAC__StreamEncoderWriteStatus = 0;
pub const FLAC__StreamEncoderWriteStatus_FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR:
  FLAC__StreamEncoderWriteStatus = 1;
#[doc = " Return values for the FLAC__StreamEncoder write callback."]
pub type FLAC__StreamEncoderWriteStatus = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__StreamEncoderWriteStatus to a C string.\n\n  Using a FLAC__StreamEncoderWriteStatus as the index to this array\n  will give the string equivalent.  The contents should not be modified."]
  pub static FLAC__StreamEncoderWriteStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamEncoderSeekStatus_FLAC__STREAM_ENCODER_SEEK_STATUS_OK:
  FLAC__StreamEncoderSeekStatus = 0;
pub const FLAC__StreamEncoderSeekStatus_FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR:
  FLAC__StreamEncoderSeekStatus = 1;
pub const FLAC__StreamEncoderSeekStatus_FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED:
  FLAC__StreamEncoderSeekStatus = 2;
#[doc = " Return values for the FLAC__StreamEncoder seek callback."]
pub type FLAC__StreamEncoderSeekStatus = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__StreamEncoderSeekStatus to a C string.\n\n  Using a FLAC__StreamEncoderSeekStatus as the index to this array\n  will give the string equivalent.  The contents should not be modified."]
  pub static FLAC__StreamEncoderSeekStatusString: [*const ::std::os::raw::c_char; 0usize];
}
pub const FLAC__StreamEncoderTellStatus_FLAC__STREAM_ENCODER_TELL_STATUS_OK:
  FLAC__StreamEncoderTellStatus = 0;
pub const FLAC__StreamEncoderTellStatus_FLAC__STREAM_ENCODER_TELL_STATUS_ERROR:
  FLAC__StreamEncoderTellStatus = 1;
pub const FLAC__StreamEncoderTellStatus_FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED:
  FLAC__StreamEncoderTellStatus = 2;
#[doc = " Return values for the FLAC__StreamEncoder tell callback."]
pub type FLAC__StreamEncoderTellStatus = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Maps a FLAC__StreamEncoderTellStatus to a C string.\n\n  Using a FLAC__StreamEncoderTellStatus as the index to this array\n  will give the string equivalent.  The contents should not be modified."]
  pub static FLAC__StreamEncoderTellStatusString: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = " class FLAC__StreamEncoder\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamEncoderProtected {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamEncoderPrivate {
  _unused: [u8; 0],
}
#[doc = " The opaque structure definition for the stream encoder type.\n  See the \\link flac_stream_encoder stream encoder module \\endlink\n  for a detailed description."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLAC__StreamEncoder {
  pub protected_: *mut FLAC__StreamEncoderProtected,
  pub private_: *mut FLAC__StreamEncoderPrivate,
}
#[test]
fn bindgen_test_layout_FLAC__StreamEncoder() {
  const UNINIT: ::std::mem::MaybeUninit<FLAC__StreamEncoder> = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
    ::std::mem::size_of::<FLAC__StreamEncoder>(),
    16usize,
    concat!("Size of: ", stringify!(FLAC__StreamEncoder))
  );
  assert_eq!(
    ::std::mem::align_of::<FLAC__StreamEncoder>(),
    8usize,
    concat!("Alignment of ", stringify!(FLAC__StreamEncoder))
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).protected_) as usize - ptr as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamEncoder),
      "::",
      stringify!(protected_)
    )
  );
  assert_eq!(
    unsafe { ::std::ptr::addr_of!((*ptr).private_) as usize - ptr as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(FLAC__StreamEncoder),
      "::",
      stringify!(private_)
    )
  );
}
#[doc = " Signature for the read callback.\n\n  A function pointer matching this signature must be passed to\n  FLAC__stream_encoder_init_ogg_stream() if seeking is supported.\n  The supplied function will be called when the encoder needs to read back\n  encoded data.  This happens during the metadata callback, when the encoder\n  has to read, modify, and rewrite the metadata (e.g. seekpoints) gathered\n  while encoding.  The address of the buffer to be filled is supplied, along\n  with the number of bytes the buffer can hold.  The callback may choose to\n  supply less data and modify the byte count but must be careful not to\n  overflow the buffer.  The callback then returns a status code chosen from\n  FLAC__StreamEncoderReadStatus.\n\n Here is an example of a read callback for stdio streams:\n \\code\n FLAC__StreamEncoderReadStatus read_cb(const FLAC__StreamEncoder *encoder, FLAC__byte buffer[], size_t *bytes, void *client_data)\n {\n   FILE *file = ((MyClientData*)client_data)->file;\n   if(*bytes > 0) {\n     *bytes = fread(buffer, sizeof(FLAC__byte), *bytes, file);\n     if(ferror(file))\n       return FLAC__STREAM_ENCODER_READ_STATUS_ABORT;\n     else if(*bytes == 0)\n       return FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM;\n     else\n       return FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE;\n   }\n   else\n     return FLAC__STREAM_ENCODER_READ_STATUS_ABORT;\n }\n \\endcode\n\n \\note In general, FLAC__StreamEncoder functions which change the\n state should not be called on the \\a encoder while in the callback.\n\n \\param  encoder  The encoder instance calling the callback.\n \\param  buffer   A pointer to a location for the callee to store\n                  data to be encoded.\n \\param  bytes    A pointer to the size of the buffer.  On entry\n                  to the callback, it contains the maximum number\n                  of bytes that may be stored in \\a buffer.  The\n                  callee must set it to the actual number of bytes\n                  stored (0 in case of error or end-of-stream) before\n                  returning.\n \\param  client_data  The callee's client data set through\n                      FLAC__stream_encoder_set_client_data().\n \\retval FLAC__StreamEncoderReadStatus\n    The callee's return status."]
pub type FLAC__StreamEncoderReadCallback = ::std::option::Option<
  unsafe extern "C" fn(
    encoder: *const FLAC__StreamEncoder,
    buffer: *mut FLAC__byte,
    bytes: *mut usize,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamEncoderReadStatus,
>;
#[doc = " Signature for the write callback.\n\n  A function pointer matching this signature must be passed to\n  FLAC__stream_encoder_init*_stream().  The supplied function will be called\n  by the encoder anytime there is raw encoded data ready to write.  It may\n  include metadata mixed with encoded audio frames and the data is not\n  guaranteed to be aligned on frame or metadata block boundaries.\n\n  The only duty of the callback is to write out the \\a bytes worth of data\n  in \\a buffer to the current position in the output stream.  The arguments\n  \\a samples and \\a current_frame are purely informational.  If \\a samples\n  is greater than \\c 0, then \\a current_frame will hold the current frame\n  number that is being written; otherwise it indicates that the write\n  callback is being called to write metadata.\n\n \\note\n Unlike when writing to native FLAC, when writing to Ogg FLAC the\n write callback will be called twice when writing each audio\n frame; once for the page header, and once for the page body.\n When writing the page header, the \\a samples argument to the\n write callback will be \\c 0.\n\n \\note In general, FLAC__StreamEncoder functions which change the\n state should not be called on the \\a encoder while in the callback.\n\n \\param  encoder  The encoder instance calling the callback.\n \\param  buffer   An array of encoded data of length \\a bytes.\n \\param  bytes    The byte length of \\a buffer.\n \\param  samples  The number of samples encoded by \\a buffer.\n                  \\c 0 has a special meaning; see above.\n \\param  current_frame  The number of the current frame being encoded.\n \\param  client_data  The callee's client data set through\n                      FLAC__stream_encoder_init_*().\n \\retval FLAC__StreamEncoderWriteStatus\n    The callee's return status."]
pub type FLAC__StreamEncoderWriteCallback = ::std::option::Option<
  unsafe extern "C" fn(
    encoder: *const FLAC__StreamEncoder,
    buffer: *const FLAC__byte,
    bytes: usize,
    samples: u32,
    current_frame: u32,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamEncoderWriteStatus,
>;
#[doc = " Signature for the seek callback.\n\n  A function pointer matching this signature may be passed to\n  FLAC__stream_encoder_init*_stream().  The supplied function will be called\n  when the encoder needs to seek the output stream.  The encoder will pass\n  the absolute byte offset to seek to, 0 meaning the beginning of the stream.\n\n Here is an example of a seek callback for stdio streams:\n \\code\n FLAC__StreamEncoderSeekStatus seek_cb(const FLAC__StreamEncoder *encoder, FLAC__uint64 absolute_byte_offset, void *client_data)\n {\n   FILE *file = ((MyClientData*)client_data)->file;\n   if(file == stdin)\n     return FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED;\n   else if(fseeko(file, (off_t)absolute_byte_offset, SEEK_SET) < 0)\n     return FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR;\n   else\n     return FLAC__STREAM_ENCODER_SEEK_STATUS_OK;\n }\n \\endcode\n\n \\note In general, FLAC__StreamEncoder functions which change the\n state should not be called on the \\a encoder while in the callback.\n\n \\param  encoder  The encoder instance calling the callback.\n \\param  absolute_byte_offset  The offset from the beginning of the stream\n                               to seek to.\n \\param  client_data  The callee's client data set through\n                      FLAC__stream_encoder_init_*().\n \\retval FLAC__StreamEncoderSeekStatus\n    The callee's return status."]
pub type FLAC__StreamEncoderSeekCallback = ::std::option::Option<
  unsafe extern "C" fn(
    encoder: *const FLAC__StreamEncoder,
    absolute_byte_offset: FLAC__uint64,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamEncoderSeekStatus,
>;
#[doc = " Signature for the tell callback.\n\n  A function pointer matching this signature may be passed to\n  FLAC__stream_encoder_init*_stream().  The supplied function will be called\n  when the encoder needs to know the current position of the output stream.\n\n \\warning\n The callback must return the true current byte offset of the output to\n which the encoder is writing.  If you are buffering the output, make\n sure and take this into account.  If you are writing directly to a\n FILE* from your write callback, ftell() is sufficient.  If you are\n writing directly to a file descriptor from your write callback, you\n can use lseek(fd, SEEK_CUR, 0).  The encoder may later seek back to\n these points to rewrite metadata after encoding.\n\n Here is an example of a tell callback for stdio streams:\n \\code\n FLAC__StreamEncoderTellStatus tell_cb(const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_byte_offset, void *client_data)\n {\n   FILE *file = ((MyClientData*)client_data)->file;\n   off_t pos;\n   if(file == stdin)\n     return FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED;\n   else if((pos = ftello(file)) < 0)\n     return FLAC__STREAM_ENCODER_TELL_STATUS_ERROR;\n   else {\n     *absolute_byte_offset = (FLAC__uint64)pos;\n     return FLAC__STREAM_ENCODER_TELL_STATUS_OK;\n   }\n }\n \\endcode\n\n \\note In general, FLAC__StreamEncoder functions which change the\n state should not be called on the \\a encoder while in the callback.\n\n \\param  encoder  The encoder instance calling the callback.\n \\param  absolute_byte_offset  The address at which to store the current\n                               position of the output.\n \\param  client_data  The callee's client data set through\n                      FLAC__stream_encoder_init_*().\n \\retval FLAC__StreamEncoderTellStatus\n    The callee's return status."]
pub type FLAC__StreamEncoderTellCallback = ::std::option::Option<
  unsafe extern "C" fn(
    encoder: *const FLAC__StreamEncoder,
    absolute_byte_offset: *mut FLAC__uint64,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamEncoderTellStatus,
>;
#[doc = " Signature for the metadata callback.\n\n  A function pointer matching this signature may be passed to\n  FLAC__stream_encoder_init*_stream().  The supplied function will be called\n  once at the end of encoding with the populated STREAMINFO structure.  This\n  is so the client can seek back to the beginning of the file and write the\n  STREAMINFO block with the correct statistics after encoding (like\n  minimum/maximum frame size and total samples).\n\n \\note In general, FLAC__StreamEncoder functions which change the\n state should not be called on the \\a encoder while in the callback.\n\n \\param  encoder      The encoder instance calling the callback.\n \\param  metadata     The final populated STREAMINFO block.\n \\param  client_data  The callee's client data set through\n                      FLAC__stream_encoder_init_*()."]
pub type FLAC__StreamEncoderMetadataCallback = ::std::option::Option<
  unsafe extern "C" fn(
    encoder: *const FLAC__StreamEncoder,
    metadata: *const FLAC__StreamMetadata,
    client_data: *mut ::std::os::raw::c_void,
  ),
>;
#[doc = " Signature for the progress callback.\n\n  A function pointer matching this signature may be passed to\n  FLAC__stream_encoder_init*_file() or FLAC__stream_encoder_init*_FILE().\n  The supplied function will be called when the encoder has finished\n  writing a frame.  The \\c total_frames_estimate argument to the\n  callback will be based on the value from\n  FLAC__stream_encoder_set_total_samples_estimate().\n\n \\note In general, FLAC__StreamEncoder functions which change the\n state should not be called on the \\a encoder while in the callback.\n\n \\param  encoder          The encoder instance calling the callback.\n \\param  bytes_written    Bytes written so far.\n \\param  samples_written  Samples written so far.\n \\param  frames_written   Frames written so far.\n \\param  total_frames_estimate  The estimate of the total number of\n                                frames to be written.\n \\param  client_data      The callee's client data set through\n                          FLAC__stream_encoder_init_*()."]
pub type FLAC__StreamEncoderProgressCallback = ::std::option::Option<
  unsafe extern "C" fn(
    encoder: *const FLAC__StreamEncoder,
    bytes_written: FLAC__uint64,
    samples_written: FLAC__uint64,
    frames_written: u32,
    total_frames_estimate: u32,
    client_data: *mut ::std::os::raw::c_void,
  ),
>;
extern "C" {
  #[doc = " Create a new stream encoder instance.  The instance is created with\n  default settings; see the individual FLAC__stream_encoder_set_*()\n  functions for each setting's default.\n\n \\retval FLAC__StreamEncoder*\n    \\c NULL if there was an error allocating memory, else the new instance."]
  pub fn FLAC__stream_encoder_new() -> *mut FLAC__StreamEncoder;
}
extern "C" {
  #[doc = " Free an encoder instance.  Deletes the object pointed to by \\a encoder.\n\n \\param encoder  A pointer to an existing encoder.\n \\assert\n    \\code encoder != NULL \\endcode"]
  pub fn FLAC__stream_encoder_delete(encoder: *mut FLAC__StreamEncoder);
}
extern "C" {
  #[doc = " Set the serial number for the FLAC stream to use in the Ogg container.\n\n \\note\n This does not need to be set for native FLAC encoding.\n\n \\note\n It is recommended to set a serial number explicitly as the default of '0'\n may collide with other streams.\n\n \\default \\c 0\n \\param  encoder        An encoder instance to set.\n \\param  serial_number  See above.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_ogg_serial_number(
    encoder: *mut FLAC__StreamEncoder,
    serial_number: ::std::os::raw::c_long,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set the \"verify\" flag.  If \\c true, the encoder will verify it's own\n  encoded output by feeding it through an internal decoder and comparing\n  the original signal against the decoded signal.  If a mismatch occurs,\n  the process call will return \\c false.  Note that this will slow the\n  encoding process by the extra time required for decoding and comparison.\n\n \\default \\c false\n \\param  encoder  An encoder instance to set.\n \\param  value    Flag value (see above).\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_verify(
    encoder: *mut FLAC__StreamEncoder,
    value: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set the <A HREF=\"https://xiph.org/flac/format.html#subset\">Subset</A> flag.  If \\c true,\n  the encoder will comply with the Subset and will check the\n  settings during FLAC__stream_encoder_init_*() to see if all settings\n  comply.  If \\c false, the settings may take advantage of the full\n  range that the format allows.\n\n  Make sure you know what it entails before setting this to \\c false.\n\n \\default \\c true\n \\param  encoder  An encoder instance to set.\n \\param  value    Flag value (see above).\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_streamable_subset(
    encoder: *mut FLAC__StreamEncoder,
    value: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set the number of channels to be encoded.\n\n \\default \\c 2\n \\param  encoder  An encoder instance to set.\n \\param  value    See above.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_channels(
    encoder: *mut FLAC__StreamEncoder,
    value: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set the sample resolution of the input to be encoded.\n\n \\warning\n Do not feed the encoder data that is wider than the value you\n set here or you will generate an invalid stream.\n\n \\default \\c 16\n \\param  encoder  An encoder instance to set.\n \\param  value    See above.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_bits_per_sample(
    encoder: *mut FLAC__StreamEncoder,
    value: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set the sample rate (in Hz) of the input to be encoded.\n\n \\default \\c 44100\n \\param  encoder  An encoder instance to set.\n \\param  value    See above.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_sample_rate(
    encoder: *mut FLAC__StreamEncoder,
    value: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set the compression level\n\n The compression level is roughly proportional to the amount of effort\n the encoder expends to compress the file.  A higher level usually\n means more computation but higher compression.  The default level is\n suitable for most applications.\n\n Currently the levels range from \\c 0 (fastest, least compression) to\n \\c 8 (slowest, most compression).  A value larger than \\c 8 will be\n treated as \\c 8.\n\n This function automatically calls the following other \\c _set_\n functions with appropriate values, so the client does not need to\n unless it specifically wants to override them:\n - FLAC__stream_encoder_set_do_mid_side_stereo()\n - FLAC__stream_encoder_set_loose_mid_side_stereo()\n - FLAC__stream_encoder_set_apodization()\n - FLAC__stream_encoder_set_max_lpc_order()\n - FLAC__stream_encoder_set_qlp_coeff_precision()\n - FLAC__stream_encoder_set_do_qlp_coeff_prec_search()\n - FLAC__stream_encoder_set_do_escape_coding()\n - FLAC__stream_encoder_set_do_exhaustive_model_search()\n - FLAC__stream_encoder_set_min_residual_partition_order()\n - FLAC__stream_encoder_set_max_residual_partition_order()\n - FLAC__stream_encoder_set_rice_parameter_search_dist()\n\n The actual values set for each level are:\n <table>\n <tr>\n  <td><b>level</b></td>\n  <td>do mid-side stereo</td>\n  <td>loose mid-side stereo</td>\n  <td>apodization</td>\n  <td>max lpc order</td>\n  <td>qlp coeff precision</td>\n  <td>qlp coeff prec search</td>\n  <td>escape coding</td>\n  <td>exhaustive model search</td>\n  <td>min residual partition order</td>\n  <td>max residual partition order</td>\n  <td>rice parameter search dist</td>\n </tr>\n <tr>  <td><b>0</b></td> <td>false</td> <td>false</td> <td>tukey(0.5)</td>         <td>0</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>3</td> <td>0</td> </tr>\n <tr>  <td><b>1</b></td> <td>true</td>  <td>true</td>  <td>tukey(0.5)</td>         <td>0</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>3</td> <td>0</td> </tr>\n <tr>  <td><b>2</b></td> <td>true</td>  <td>false</td> <td>tukey(0.5)</td>         <td>0</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>3</td> <td>0</td> </tr>\n <tr>  <td><b>3</b></td> <td>false</td> <td>false</td> <td>tukey(0.5)</td>         <td>6</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>4</td> <td>0</td> </tr>\n <tr>  <td><b>4</b></td> <td>true</td>  <td>true</td>  <td>tukey(0.5)</td>         <td>8</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>4</td> <td>0</td> </tr>\n <tr>  <td><b>5</b></td> <td>true</td>  <td>false</td> <td>tukey(0.5)</td>         <td>8</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>5</td> <td>0</td> </tr>\n <tr>  <td><b>6</b></td> <td>true</td>  <td>false</td> <td>subdivide_tukey(2)</td> <td>8</td>  <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>6</td> <td>0</td> </tr>\n <tr>  <td><b>7</b></td> <td>true</td>  <td>false</td> <td>subdivide_tukey(2)</td> <td>12</td> <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>6</td> <td>0</td> </tr>\n <tr>  <td><b>8</b></td> <td>true</td>  <td>false</td> <td>subdivide_tukey(3)</td> <td>12</td> <td>0</td> <td>false</td> <td>false</td> <td>false</td> <td>0</td> <td>6</td> <td>0</td> </tr>\n </table>\n\n \\default \\c 5\n \\param  encoder  An encoder instance to set.\n \\param  value    See above.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_compression_level(
    encoder: *mut FLAC__StreamEncoder,
    value: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set the blocksize to use while encoding.\n\n The number of samples to use per frame.  Use \\c 0 to let the encoder\n estimate a blocksize; this is usually best.\n\n \\default \\c 0\n \\param  encoder  An encoder instance to set.\n \\param  value    See above.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_blocksize(
    encoder: *mut FLAC__StreamEncoder,
    value: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set to \\c true to enable mid-side encoding on stereo input.  The\n  number of channels must be 2 for this to have any effect.  Set to\n  \\c false to use only independent channel coding.\n\n \\default \\c true\n \\param  encoder  An encoder instance to set.\n \\param  value    Flag value (see above).\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_do_mid_side_stereo(
    encoder: *mut FLAC__StreamEncoder,
    value: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set to \\c true to enable adaptive switching between mid-side and\n  left-right encoding on stereo input.  Set to \\c false to use\n  exhaustive searching.  Setting this to \\c true requires\n  FLAC__stream_encoder_set_do_mid_side_stereo() to also be set to\n  \\c true in order to have any effect.\n\n \\default \\c false\n \\param  encoder  An encoder instance to set.\n \\param  value    Flag value (see above).\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_loose_mid_side_stereo(
    encoder: *mut FLAC__StreamEncoder,
    value: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Sets the apodization function(s) the encoder will use when windowing\n  audio data for LPC analysis.\n\n The \\a specification is a plain ASCII string which specifies exactly\n which functions to use.  There may be more than one (up to 32),\n separated by \\c ';' characters.  Some functions take one or more\n comma-separated arguments in parentheses.\n\n The available functions are \\c bartlett, \\c bartlett_hann,\n \\c blackman, \\c blackman_harris_4term_92db, \\c connes, \\c flattop,\n \\c gauss(STDDEV), \\c hamming, \\c hann, \\c kaiser_bessel, \\c nuttall,\n \\c rectangle, \\c triangle, \\c tukey(P), \\c partial_tukey(n[/ov[/P]]),\n \\c punchout_tukey(n[/ov[/P]]), \\c subdivide_tukey(n[/P]), \\c welch.\n\n For \\c gauss(STDDEV), STDDEV specifies the standard deviation\n (0<STDDEV<=0.5).\n\n For \\c tukey(P), P specifies the fraction of the window that is\n tapered (0<=P<=1).  P=0 corresponds to \\c rectangle and P=1\n corresponds to \\c hann.\n\n Specifying \\c partial_tukey or \\c punchout_tukey works a little\n different. These do not specify a single apodization function, but\n a series of them with some overlap. partial_tukey specifies a series\n of small windows (all treated separately) while punchout_tukey\n specifies a series of windows that have a hole in them. In this way,\n the predictor is constructed with only a part of the block, which\n helps in case a block consists of dissimilar parts.\n\n The three parameters that can be specified for the functions are\n n, ov and P. n is the number of functions to add, ov is the overlap\n of the windows in case of partial_tukey and the overlap in the gaps\n in case of punchout_tukey. P is the fraction of the window that is\n tapered, like with a regular tukey window. The function can be\n specified with only a number, a number and an overlap, or a number\n an overlap and a P, for example, partial_tukey(3), partial_tukey(3/0.3)\n and partial_tukey(3/0.3/0.5) are all valid. ov should be smaller than 1\n and can be negative.\n\n subdivide_tukey(n) is a more efficient reimplementation of\n partial_tukey and punchout_tukey taken together, recycling as much data\n as possible. It combines all possible non-redundant partial_tukey(n)\n and punchout_tukey(n) up to the n specified. Specifying\n subdivide_tukey(3) is equivalent to specifying tukey, partial_tukey(2),\n partial_tukey(3) and punchout_tukey(3), specifying subdivide_tukey(5)\n equivalently adds partial_tukey(4), punchout_tukey(4), partial_tukey(5)\n and punchout_tukey(5). To be able to reuse data as much as possible,\n the tukey taper is taken equal for all windows, and the P specified is\n applied for the smallest used window. In other words,\n subdivide_tukey(2/0.5) results in a taper equal to that of tukey(0.25)\n and subdivide_tukey(5) in a taper equal to that of tukey(0.1). The\n default P for subdivide_tukey when none is specified is 0.5.\n\n Example specifications are \\c \"blackman\" or\n \\c \"hann;triangle;tukey(0.5);tukey(0.25);tukey(0.125)\"\n\n Any function that is specified erroneously is silently dropped.  Up\n to 32 functions are kept, the rest are dropped.  If the specification\n is empty the encoder defaults to \\c \"tukey(0.5)\".\n\n When more than one function is specified, then for every subframe the\n encoder will try each of them separately and choose the window that\n results in the smallest compressed subframe.\n\n Note that each function specified causes the encoder to occupy a\n floating point array in which to store the window. Also note that the\n values of P, STDDEV and ov are locale-specific, so if the comma\n separator specified by the locale is a comma, a comma should be used.\n A locale-independent way is to specify using scientific notation,\n e.g. 5e-1 instad of 0.5 or 0,5.\n\n \\default \\c \"tukey(0.5)\"\n \\param  encoder        An encoder instance to set.\n \\param  specification  See above.\n \\assert\n    \\code encoder != NULL \\endcode\n    \\code specification != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_apodization(
    encoder: *mut FLAC__StreamEncoder,
    specification: *const ::std::os::raw::c_char,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set the maximum LPC order, or \\c 0 to use only the fixed predictors.\n\n \\default \\c 8\n \\param  encoder  An encoder instance to set.\n \\param  value    See above.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_max_lpc_order(
    encoder: *mut FLAC__StreamEncoder,
    value: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set the precision, in bits, of the quantized linear predictor\n  coefficients, or \\c 0 to let the encoder select it based on the\n  blocksize.\n\n \\default \\c 0\n \\param  encoder  An encoder instance to set.\n \\param  value    See above.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_qlp_coeff_precision(
    encoder: *mut FLAC__StreamEncoder,
    value: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set to \\c false to use only the specified quantized linear predictor\n  coefficient precision, or \\c true to search neighboring precision\n  values and use the best one.\n\n \\default \\c false\n \\param  encoder  An encoder instance to set.\n \\param  value    See above.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_do_qlp_coeff_prec_search(
    encoder: *mut FLAC__StreamEncoder,
    value: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Deprecated.  Setting this value has no effect.\n\n \\default \\c false\n \\param  encoder  An encoder instance to set.\n \\param  value    See above.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_do_escape_coding(
    encoder: *mut FLAC__StreamEncoder,
    value: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set to \\c false to let the encoder estimate the best model order\n  based on the residual signal energy, or \\c true to force the\n  encoder to evaluate all order models and select the best.\n\n \\default \\c false\n \\param  encoder  An encoder instance to set.\n \\param  value    See above.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_do_exhaustive_model_search(
    encoder: *mut FLAC__StreamEncoder,
    value: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set the minimum partition order to search when coding the residual.\n  This is used in tandem with\n  FLAC__stream_encoder_set_max_residual_partition_order().\n\n  The partition order determines the context size in the residual.\n  The context size will be approximately <tt>blocksize / (2 ^ order)</tt>.\n\n  Set both min and max values to \\c 0 to force a single context,\n  whose Rice parameter is based on the residual signal variance.\n  Otherwise, set a min and max order, and the encoder will search\n  all orders, using the mean of each context for its Rice parameter,\n  and use the best.\n\n \\default \\c 0\n \\param  encoder  An encoder instance to set.\n \\param  value    See above.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_min_residual_partition_order(
    encoder: *mut FLAC__StreamEncoder,
    value: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set the maximum partition order to search when coding the residual.\n  This is used in tandem with\n  FLAC__stream_encoder_set_min_residual_partition_order().\n\n  The partition order determines the context size in the residual.\n  The context size will be approximately <tt>blocksize / (2 ^ order)</tt>.\n\n  Set both min and max values to \\c 0 to force a single context,\n  whose Rice parameter is based on the residual signal variance.\n  Otherwise, set a min and max order, and the encoder will search\n  all orders, using the mean of each context for its Rice parameter,\n  and use the best.\n\n \\default \\c 5\n \\param  encoder  An encoder instance to set.\n \\param  value    See above.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_max_residual_partition_order(
    encoder: *mut FLAC__StreamEncoder,
    value: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set the maximum number of threads to use during encoding.\n  Set to a value different than 1 to enable multithreaded encoding.\n\n  Note that enabling multithreading encoding (i.e., setting a value\n  different than 1) results in the behaviour of\n  FLAC__stream_encoder_finish(), FLAC__stream_encoder_process(),\n  FLAC__stream_encoder_process_interleaved() subtly changing.\n  For example, calling one of the process functions with enough\n  samples to fill a block might not always result in a call to\n  the write callback with a frame coding these samples. Instead,\n  blocks with samples are distributed among worker threads,\n  meaning that the first few calls to those functions will\n  return very quickly, while later calls might block if all\n  threads are occupied. Also, certain calls to the process\n  functions will results in several calls to the write callback,\n  while subsequent calls might again return very quickly with no\n  calls to the write callback.\n\n  Also, a call to FLAC__stream_encoder_finish() blocks while\n  waiting for all threads to finish, and therefore might take much\n  longer than when not multithreading and result in multiple calls\n  to the write callback.\n\n  Calls to the write callback are guaranteed to be in the correct\n  order.\n\n  Currently, passing a value of 0 is synonymous with a value of 1,\n  but this might change in the future.\n\n \\default \\c 1\n \\param  encoder  An encoder instance to set.\n \\param  value    See above.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval uint32_t\n    - \\c FLAC__STREAM_ENCODER_SET_NUM_THREADS_OK if the number of threads was set correctly,\n    - \\c FLAC__STREAM_ENCODER_SET_NUM_THREADS_NOT_COMPILED_WITH_MULTITHREADING_ENABLED when\n    multithreading was not enabled at compilation,\n    - \\c FLAC__STREAM_ENCODER_SET_NUM_THREADS_ALREADY_INITIALIZED when the encoder was\n    already initialized,\n    - \\c FLAC__STREAM_ENCODER_SET_NUM_THREADS_TOO_MANY_THREADS when\n    the number of threads was larger than the maximum allowed number of threads (currently\n    128)."]
  pub fn FLAC__stream_encoder_set_num_threads(encoder: *mut FLAC__StreamEncoder, value: u32)
    -> u32;
}
extern "C" {
  #[doc = " Deprecated.  Setting this value has no effect.\n\n \\default \\c 0\n \\param  encoder  An encoder instance to set.\n \\param  value    See above.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_rice_parameter_search_dist(
    encoder: *mut FLAC__StreamEncoder,
    value: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set an estimate of the total samples that will be encoded.\n  This is merely an estimate and may be set to \\c 0 if unknown.\n  This value will be written to the STREAMINFO block before encoding,\n  and can remove the need for the caller to rewrite the value later\n  if the value is known before encoding.\n\n \\default \\c 0\n \\param  encoder  An encoder instance to set.\n \\param  value    See above.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_total_samples_estimate(
    encoder: *mut FLAC__StreamEncoder,
    value: FLAC__uint64,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set the metadata blocks to be emitted to the stream before encoding.\n  A value of \\c NULL, \\c 0 implies no metadata; otherwise, supply an\n  array of pointers to metadata blocks.  The array is non-const since\n  the encoder may need to change the \\a is_last flag inside them, and\n  in some cases update seek point offsets.  Otherwise, the encoder will\n  not modify or free the blocks.  It is up to the caller to free the\n  metadata blocks after encoding finishes.\n\n \\note\n The encoder stores only copies of the pointers in the \\a metadata array;\n the metadata blocks themselves must survive at least until after\n FLAC__stream_encoder_finish() returns.  Do not free the blocks until then.\n\n \\note\n The STREAMINFO block is always written and no STREAMINFO block may\n occur in the supplied array.\n\n \\note\n By default the encoder does not create a SEEKTABLE.  If one is supplied\n in the \\a metadata array, but the client has specified that it does not\n support seeking, then the SEEKTABLE will be written verbatim.  However\n by itself this is not very useful as the client will not know the stream\n offsets for the seekpoints ahead of time.  In order to get a proper\n seektable the client must support seeking.  See next note.\n\n \\note\n SEEKTABLE blocks are handled specially.  Since you will not know\n the values for the seek point stream offsets, you should pass in\n a SEEKTABLE 'template', that is, a SEEKTABLE object with the\n required sample numbers (or placeholder points), with \\c 0 for the\n \\a frame_samples and \\a stream_offset fields for each point.  If the\n client has specified that it supports seeking by providing a seek\n callback to FLAC__stream_encoder_init_stream() or both seek AND read\n callback to FLAC__stream_encoder_init_ogg_stream() (or by using\n FLAC__stream_encoder_init*_file() or FLAC__stream_encoder_init*_FILE()),\n then while it is encoding the encoder will fill the stream offsets in\n for you and when encoding is finished, it will seek back and write the\n real values into the SEEKTABLE block in the stream.  There are helper\n routines for manipulating seektable template blocks; see metadata.h:\n FLAC__metadata_object_seektable_template_*().  If the client does\n not support seeking, the SEEKTABLE will have inaccurate offsets which\n will slow down or remove the ability to seek in the FLAC stream.\n\n \\note\n The encoder instance \\b will modify the first \\c SEEKTABLE block\n as it transforms the template to a valid seektable while encoding,\n but it is still up to the caller to free all metadata blocks after\n encoding.\n\n \\note\n A VORBIS_COMMENT block may be supplied.  The vendor string in it\n will be ignored.  libFLAC will use it's own vendor string. libFLAC\n will not modify the passed-in VORBIS_COMMENT's vendor string, it\n will simply write it's own into the stream.  If no VORBIS_COMMENT\n block is present in the \\a metadata array, libFLAC will write an\n empty one, containing only the vendor string.\n\n \\note The Ogg FLAC mapping requires that the VORBIS_COMMENT block be\n the second metadata block of the stream.  The encoder already supplies\n the STREAMINFO block automatically.  If \\a metadata does not contain a\n VORBIS_COMMENT block, the encoder will supply that too.  Otherwise, if\n \\a metadata does contain a VORBIS_COMMENT block and it is not the\n first, the init function will reorder \\a metadata by moving the\n VORBIS_COMMENT block to the front; the relative ordering of the other\n blocks will remain as they were.\n\n \\note The Ogg FLAC mapping limits the number of metadata blocks per\n stream to \\c 65535.  If \\a num_blocks exceeds this the function will\n return \\c false.\n\n \\default \\c NULL, 0\n \\param  encoder     An encoder instance to set.\n \\param  metadata    See above.\n \\param  num_blocks  See above.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true.\n    \\c false if the encoder is already initialized, or if\n    \\a num_blocks > 65535 if encoding to Ogg FLAC, else \\c true."]
  pub fn FLAC__stream_encoder_set_metadata(
    encoder: *mut FLAC__StreamEncoder,
    metadata: *mut *mut FLAC__StreamMetadata,
    num_blocks: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Set to \\c true to make the encoder not output frames which contain\n  only constant subframes. This is beneficial for streaming\n  applications: very small frames can cause problems with buffering\n  as bitrates can drop as low 1kbit/s for CDDA audio encoded within\n  subset. The minimum bitrate for a FLAC file encoded with this\n  function used is raised to 1bit/sample (i.e. 48kbit/s for 48kHz\n  material).\n\n \\default \\c false\n \\param  encoder  An encoder instance to set.\n \\param  value    Flag value (see above).\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if the encoder is already initialized, else \\c true."]
  pub fn FLAC__stream_encoder_set_limit_min_bitrate(
    encoder: *mut FLAC__StreamEncoder,
    value: FLAC__bool,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Get the current encoder state.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__StreamEncoderState\n    The current encoder state."]
  pub fn FLAC__stream_encoder_get_state(
    encoder: *const FLAC__StreamEncoder,
  ) -> FLAC__StreamEncoderState;
}
extern "C" {
  #[doc = " Get the state of the verify stream decoder.\n  Useful when the stream encoder state is\n  \\c FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__StreamDecoderState\n    The verify stream decoder state."]
  pub fn FLAC__stream_encoder_get_verify_decoder_state(
    encoder: *const FLAC__StreamEncoder,
  ) -> FLAC__StreamDecoderState;
}
extern "C" {
  #[doc = " Get the current encoder state as a C string.\n  This version automatically resolves\n  \\c FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR by getting the\n  verify decoder's state.\n\n \\param  encoder  A encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval const char *\n    The encoder state as a C string.  Do not modify the contents."]
  pub fn FLAC__stream_encoder_get_resolved_state_string(
    encoder: *const FLAC__StreamEncoder,
  ) -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Get relevant values about the nature of a verify decoder error.\n  Useful when the stream encoder state is\n  \\c FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR.  The arguments should\n  be addresses in which the stats will be returned, or NULL if value\n  is not desired.\n\n \\param  encoder  An encoder instance to query.\n \\param  absolute_sample  The absolute sample number of the mismatch.\n \\param  frame_number  The number of the frame in which the mismatch occurred.\n \\param  channel       The channel in which the mismatch occurred.\n \\param  sample        The number of the sample (relative to the frame) in\n                       which the mismatch occurred.\n \\param  expected      The expected value for the sample in question.\n \\param  got           The actual value returned by the decoder.\n \\assert\n    \\code encoder != NULL \\endcode"]
  pub fn FLAC__stream_encoder_get_verify_decoder_error_stats(
    encoder: *const FLAC__StreamEncoder,
    absolute_sample: *mut FLAC__uint64,
    frame_number: *mut u32,
    channel: *mut u32,
    sample: *mut u32,
    expected: *mut FLAC__int32,
    got: *mut FLAC__int32,
  );
}
extern "C" {
  #[doc = " Get the \"verify\" flag.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    See FLAC__stream_encoder_set_verify()."]
  pub fn FLAC__stream_encoder_get_verify(encoder: *const FLAC__StreamEncoder) -> FLAC__bool;
}
extern "C" {
  #[doc = " Get the <A HREF=\"https://xiph.org/flac/format.html#subset\">Subset</A> flag.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    See FLAC__stream_encoder_set_streamable_subset()."]
  pub fn FLAC__stream_encoder_get_streamable_subset(
    encoder: *const FLAC__StreamEncoder,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Get the number of input channels being processed.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval uint32_t\n    See FLAC__stream_encoder_set_channels()."]
  pub fn FLAC__stream_encoder_get_channels(encoder: *const FLAC__StreamEncoder) -> u32;
}
extern "C" {
  #[doc = " Get the input sample resolution setting.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval uint32_t\n    See FLAC__stream_encoder_set_bits_per_sample()."]
  pub fn FLAC__stream_encoder_get_bits_per_sample(encoder: *const FLAC__StreamEncoder) -> u32;
}
extern "C" {
  #[doc = " Get the input sample rate setting.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval uint32_t\n    See FLAC__stream_encoder_set_sample_rate()."]
  pub fn FLAC__stream_encoder_get_sample_rate(encoder: *const FLAC__StreamEncoder) -> u32;
}
extern "C" {
  #[doc = " Get the blocksize setting.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval uint32_t\n    See FLAC__stream_encoder_set_blocksize()."]
  pub fn FLAC__stream_encoder_get_blocksize(encoder: *const FLAC__StreamEncoder) -> u32;
}
extern "C" {
  #[doc = " Get the \"mid/side stereo coding\" flag.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    See FLAC__stream_encoder_get_do_mid_side_stereo()."]
  pub fn FLAC__stream_encoder_get_do_mid_side_stereo(
    encoder: *const FLAC__StreamEncoder,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Get the \"adaptive mid/side switching\" flag.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    See FLAC__stream_encoder_set_loose_mid_side_stereo()."]
  pub fn FLAC__stream_encoder_get_loose_mid_side_stereo(
    encoder: *const FLAC__StreamEncoder,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Get the maximum LPC order setting.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval uint32_t\n    See FLAC__stream_encoder_set_max_lpc_order()."]
  pub fn FLAC__stream_encoder_get_max_lpc_order(encoder: *const FLAC__StreamEncoder) -> u32;
}
extern "C" {
  #[doc = " Get the quantized linear predictor coefficient precision setting.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval uint32_t\n    See FLAC__stream_encoder_set_qlp_coeff_precision()."]
  pub fn FLAC__stream_encoder_get_qlp_coeff_precision(encoder: *const FLAC__StreamEncoder) -> u32;
}
extern "C" {
  #[doc = " Get the qlp coefficient precision search flag.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    See FLAC__stream_encoder_set_do_qlp_coeff_prec_search()."]
  pub fn FLAC__stream_encoder_get_do_qlp_coeff_prec_search(
    encoder: *const FLAC__StreamEncoder,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Get the \"escape coding\" flag.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    See FLAC__stream_encoder_set_do_escape_coding()."]
  pub fn FLAC__stream_encoder_get_do_escape_coding(
    encoder: *const FLAC__StreamEncoder,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Get the exhaustive model search flag.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    See FLAC__stream_encoder_set_do_exhaustive_model_search()."]
  pub fn FLAC__stream_encoder_get_do_exhaustive_model_search(
    encoder: *const FLAC__StreamEncoder,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Get the minimum residual partition order setting.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval uint32_t\n    See FLAC__stream_encoder_set_min_residual_partition_order()."]
  pub fn FLAC__stream_encoder_get_min_residual_partition_order(
    encoder: *const FLAC__StreamEncoder,
  ) -> u32;
}
extern "C" {
  #[doc = " Get maximum residual partition order setting.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval uint32_t\n    See FLAC__stream_encoder_set_max_residual_partition_order()."]
  pub fn FLAC__stream_encoder_get_max_residual_partition_order(
    encoder: *const FLAC__StreamEncoder,
  ) -> u32;
}
extern "C" {
  #[doc = " Get maximum number of threads setting.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval uint32_t\n    See FLAC__stream_encoder_set_num_threads()."]
  pub fn FLAC__stream_encoder_get_num_threads(encoder: *const FLAC__StreamEncoder) -> u32;
}
extern "C" {
  #[doc = " Get the Rice parameter search distance setting.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval uint32_t\n    See FLAC__stream_encoder_set_rice_parameter_search_dist()."]
  pub fn FLAC__stream_encoder_get_rice_parameter_search_dist(
    encoder: *const FLAC__StreamEncoder,
  ) -> u32;
}
extern "C" {
  #[doc = " Get the previously set estimate of the total samples to be encoded.\n  The encoder merely mimics back the value given to\n  FLAC__stream_encoder_set_total_samples_estimate() since it has no\n  other way of knowing how many samples the client will encode.\n\n \\param  encoder  An encoder instance to set.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__uint64\n    See FLAC__stream_encoder_get_total_samples_estimate()."]
  pub fn FLAC__stream_encoder_get_total_samples_estimate(
    encoder: *const FLAC__StreamEncoder,
  ) -> FLAC__uint64;
}
extern "C" {
  #[doc = " Get the \"limit_min_bitrate\" flag.\n\n \\param  encoder  An encoder instance to query.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    See FLAC__stream_encoder_set_limit_min_bitrate()."]
  pub fn FLAC__stream_encoder_get_limit_min_bitrate(
    encoder: *const FLAC__StreamEncoder,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Initialize the encoder instance to encode native FLAC streams.\n\n  This flavor of initialization sets up the encoder to encode to a\n  native FLAC stream. I/O is performed via callbacks to the client.\n  For encoding to a plain file via filename or open \\c FILE*,\n  FLAC__stream_encoder_init_file() and FLAC__stream_encoder_init_FILE()\n  provide a simpler interface.\n\n  This function should be called after FLAC__stream_encoder_new() and\n  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()\n  or FLAC__stream_encoder_process_interleaved().\n  initialization succeeded.\n\n  The call to FLAC__stream_encoder_init_stream() currently will also\n  immediately call the write callback several times, once with the \\c fLaC\n  signature, and once for each encoded metadata block.\n\n \\param  encoder            An uninitialized encoder instance.\n \\param  write_callback     See FLAC__StreamEncoderWriteCallback.  This\n                            pointer must not be \\c NULL.\n \\param  seek_callback      See FLAC__StreamEncoderSeekCallback.  This\n                            pointer may be \\c NULL if seeking is not\n                            supported.  The encoder uses seeking to go back\n                            and write some some stream statistics to the\n                            STREAMINFO block; this is recommended but not\n                            necessary to create a valid FLAC stream.  If\n                            \\a seek_callback is not \\c NULL then a\n                            \\a tell_callback must also be supplied.\n                            Alternatively, a dummy seek callback that just\n                            returns \\c FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED\n                            may also be supplied, all though this is slightly\n                            less efficient for the encoder.\n \\param  tell_callback      See FLAC__StreamEncoderTellCallback.  This\n                            pointer may be \\c NULL if seeking is not\n                            supported.  If \\a seek_callback is \\c NULL then\n                            this argument will be ignored.  If\n                            \\a seek_callback is not \\c NULL then a\n                            \\a tell_callback must also be supplied.\n                            Alternatively, a dummy tell callback that just\n                            returns \\c FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED\n                            may also be supplied, all though this is slightly\n                            less efficient for the encoder.\n \\param  metadata_callback  See FLAC__StreamEncoderMetadataCallback.  This\n                            pointer may be \\c NULL if the callback is not\n                            desired.  If the client provides a seek callback,\n                            this function is not necessary as the encoder\n                            will automatically seek back and update the\n                            STREAMINFO block.  It may also be \\c NULL if the\n                            client does not support seeking, since it will\n                            have no way of going back to update the\n                            STREAMINFO.  However the client can still supply\n                            a callback if it would like to know the details\n                            from the STREAMINFO.\n \\param  client_data        This value will be supplied to callbacks in their\n                            \\a client_data argument.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__StreamEncoderInitStatus\n    \\c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;\n    see FLAC__StreamEncoderInitStatus for the meanings of other return values."]
  pub fn FLAC__stream_encoder_init_stream(
    encoder: *mut FLAC__StreamEncoder,
    write_callback: FLAC__StreamEncoderWriteCallback,
    seek_callback: FLAC__StreamEncoderSeekCallback,
    tell_callback: FLAC__StreamEncoderTellCallback,
    metadata_callback: FLAC__StreamEncoderMetadataCallback,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
  #[doc = " Initialize the encoder instance to encode Ogg FLAC streams.\n\n  This flavor of initialization sets up the encoder to encode to a FLAC\n  stream in an Ogg container.  I/O is performed via callbacks to the\n  client.  For encoding to a plain file via filename or open \\c FILE*,\n  FLAC__stream_encoder_init_ogg_file() and FLAC__stream_encoder_init_ogg_FILE()\n  provide a simpler interface.\n\n  This function should be called after FLAC__stream_encoder_new() and\n  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()\n  or FLAC__stream_encoder_process_interleaved().\n  initialization succeeded.\n\n  The call to FLAC__stream_encoder_init_ogg_stream() currently will also\n  immediately call the write callback several times to write the metadata\n  packets.\n\n \\param  encoder            An uninitialized encoder instance.\n \\param  read_callback      See FLAC__StreamEncoderReadCallback.  This\n                            pointer must not be \\c NULL if \\a seek_callback\n                            is non-NULL since they are both needed to be\n                            able to write data back to the Ogg FLAC stream\n                            in the post-encode phase.\n \\param  write_callback     See FLAC__StreamEncoderWriteCallback.  This\n                            pointer must not be \\c NULL.\n \\param  seek_callback      See FLAC__StreamEncoderSeekCallback.  This\n                            pointer may be \\c NULL if seeking is not\n                            supported.  The encoder uses seeking to go back\n                            and write some some stream statistics to the\n                            STREAMINFO block; this is recommended but not\n                            necessary to create a valid FLAC stream.  If\n                            \\a seek_callback is not \\c NULL then a\n                            \\a tell_callback must also be supplied.\n                            Alternatively, a dummy seek callback that just\n                            returns \\c FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED\n                            may also be supplied, all though this is slightly\n                            less efficient for the encoder.\n \\param  tell_callback      See FLAC__StreamEncoderTellCallback.  This\n                            pointer may be \\c NULL if seeking is not\n                            supported.  If \\a seek_callback is \\c NULL then\n                            this argument will be ignored.  If\n                            \\a seek_callback is not \\c NULL then a\n                            \\a tell_callback must also be supplied.\n                            Alternatively, a dummy tell callback that just\n                            returns \\c FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED\n                            may also be supplied, all though this is slightly\n                            less efficient for the encoder.\n \\param  metadata_callback  See FLAC__StreamEncoderMetadataCallback.  This\n                            pointer may be \\c NULL if the callback is not\n                            desired.  If the client provides a seek callback,\n                            this function is not necessary as the encoder\n                            will automatically seek back and update the\n                            STREAMINFO block.  It may also be \\c NULL if the\n                            client does not support seeking, since it will\n                            have no way of going back to update the\n                            STREAMINFO.  However the client can still supply\n                            a callback if it would like to know the details\n                            from the STREAMINFO.\n \\param  client_data        This value will be supplied to callbacks in their\n                            \\a client_data argument.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__StreamEncoderInitStatus\n    \\c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;\n    see FLAC__StreamEncoderInitStatus for the meanings of other return values."]
  pub fn FLAC__stream_encoder_init_ogg_stream(
    encoder: *mut FLAC__StreamEncoder,
    read_callback: FLAC__StreamEncoderReadCallback,
    write_callback: FLAC__StreamEncoderWriteCallback,
    seek_callback: FLAC__StreamEncoderSeekCallback,
    tell_callback: FLAC__StreamEncoderTellCallback,
    metadata_callback: FLAC__StreamEncoderMetadataCallback,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
  #[doc = " Initialize the encoder instance to encode native FLAC files.\n\n  This flavor of initialization sets up the encoder to encode to a\n  plain native FLAC file.  For non-stdio streams, you must use\n  FLAC__stream_encoder_init_stream() and provide callbacks for the I/O.\n\n  This function should be called after FLAC__stream_encoder_new() and\n  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()\n  or FLAC__stream_encoder_process_interleaved().\n  initialization succeeded.\n\n \\param  encoder            An uninitialized encoder instance.\n \\param  file               An open file.  The file should have been opened\n                            with mode \\c \"w+b\" and rewound.  The file\n                            becomes owned by the encoder and should not be\n                            manipulated by the client while encoding.\n                            Unless \\a file is \\c stdout, it will be closed\n                            when FLAC__stream_encoder_finish() is called.\n                            Note however that a proper SEEKTABLE cannot be\n                            created when encoding to \\c stdout since it is\n                            not seekable.\n \\param  progress_callback  See FLAC__StreamEncoderProgressCallback.  This\n                            pointer may be \\c NULL if the callback is not\n                            desired.\n \\param  client_data        This value will be supplied to callbacks in their\n                            \\a client_data argument.\n \\assert\n    \\code encoder != NULL \\endcode\n    \\code file != NULL \\endcode\n \\retval FLAC__StreamEncoderInitStatus\n    \\c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;\n    see FLAC__StreamEncoderInitStatus for the meanings of other return values."]
  pub fn FLAC__stream_encoder_init_FILE(
    encoder: *mut FLAC__StreamEncoder,
    file: *mut FILE,
    progress_callback: FLAC__StreamEncoderProgressCallback,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
  #[doc = " Initialize the encoder instance to encode Ogg FLAC files.\n\n  This flavor of initialization sets up the encoder to encode to a\n  plain Ogg FLAC file.  For non-stdio streams, you must use\n  FLAC__stream_encoder_init_ogg_stream() and provide callbacks for the I/O.\n\n  This function should be called after FLAC__stream_encoder_new() and\n  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()\n  or FLAC__stream_encoder_process_interleaved().\n  initialization succeeded.\n\n \\param  encoder            An uninitialized encoder instance.\n \\param  file               An open file.  The file should have been opened\n                            with mode \\c \"w+b\" and rewound.  The file\n                            becomes owned by the encoder and should not be\n                            manipulated by the client while encoding.\n                            Unless \\a file is \\c stdout, it will be closed\n                            when FLAC__stream_encoder_finish() is called.\n                            Note however that a proper SEEKTABLE cannot be\n                            created when encoding to \\c stdout since it is\n                            not seekable.\n \\param  progress_callback  See FLAC__StreamEncoderProgressCallback.  This\n                            pointer may be \\c NULL if the callback is not\n                            desired.\n \\param  client_data        This value will be supplied to callbacks in their\n                            \\a client_data argument.\n \\assert\n    \\code encoder != NULL \\endcode\n    \\code file != NULL \\endcode\n \\retval FLAC__StreamEncoderInitStatus\n    \\c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;\n    see FLAC__StreamEncoderInitStatus for the meanings of other return values."]
  pub fn FLAC__stream_encoder_init_ogg_FILE(
    encoder: *mut FLAC__StreamEncoder,
    file: *mut FILE,
    progress_callback: FLAC__StreamEncoderProgressCallback,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
  #[doc = " Initialize the encoder instance to encode native FLAC files.\n\n  This flavor of initialization sets up the encoder to encode to a plain\n  FLAC file.  If POSIX fopen() semantics are not sufficient you must use\n  FLAC__stream_encoder_init_FILE(), or FLAC__stream_encoder_init_stream()\n  and provide callbacks for the I/O.\n\n  On Windows, filename must be a UTF-8 encoded filename, which libFLAC\n  internally translates to an appropriate representation to use with\n  _wfopen. On all other systems, filename is passed to fopen without\n  any translation.\n\n  This function should be called after FLAC__stream_encoder_new() and\n  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()\n  or FLAC__stream_encoder_process_interleaved().\n  initialization succeeded.\n\n \\param  encoder            An uninitialized encoder instance.\n \\param  filename           The name of the file to encode to.  The file will\n                            be opened with fopen().  Use \\c NULL to encode to\n                            \\c stdout.  Note however that a proper SEEKTABLE\n                            cannot be created when encoding to \\c stdout since\n                            it is not seekable.\n \\param  progress_callback  See FLAC__StreamEncoderProgressCallback.  This\n                            pointer may be \\c NULL if the callback is not\n                            desired.\n \\param  client_data        This value will be supplied to callbacks in their\n                            \\a client_data argument.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__StreamEncoderInitStatus\n    \\c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;\n    see FLAC__StreamEncoderInitStatus for the meanings of other return values."]
  pub fn FLAC__stream_encoder_init_file(
    encoder: *mut FLAC__StreamEncoder,
    filename: *const ::std::os::raw::c_char,
    progress_callback: FLAC__StreamEncoderProgressCallback,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
  #[doc = " Initialize the encoder instance to encode Ogg FLAC files.\n\n  This flavor of initialization sets up the encoder to encode to a plain\n  Ogg FLAC file.  If POSIX fopen() semantics are not sufficient, you must use\n  FLAC__stream_encoder_init_ogg_FILE(), or FLAC__stream_encoder_init_ogg_stream()\n  and provide callbacks for the I/O.\n\n  On Windows, filename must be a UTF-8 encoded filename, which libFLAC\n  internally translates to an appropriate representation to use with\n  _wfopen. On all other systems, filename is passed to fopen without\n  any translation.\n\n  This function should be called after FLAC__stream_encoder_new() and\n  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()\n  or FLAC__stream_encoder_process_interleaved().\n  initialization succeeded.\n\n \\param  encoder            An uninitialized encoder instance.\n \\param  filename           The name of the file to encode to.  The file will\n                            be opened with fopen().  Use \\c NULL to encode to\n                            \\c stdout.  Note however that a proper SEEKTABLE\n                            cannot be created when encoding to \\c stdout since\n                            it is not seekable.\n \\param  progress_callback  See FLAC__StreamEncoderProgressCallback.  This\n                            pointer may be \\c NULL if the callback is not\n                            desired.\n \\param  client_data        This value will be supplied to callbacks in their\n                            \\a client_data argument.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__StreamEncoderInitStatus\n    \\c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;\n    see FLAC__StreamEncoderInitStatus for the meanings of other return values."]
  pub fn FLAC__stream_encoder_init_ogg_file(
    encoder: *mut FLAC__StreamEncoder,
    filename: *const ::std::os::raw::c_char,
    progress_callback: FLAC__StreamEncoderProgressCallback,
    client_data: *mut ::std::os::raw::c_void,
  ) -> FLAC__StreamEncoderInitStatus;
}
extern "C" {
  #[doc = " Finish the encoding process.\n  Flushes the encoding buffer, releases resources, resets the encoder\n  settings to their defaults, and returns the encoder state to\n  FLAC__STREAM_ENCODER_UNINITIALIZED.  Note that this can generate\n  one or more write callbacks before returning, and will generate\n  a metadata callback.\n\n  Note that in the course of processing the last frame, errors can\n  occur, so the caller should be sure to check the return value to\n  ensure the file was encoded properly.\n\n  In the event of a prematurely-terminated encode, it is not strictly\n  necessary to call this immediately before FLAC__stream_encoder_delete()\n  but it is good practice to match every FLAC__stream_encoder_init_*()\n  with a FLAC__stream_encoder_finish().\n\n \\param  encoder  An uninitialized encoder instance.\n \\assert\n    \\code encoder != NULL \\endcode\n \\retval FLAC__bool\n    \\c false if an error occurred processing the last frame; or if verify\n    mode is set (see FLAC__stream_encoder_set_verify()), there was a\n    verify mismatch; else \\c true.  If \\c false, caller should check the\n    state with FLAC__stream_encoder_get_state() for more information\n    about the error."]
  pub fn FLAC__stream_encoder_finish(encoder: *mut FLAC__StreamEncoder) -> FLAC__bool;
}
extern "C" {
  #[doc = " Submit data for encoding.\n  This version allows you to supply the input data via an array of\n  pointers, each pointer pointing to an array of \\a samples samples\n  representing one channel.  The samples need not be block-aligned,\n  but each channel should have the same number of samples.  Each sample\n  should be a signed integer, right-justified to the resolution set by\n  FLAC__stream_encoder_set_bits_per_sample().  For example, if the\n  resolution is 16 bits per sample, the samples should all be in the\n  range [-32768,32767].\n\n  For applications where channel order is important, channels must\n  follow the order as described in the\n  <A HREF=\"https://xiph.org/flac/format.html#frame_header\">frame header</A>.\n\n \\param  encoder  An initialized encoder instance in the OK state.\n \\param  buffer   An array of pointers to each channel's signal.\n \\param  samples  The number of samples in one channel.\n \\assert\n    \\code encoder != NULL \\endcode\n    \\code FLAC__stream_encoder_get_state(encoder) == FLAC__STREAM_ENCODER_OK \\endcode\n \\retval FLAC__bool\n    \\c true if successful, else \\c false; in this case, check the\n    encoder state with FLAC__stream_encoder_get_state() to see what\n    went wrong."]
  pub fn FLAC__stream_encoder_process(
    encoder: *mut FLAC__StreamEncoder,
    buffer: *const *const FLAC__int32,
    samples: u32,
  ) -> FLAC__bool;
}
extern "C" {
  #[doc = " Submit data for encoding.\n  This version allows you to supply the input data where the channels\n  are interleaved into a single array (i.e. channel0_sample0,\n  channel1_sample0, ... , channelN_sample0, channel0_sample1, ...).\n  The samples need not be block-aligned but they must be\n  sample-aligned, i.e. the first value should be channel0_sample0\n  and the last value channelN_sampleM.  Each sample should be a signed\n  integer, right-justified to the resolution set by\n  FLAC__stream_encoder_set_bits_per_sample().  For example, if the\n  resolution is 16 bits per sample, the samples should all be in the\n  range [-32768,32767].\n\n  For applications where channel order is important, channels must\n  follow the order as described in the\n  <A HREF=\"https://xiph.org/flac/format.html#frame_header\">frame header</A>.\n\n \\param  encoder  An initialized encoder instance in the OK state.\n \\param  buffer   An array of channel-interleaved data (see above).\n \\param  samples  The number of samples in one channel, the same as for\n                  FLAC__stream_encoder_process().  For example, if\n                  encoding two channels, \\c 1000 \\a samples corresponds\n                  to a \\a buffer of 2000 values.\n \\assert\n    \\code encoder != NULL \\endcode\n    \\code FLAC__stream_encoder_get_state(encoder) == FLAC__STREAM_ENCODER_OK \\endcode\n \\retval FLAC__bool\n    \\c true if successful, else \\c false; in this case, check the\n    encoder state with FLAC__stream_encoder_get_state() to see what\n    went wrong."]
  pub fn FLAC__stream_encoder_process_interleaved(
    encoder: *mut FLAC__StreamEncoder,
    buffer: *const FLAC__int32,
    samples: u32,
  ) -> FLAC__bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
  pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
  pub _address: u8,
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
